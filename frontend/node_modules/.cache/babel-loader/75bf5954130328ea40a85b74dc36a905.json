{"ast":null,"code":"import { __assign, __spreadArrays, __rest, __extends } from 'tslib';\nimport sync, { getFrameData, cancelSync } from 'framesync';\nimport { velocityPerSecond, mix, clamp, distance, progress, linear as linear$1, circOut, interpolate, wrap } from '@popmotion/popcorn';\nimport { invariant, warning } from 'hey-listen';\nimport { number, color, complex, px, percent, degrees, vw, vh, scale, alpha, progressPercentage } from 'style-value-types';\nimport { action, delay, tween, spring, keyframes as keyframes$1, inertia } from 'popmotion';\nimport * as easingLookup from '@popmotion/easing';\nimport { cubicBezier, linear } from '@popmotion/easing';\nimport React__default, { useRef, createContext, useContext, useEffect, createElement, useMemo, Component, forwardRef, Fragment, useCallback, useState, cloneElement, Children, isValidElement, useLayoutEffect } from 'react';\n\nvar isRefObject = function (ref) {\n  return typeof ref === \"object\" && ref.hasOwnProperty(\"current\");\n};\n\nvar isFloat = function (value) {\n  return !isNaN(parseFloat(value));\n};\n/**\r\n * `MotionValue` is used to track the state and velocity of motion values.\r\n *\r\n * @public\r\n */\n\n\nvar MotionValue =\n/** @class */\nfunction () {\n  /**\r\n   * @param init - The initiating value\r\n   * @param config - Optional configuration options\r\n   *\r\n   * -  `transformer`: A function to transform incoming values with.\r\n   *\r\n   * @internal\r\n   */\n  function MotionValue(init) {\n    var _this = this;\n    /**\r\n     * Duration, in milliseconds, since last updating frame.\r\n     *\r\n     * @internal\r\n     */\n\n\n    this.timeDelta = 0;\n    /**\r\n     * Timestamp of the last time this `MotionValue` was updated.\r\n     *\r\n     * @internal\r\n     */\n\n    this.lastUpdated = 0;\n    /**\r\n     * Tracks whether this value can output a velocity. Currently this is only true\r\n     * if the value is numerical, but we might be able to widen the scope here and support\r\n     * other value types.\r\n     *\r\n     * @internal\r\n     */\n\n    this.canTrackVelocity = false;\n\n    this.updateAndNotify = function (v, render) {\n      if (render === void 0) {\n        render = true;\n      }\n\n      _this.prev = _this.current;\n      _this.current = v;\n\n      if (_this.updateSubscribers && _this.prev !== _this.current) {\n        _this.updateSubscribers.forEach(_this.notifySubscriber);\n      }\n\n      if (render && _this.renderSubscribers) {\n        _this.renderSubscribers.forEach(_this.notifySubscriber);\n      } // Update timestamp\n\n\n      var _a = getFrameData(),\n          delta = _a.delta,\n          timestamp = _a.timestamp;\n\n      if (_this.lastUpdated !== timestamp) {\n        _this.timeDelta = delta;\n        _this.lastUpdated = timestamp;\n        sync.postRender(_this.scheduleVelocityCheck);\n      }\n    };\n    /**\r\n     * Notify a subscriber with the latest value.\r\n     *\r\n     * This is an instanced and bound function to prevent generating a new\r\n     * function once per frame.\r\n     *\r\n     * @param subscriber - The subscriber to notify.\r\n     *\r\n     * @internal\r\n     */\n\n\n    this.notifySubscriber = function (subscriber) {\n      subscriber(_this.current);\n    };\n    /**\r\n     * Schedule a velocity check for the next frame.\r\n     *\r\n     * This is an instanced and bound function to prevent generating a new\r\n     * function once per frame.\r\n     *\r\n     * @internal\r\n     */\n\n\n    this.scheduleVelocityCheck = function () {\n      return sync.postRender(_this.velocityCheck);\n    };\n    /**\r\n     * Updates `prev` with `current` if the value hasn't been updated this frame.\r\n     * This ensures velocity calculations return `0`.\r\n     *\r\n     * This is an instanced and bound function to prevent generating a new\r\n     * function once per frame.\r\n     *\r\n     * @internal\r\n     */\n\n\n    this.velocityCheck = function (_a) {\n      var timestamp = _a.timestamp;\n\n      if (timestamp !== _this.lastUpdated) {\n        _this.prev = _this.current;\n      }\n    };\n\n    this.set(init, false);\n    this.canTrackVelocity = isFloat(this.current);\n  }\n  /**\r\n   * Subscribes a subscriber function to a subscription list.\r\n   *\r\n   * @param subscriptions - A `Set` of subscribers.\r\n   * @param subscription - A subscriber function.\r\n   */\n\n\n  MotionValue.prototype.subscribeTo = function (subscriptions, subscription) {\n    var _this = this;\n\n    var updateSubscriber = function () {\n      return subscription(_this.current);\n    };\n\n    subscriptions.add(updateSubscriber);\n    return function () {\n      return subscriptions.delete(updateSubscriber);\n    };\n  };\n  /**\r\n   * Adds a function that will be notified when the `MotionValue` is updated.\r\n   *\r\n   * It returns a function that, when called, will cancel the subscription.\r\n   *\r\n   * When calling `onChange` inside a React component, it should be wrapped with the\r\n   * `useEffect` hook. As it returns an unsubscribe function, this should be returned\r\n   * from the `useEffect` function to ensure you don't add duplicate subscribers..\r\n   *\r\n   * @library\r\n   *\r\n   * ```jsx\r\n   * function MyComponent() {\r\n   *   const x = useMotionValue(0)\r\n   *   const y = useMotionValue(0)\r\n   *   const opacity = useMotionValue(1)\r\n   *\r\n   *   useEffect(() => {\r\n   *     function updateOpacity() {\r\n   *       const maxXY = Math.max(x.get(), y.get())\r\n   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\r\n   *       opacity.set(newOpacity)\r\n   *     }\r\n   *\r\n   *     const unsubscribeX = x.onChange(updateOpacity)\r\n   *     const unsubscribeY = y.onChange(updateOpacity)\r\n   *\r\n   *     return () => {\r\n   *       unsubscribeX()\r\n   *       unsubscribeY()\r\n   *     }\r\n   *   }, [])\r\n   *\r\n   *   return <Frame x={x} />\r\n   * }\r\n   * ```\r\n   *\r\n   * @motion\r\n   *\r\n   * ```jsx\r\n   * export const MyComponent = () => {\r\n   *   const x = useMotionValue(0)\r\n   *   const y = useMotionValue(0)\r\n   *   const opacity = useMotionValue(1)\r\n   *\r\n   *   useEffect(() => {\r\n   *     function updateOpacity() {\r\n   *       const maxXY = Math.max(x.get(), y.get())\r\n   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\r\n   *       opacity.set(newOpacity)\r\n   *     }\r\n   *\r\n   *     const unsubscribeX = x.onChange(updateOpacity)\r\n   *     const unsubscribeY = y.onChange(updateOpacity)\r\n   *\r\n   *     return () => {\r\n   *       unsubscribeX()\r\n   *       unsubscribeY()\r\n   *     }\r\n   *   }, [])\r\n   *\r\n   *   return <motion.div style={{ x }} />\r\n   * }\r\n   * ```\r\n   *\r\n   * @internalremarks\r\n   *\r\n   * We could look into a `useOnChange` hook if the above lifecycle management proves confusing.\r\n   *\r\n   * ```jsx\r\n   * useOnChange(x, () => {})\r\n   * ```\r\n   *\r\n   * @param subscriber - A function that receives the latest value.\r\n   * @returns A function that, when called, will cancel this subscription.\r\n   *\r\n   * @public\r\n   */\n\n\n  MotionValue.prototype.onChange = function (subscription) {\n    if (!this.updateSubscribers) this.updateSubscribers = new Set();\n    return this.subscribeTo(this.updateSubscribers, subscription);\n  };\n\n  MotionValue.prototype.clearListeners = function () {\n    var _a;\n\n    (_a = this.updateSubscribers) === null || _a === void 0 ? void 0 : _a.clear();\n  };\n  /**\r\n   * Adds a function that will be notified when the `MotionValue` requests a render.\r\n   *\r\n   * @param subscriber - A function that's provided the latest value.\r\n   * @returns A function that, when called, will cancel this subscription.\r\n   *\r\n   * @internal\r\n   */\n\n\n  MotionValue.prototype.onRenderRequest = function (subscription) {\n    if (!this.renderSubscribers) this.renderSubscribers = new Set(); // Render immediately\n\n    this.notifySubscriber(subscription);\n    return this.subscribeTo(this.renderSubscribers, subscription);\n  };\n  /**\r\n   * Attaches a passive effect to the `MotionValue`.\r\n   *\r\n   * @internal\r\n   */\n\n\n  MotionValue.prototype.attach = function (passiveEffect) {\n    this.passiveEffect = passiveEffect;\n  };\n  /**\r\n   * Sets the state of the `MotionValue`.\r\n   *\r\n   * @remarks\r\n   *\r\n   * ```jsx\r\n   * const x = useMotionValue(0)\r\n   * x.set(10)\r\n   * ```\r\n   *\r\n   * @param latest - Latest value to set.\r\n   * @param render - Whether to notify render subscribers. Defaults to `true`\r\n   *\r\n   * @public\r\n   */\n\n\n  MotionValue.prototype.set = function (v, render) {\n    if (render === void 0) {\n      render = true;\n    }\n\n    if (!render || !this.passiveEffect) {\n      this.updateAndNotify(v, render);\n    } else {\n      this.passiveEffect(v, this.updateAndNotify);\n    }\n  };\n  /**\r\n   * Returns the latest state of `MotionValue`\r\n   *\r\n   * @returns - The latest state of `MotionValue`\r\n   *\r\n   * @public\r\n   */\n\n\n  MotionValue.prototype.get = function () {\n    return this.current;\n  };\n  /**\r\n   * @public\r\n   */\n\n\n  MotionValue.prototype.getPrevious = function () {\n    return this.prev;\n  };\n  /**\r\n   * Returns the latest velocity of `MotionValue`\r\n   *\r\n   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\r\n   *\r\n   * @public\r\n   */\n\n\n  MotionValue.prototype.getVelocity = function () {\n    // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\n    return this.canTrackVelocity ? // These casts could be avoided if parseFloat would be typed better\n    velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;\n  };\n  /**\r\n   * Registers a new animation to control this `MotionValue`. Only one\r\n   * animation can drive a `MotionValue` at one time.\r\n   *\r\n   * ```jsx\r\n   * value.start()\r\n   * ```\r\n   *\r\n   * @param animation - A function that starts the provided animation\r\n   *\r\n   * @internal\r\n   */\n\n\n  MotionValue.prototype.start = function (animation) {\n    var _this = this;\n\n    this.stop();\n    return new Promise(function (resolve) {\n      _this.stopAnimation = animation(resolve);\n    }).then(function () {\n      return _this.clearAnimation();\n    });\n  };\n  /**\r\n   * Stop the currently active animation.\r\n   *\r\n   * @public\r\n   */\n\n\n  MotionValue.prototype.stop = function () {\n    if (this.stopAnimation) this.stopAnimation();\n    this.clearAnimation();\n  };\n  /**\r\n   * Returns `true` if this value is currently animating.\r\n   *\r\n   * @public\r\n   */\n\n\n  MotionValue.prototype.isAnimating = function () {\n    return !!this.stopAnimation;\n  };\n\n  MotionValue.prototype.clearAnimation = function () {\n    this.stopAnimation = null;\n  };\n  /**\r\n   * Destroy and clean up subscribers to this `MotionValue`.\r\n   *\r\n   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\r\n   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\r\n   * created a `MotionValue` via the `motionValue` function.\r\n   *\r\n   * @public\r\n   */\n\n\n  MotionValue.prototype.destroy = function () {\n    this.updateSubscribers && this.updateSubscribers.clear();\n    this.renderSubscribers && this.renderSubscribers.clear();\n    this.stop();\n  };\n\n  return MotionValue;\n}();\n/**\r\n * @internal\r\n */\n\n\nfunction motionValue(init) {\n  return new MotionValue(init);\n}\n/**\r\n * VisualElement is an abstract class that provides a generic animation-optimised interface to the\r\n * underlying renderer.\r\n *\r\n * Currently many features interact directly with HTMLVisualElement/SVGVisualElement\r\n * but the idea is we can create, for instance, a ThreeVisualElement that extends\r\n * VisualElement and we can quickly offer all the same features.\r\n */\n\n\nvar VisualElement =\n/** @class */\nfunction () {\n  function VisualElement(parent, ref) {\n    var _this = this; // An iterable list of current children\n\n\n    this.children = new Set(); // The latest resolved MotionValues\n\n    this.latest = {}; // A map of MotionValues used to animate this element\n\n    this.values = new Map(); // Unsubscription callbacks for each MotionValue\n\n    this.valueSubscriptions = new Map(); // A configuration for this VisualElement, each derived class can extend this.\n\n    this.config = {}; // A pre-bound call to the user-provided `onUpdate` callback. This won't\n    // be called more than once per frame.\n\n    this.update = function () {\n      return _this.config.onUpdate(_this.latest);\n    }; // Pre-bound version of render\n\n\n    this.triggerRender = function () {\n      return _this.render();\n    };\n\n    this.scheduleRender = function () {\n      return sync.render(_this.triggerRender, false, true);\n    }; // This function gets passed to the rendered component's `ref` prop\n    // and is used to mount/unmount the VisualElement\n\n\n    this.ref = function (element) {\n      element ? _this.mount(element) : _this.unmount();\n      if (!_this.externalRef) return;\n\n      if (typeof _this.externalRef === \"function\") {\n        _this.externalRef(element);\n      } else if (isRefObject(_this.externalRef)) {\n        _this.externalRef.current = element;\n      }\n    }; // Create a relationship with the provided parent. When we come to replace\n    // the auto-animation stuff with VisualElement we might need to make this\n    // relationship two-way\n\n\n    this.parent = parent;\n    this.treePath = parent ? __spreadArrays(parent.treePath, [parent]) : []; // Calculate the depth of this node in the VisualElement graph\n\n    this.depth = parent ? parent.depth + 1 : 0; // A reference to any externally-defined React ref. This might live better\n    // outside the VisualElement and be handled in a hook.\n\n    this.externalRef = ref;\n  }\n\n  VisualElement.prototype.subscribe = function (child) {\n    var _this = this;\n\n    this.children.add(child);\n    return function () {\n      return _this.children.delete(child);\n    };\n  }; // Check whether this element has a MotionValue of the provided key\n\n\n  VisualElement.prototype.hasValue = function (key) {\n    return this.values.has(key);\n  }; // Add a MotionValue\n\n\n  VisualElement.prototype.addValue = function (key, value) {\n    if (this.hasValue(key)) this.removeValue(key);\n    this.values.set(key, value);\n    this.latest[key] = value.get();\n    if (this.element) this.subscribeToValue(key, value);\n  }; // Remove a MotionValue\n\n\n  VisualElement.prototype.removeValue = function (key) {\n    var unsubscribe = this.valueSubscriptions.get(key);\n    unsubscribe && unsubscribe();\n    this.values.delete(key);\n    delete this.latest[key];\n    this.valueSubscriptions.delete(key);\n  };\n\n  VisualElement.prototype.getValue = function (key, defaultValue) {\n    var value = this.values.get(key);\n\n    if (value === undefined && defaultValue !== undefined) {\n      value = new MotionValue(defaultValue);\n      this.addValue(key, value);\n    }\n\n    return value;\n  }; // Iterate over all MotionValues\n\n\n  VisualElement.prototype.forEachValue = function (callback) {\n    this.values.forEach(callback);\n  }; // Get the underlying rendered instance of this VisualElement. For instance in\n  // HTMLVisualElement this will be a HTMLElement.\n\n\n  VisualElement.prototype.getInstance = function () {\n    return this.element;\n  };\n\n  VisualElement.prototype.updateConfig = function (config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    this.config = __assign({}, config);\n  }; // Set a single `latest` value\n\n\n  VisualElement.prototype.setSingleStaticValue = function (key, value) {\n    this.latest[key] = value;\n  }; // Statically set values to `latest` without needing a MotionValue\n\n\n  VisualElement.prototype.setStaticValues = function (values, value) {\n    if (typeof values === \"string\") {\n      this.setSingleStaticValue(values, value);\n    } else {\n      for (var key in values) {\n        this.setSingleStaticValue(key, values[key]);\n      }\n    }\n  }; // Subscribe to changes in a MotionValue\n\n\n  VisualElement.prototype.subscribeToValue = function (key, value) {\n    var _this = this;\n\n    var onChange = function (latest) {\n      _this.setSingleStaticValue(key, latest);\n\n      _this.latest[key] = latest;\n      _this.config.onUpdate && sync.update(_this.update, false, true);\n    };\n\n    var unsubscribeOnChange = value.onChange(onChange);\n    var unsubscribeOnRender = value.onRenderRequest(this.scheduleRender);\n    this.valueSubscriptions.set(key, function () {\n      unsubscribeOnChange();\n      unsubscribeOnRender();\n    });\n  }; // Mount the VisualElement with the actual DOM element\n\n\n  VisualElement.prototype.mount = function (element) {\n    var _this = this;\n\n    invariant(!!element, \"No ref found. Ensure components created with motion.custom forward refs using React.forwardRef\");\n\n    if (this.parent) {\n      this.removeFromParent = this.parent.subscribe(this);\n      /**\r\n       * Save a reference to the nearest layout projecting ancestor.\r\n       */\n      // this.layoutParent = this.parent.isLayoutProjectionEnabled\n      //     ? this.parent\n      //     : this.parent.layoutParent\n    }\n    /**\r\n     * Save the element to this.element as a semantic API, this.current to the VisualElement\r\n     * is compatible with existing RefObject APIs.\r\n     */\n\n\n    this.element = this.current = element; // Subscribe to any pre-existing MotionValues\n\n    this.forEachValue(function (value, key) {\n      return _this.subscribeToValue(key, value);\n    });\n  }; // Unmount the VisualElement and cancel any scheduled updates\n\n\n  VisualElement.prototype.unmount = function () {\n    var _this = this;\n\n    this.forEachValue(function (_, key) {\n      return _this.removeValue(key);\n    });\n    cancelSync.update(this.update);\n    cancelSync.render(this.render);\n    this.removeFromParent && this.removeFromParent();\n  };\n\n  return VisualElement;\n}();\n\nfunction noop(any) {\n  return any;\n}\n/**\r\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\r\n * it's easier to consider each axis individually. This function returns a bounding box\r\n * as a map of single-axis min/max values.\r\n */\n\n\nfunction convertBoundingBoxToAxisBox(_a) {\n  var top = _a.top,\n      left = _a.left,\n      right = _a.right,\n      bottom = _a.bottom;\n  return {\n    x: {\n      min: left,\n      max: right\n    },\n    y: {\n      min: top,\n      max: bottom\n    }\n  };\n}\n\nfunction convertAxisBoxToBoundingBox(_a) {\n  var x = _a.x,\n      y = _a.y;\n  return {\n    top: y.min,\n    bottom: y.max,\n    left: x.min,\n    right: x.max\n  };\n}\n/**\r\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\r\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\r\n * when measuring DOM elements and DOM event points.\r\n */\n\n\nfunction transformBoundingBox(_a, transformPoint) {\n  var top = _a.top,\n      left = _a.left,\n      bottom = _a.bottom,\n      right = _a.right;\n\n  if (transformPoint === void 0) {\n    transformPoint = noop;\n  }\n\n  var topLeft = transformPoint({\n    x: left,\n    y: top\n  });\n  var bottomRight = transformPoint({\n    x: right,\n    y: bottom\n  });\n  return {\n    top: topLeft.y,\n    left: topLeft.x,\n    bottom: bottomRight.y,\n    right: bottomRight.x\n  };\n}\n/**\r\n * Create an empty axis box of zero size\r\n */\n\n\nfunction axisBox() {\n  return {\n    x: {\n      min: 0,\n      max: 1\n    },\n    y: {\n      min: 0,\n      max: 1\n    }\n  };\n}\n\nfunction copyAxisBox(box) {\n  return {\n    x: __assign({}, box.x),\n    y: __assign({}, box.y)\n  };\n}\n/**\r\n * Create an empty box delta\r\n */\n\n\nvar zeroDelta = {\n  translate: 0,\n  scale: 1,\n  origin: 0,\n  originPoint: 0\n};\n\nfunction delta() {\n  return {\n    x: __assign({}, zeroDelta),\n    y: __assign({}, zeroDelta)\n  };\n}\n/**\r\n * ValueType for \"auto\"\r\n */\n\n\nvar auto = {\n  test: function (v) {\n    return v === \"auto\";\n  },\n  parse: function (v) {\n    return v;\n  }\n};\n/**\r\n * ValueType for ints\r\n */\n\nvar int = __assign(__assign({}, number), {\n  transform: Math.round\n});\n/**\r\n * A map of default value types for common values\r\n */\n\n\nvar defaultValueTypes = {\n  // Color props\n  color: color,\n  backgroundColor: color,\n  outlineColor: color,\n  fill: color,\n  stroke: color,\n  // Border props\n  borderColor: color,\n  borderTopColor: color,\n  borderRightColor: color,\n  borderBottomColor: color,\n  borderLeftColor: color,\n  borderWidth: px,\n  borderTopWidth: px,\n  borderRightWidth: px,\n  borderBottomWidth: px,\n  borderLeftWidth: px,\n  borderRadius: px,\n  radius: px,\n  borderTopLeftRadius: px,\n  borderTopRightRadius: px,\n  borderBottomRightRadius: px,\n  borderBottomLeftRadius: px,\n  // Positioning props\n  width: px,\n  maxWidth: px,\n  height: px,\n  maxHeight: px,\n  size: px,\n  top: px,\n  right: px,\n  bottom: px,\n  left: px,\n  // Spacing props\n  padding: px,\n  paddingTop: px,\n  paddingRight: px,\n  paddingBottom: px,\n  paddingLeft: px,\n  margin: px,\n  marginTop: px,\n  marginRight: px,\n  marginBottom: px,\n  marginLeft: px,\n  // Transform props\n  rotate: degrees,\n  rotateX: degrees,\n  rotateY: degrees,\n  rotateZ: degrees,\n  scale: scale,\n  scaleX: scale,\n  scaleY: scale,\n  scaleZ: scale,\n  skew: degrees,\n  skewX: degrees,\n  skewY: degrees,\n  distance: px,\n  translateX: px,\n  translateY: px,\n  translateZ: px,\n  x: px,\n  y: px,\n  z: px,\n  perspective: px,\n  opacity: alpha,\n  originX: progressPercentage,\n  originY: progressPercentage,\n  originZ: px,\n  // Misc\n  zIndex: int,\n  // SVG\n  fillOpacity: alpha,\n  strokeOpacity: alpha,\n  numOctaves: int\n};\n/**\r\n * A list of value types commonly used for dimensions\r\n */\n\nvar dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\n/**\r\n * Tests a provided value against a ValueType\r\n */\n\nvar testValueType = function (v) {\n  return function (type) {\n    return type.test(v);\n  };\n};\n/**\r\n * Tests a dimensional value against the list of dimension ValueTypes\r\n */\n\n\nvar findDimensionValueType = function (v) {\n  return dimensionValueTypes.find(testValueType(v));\n};\n/**\r\n * A list of all ValueTypes\r\n */\n\n\nvar valueTypes = __spreadArrays(dimensionValueTypes, [color, complex]);\n/**\r\n * Tests a value against the list of ValueTypes\r\n */\n\n\nvar findValueType = function (v) {\n  return valueTypes.find(testValueType(v));\n};\n/**\r\n * Gets the default ValueType for the provided value key\r\n */\n\n\nvar getDefaultValueType = function (key) {\n  return defaultValueTypes[key];\n};\n/**\r\n * Provided a value and a ValueType, returns the value as that value type.\r\n */\n\n\nvar getValueAsType = function (value, type) {\n  return type && typeof value === \"number\" ? type.transform(value) : value;\n};\n/**\r\n * A list of all transformable axes. We'll use this list to generated a version\r\n * of each axes for each transform.\r\n */\n\n\nvar axes = [\"\", \"X\", \"Y\", \"Z\"];\n/**\r\n * An ordered array of each transformable value. By default, transform values\r\n * will be sorted to this order.\r\n */\n\nvar order = [\"translate\", \"scale\", \"rotate\", \"skew\", \"transformPerspective\"];\n/**\r\n * Generate a list of every possible transform key.\r\n */\n\nvar transformProps = [\"x\", \"y\", \"z\"];\norder.forEach(function (operationKey) {\n  axes.forEach(function (axesKey) {\n    return transformProps.push(operationKey + axesKey);\n  });\n});\n/**\r\n * A function to use with Array.sort to sort transform keys by their default order.\r\n */\n\nfunction sortTransformProps(a, b) {\n  return transformProps.indexOf(a) - transformProps.indexOf(b);\n}\n/**\r\n * A quick lookup for transform props.\r\n */\n\n\nvar transformPropSet = new Set(transformProps);\n\nfunction isTransformProp(key) {\n  return transformPropSet.has(key);\n}\n/**\r\n * A quick lookup for transform origin props\r\n */\n\n\nvar transformOriginProps = new Set([\"originX\", \"originY\", \"originZ\"]);\n\nfunction isTransformOriginProp(key) {\n  return transformOriginProps.has(key);\n}\n\nvar translateAlias = {\n  x: \"translateX\",\n  y: \"translateY\",\n  z: \"translateZ\"\n};\n/**\r\n * Build a CSS transform style from individual x/y/scale etc properties.\r\n *\r\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\r\n * providing a transformTemplate function.\r\n */\n\nfunction buildTransform(transform, transformKeys, transformTemplate, transformIsDefault, enableHardwareAcceleration, allowTransformNone) {\n  if (enableHardwareAcceleration === void 0) {\n    enableHardwareAcceleration = true;\n  }\n\n  if (allowTransformNone === void 0) {\n    allowTransformNone = true;\n  } // The transform string we're going to build into\n\n\n  var transformString = \"\"; // Track whether the defined transform has a defined z so we don't add a\n  // second to enable hardware acceleration\n\n  var transformHasZ = false; // Transform keys into their default order - this will determine the output order.\n\n  transformKeys.sort(sortTransformProps); // Loop over each transform and build them into transformString\n\n  var numTransformKeys = transformKeys.length;\n\n  for (var i = 0; i < numTransformKeys; i++) {\n    var key = transformKeys[i];\n    transformString += (translateAlias[key] || key) + \"(\" + transform[key] + \") \";\n    if (key === \"z\") transformHasZ = true;\n  }\n\n  if (!transformHasZ && enableHardwareAcceleration) {\n    transformString += \"translateZ(0)\";\n  } else {\n    transformString = transformString.trim();\n  } // If we have a custom `transform` template, pass our transform values and\n  // generated transformString to that before returning\n\n\n  if (transformTemplate) {\n    transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n  } else if (allowTransformNone && transformIsDefault) {\n    transformString = \"none\";\n  }\n\n  return transformString;\n}\n/**\r\n * Returns true if the provided key is a CSS variable\r\n */\n\n\nfunction isCSSVariable(key) {\n  return key.startsWith(\"--\");\n}\n\nfunction pixelsToPercent(pixels, axis) {\n  return pixels / (axis.max - axis.min) * 100;\n}\n/**\r\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\r\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\r\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\r\n * borderRadius in both states. If we animate between the two in pixels that will trigger\r\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\r\n */\n\n\nfunction correctBorderRadius(latest, viewportBox) {\n  /**\r\n   * If latest is a string, we either presume it's already a percentage, in which case it'll\r\n   * already be stretched appropriately, or it's another value type which we don't support.\r\n   */\n  if (typeof latest !== \"number\") return latest;\n  /**\r\n   * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\r\n   * pixel value as a percentage of each axis\r\n   */\n\n  var x = pixelsToPercent(latest, viewportBox.x);\n  var y = pixelsToPercent(latest, viewportBox.y);\n  return x + \"% \" + y + \"%\";\n}\n\nfunction correctBoxShadow(latest, _viewportBox, delta, treeScale) {\n  // GC Warning - this creates a function and object every frame\n  var shadow = complex.parse(latest);\n  var template = complex.createTransformer(latest); // Calculate the overall context scale\n\n  var xScale = delta.x.scale * treeScale.x;\n  var yScale = delta.y.scale * treeScale.y; // Scale x/y\n\n  shadow[1] /= xScale;\n  shadow[2] /= yScale;\n  /**\r\n   * Ideally we'd correct x and y scales individually, but because blur and\r\n   * spread apply to both we have to take a scale average and apply that instead.\r\n   * We could potentially improve the outcome of this by incorporating the ratio between\r\n   * the two scales.\r\n   */\n\n  var averageScale = mix(xScale, yScale, 0.5); // Blur\n\n  if (typeof shadow[3] === \"number\") shadow[3] /= averageScale; // Spread\n\n  if (typeof shadow[4] === \"number\") shadow[4] /= averageScale;\n  return template(shadow);\n}\n\nvar borderCorrectionDefinition = {\n  process: correctBorderRadius\n};\nvar valueScaleCorrection = {\n  borderRadius: __assign(__assign({}, borderCorrectionDefinition), {\n    applyTo: [\"borderTopLeftRadius\", \"borderTopRightRadius\", \"borderBottomLeftRadius\", \"borderBottomRightRadius\"]\n  }),\n  borderTopLeftRadius: borderCorrectionDefinition,\n  borderTopRightRadius: borderCorrectionDefinition,\n  borderBottomLeftRadius: borderCorrectionDefinition,\n  borderBottomRightRadius: borderCorrectionDefinition,\n  boxShadow: {\n    process: correctBoxShadow\n  }\n};\n/**\r\n * @internal\r\n */\n\nfunction addScaleCorrection(correctors) {\n  for (var key in correctors) {\n    valueScaleCorrection[key] = correctors[key];\n  }\n}\n/**\r\n * Build style and CSS variables\r\n *\r\n * This function converts a Motion style prop:\r\n *\r\n * { x: 100, width: 100, originX: 0.5 }\r\n *\r\n * Into an object with default value types applied and default\r\n * transform order set:\r\n *\r\n * {\r\n *   transform: 'translateX(100px) translateZ(0)`,\r\n *   width: '100px',\r\n *   transformOrigin: '50% 50%'\r\n * }\r\n *\r\n * Styles are saved to `style` and CSS vars to `vars`.\r\n *\r\n * This function works with mutative data structures.\r\n */\n\n\nfunction buildHTMLStyles(latest, style, vars, transform, transformOrigin, transformKeys, _a, isLayoutProjectionEnabled, delta, deltaFinal, treeScale, targetBox) {\n  var enableHardwareAcceleration = _a.enableHardwareAcceleration,\n      transformTemplate = _a.transformTemplate,\n      allowTransformNone = _a.allowTransformNone; // Empty the transformKeys array. As we're throwing out refs to its items\n  // this might not be as cheap as suspected. Maybe using the array as a buffer\n  // with a manual incrementation would be better.\n\n  transformKeys.length = 0; // Track whether we encounter any transform or transformOrigin values.\n\n  var hasTransform = !!isLayoutProjectionEnabled;\n  var hasTransformOrigin = !!isLayoutProjectionEnabled; // Does the calculated transform essentially equal \"none\"?\n\n  var transformIsNone = true;\n  /**\r\n   * Loop over all our latest animated values and decide whether to handle them\r\n   * as a style or CSS variable. Transforms and transform origins are kept seperately\r\n   * for further processing\r\n   */\n\n  for (var key in latest) {\n    var value = latest[key]; // Convert the value to its default value type, ie 0 -> \"0px\"\n\n    var valueType = getDefaultValueType(key);\n    var valueAsType = getValueAsType(value, valueType);\n\n    if (isTransformProp(key)) {\n      // If this is a transform, flag and enable further transform processing\n      hasTransform = true;\n      transform[key] = valueAsType;\n      transformKeys.push(key);\n      if (!transformIsNone) continue; // If all the transform keys we've so far encountered are their default value\n      // then check to see if this one isn't\n\n      var defaultValue = valueType.default !== undefined ? valueType.default : 0;\n      if (value !== defaultValue) transformIsNone = false;\n    } else if (isTransformOriginProp(key)) {\n      // If this is a transform origin, flag and enable further transform-origin processing\n      transformOrigin[key] = valueAsType;\n      hasTransformOrigin = true;\n    } else if (key !== \"transform\" || typeof value !== \"function\") {\n      // Handle all remaining values. Decide which map to save to depending\n      // on whether this is a CSS variable\n      var bucket = isCSSVariable(key) ? vars : style; // If we need to perform scale correction, and we have a handler for this\n      // value type (ie borderRadius), perform it\n\n      if (isLayoutProjectionEnabled && valueScaleCorrection[key]) {\n        var corrected = valueScaleCorrection[key].process(value, targetBox, delta, treeScale);\n        /**\r\n         * Scale-correctable values can define a number of other values to break\r\n         * down into. For instance borderRadius needs applying to borderBottomLeftRadius etc\r\n         */\n\n        var applyTo = valueScaleCorrection[key].applyTo;\n\n        if (applyTo) {\n          var num = applyTo.length;\n\n          for (var i = 0; i < num; i++) {\n            bucket[applyTo[i]] = corrected;\n          }\n        } else {\n          bucket[key] = corrected;\n        }\n      } else {\n        bucket[key] = valueAsType;\n      }\n    }\n  } // Only process transform if values aren't defaults\n\n\n  if (hasTransform || transformTemplate) {\n    if (!isLayoutProjectionEnabled) {\n      style.transform = buildTransform(transform, transformKeys, transformTemplate, transformIsNone, enableHardwareAcceleration, allowTransformNone);\n    } else {\n      style.transform = layoutReprojection(deltaFinal, treeScale);\n    }\n  } // Only process transform origin if values aren't default\n\n\n  if (hasTransformOrigin) {\n    var originX = isLayoutProjectionEnabled ? deltaFinal.x.origin * 100 + \"%\" : transformOrigin.originX || \"50%\";\n    var originY = isLayoutProjectionEnabled ? deltaFinal.y.origin * 100 + \"%\" : transformOrigin.originY || \"50%\";\n    var originZ = transformOrigin.originZ || \"0\";\n    style.transformOrigin = originX + \" \" + originY + \" \" + originZ;\n  }\n}\n\nfunction layoutReprojection(delta, treeScale) {\n  var x = delta.x.translate / treeScale.x;\n  var y = delta.y.translate / treeScale.y;\n  var scaleX = delta.x.scale;\n  var scaleY = delta.y.scale;\n  return \"translate3d(\" + x + \"px, \" + y + \"px, 0) scale(\" + scaleX + \", \" + scaleY + \")\";\n}\n/**\r\n * Reset an axis to the provided origin box.\r\n *\r\n * This is a mutative operation.\r\n */\n\n\nfunction resetAxis(axis, originAxis) {\n  axis.min = originAxis.min;\n  axis.max = originAxis.max;\n}\n/**\r\n * Reset a box to the provided origin box.\r\n *\r\n * This is a mutative operation.\r\n */\n\n\nfunction resetBox(box, originBox) {\n  resetAxis(box.x, originBox.x);\n  resetAxis(box.y, originBox.y);\n}\n/**\r\n * Scales a point based on a factor and an originPoint\r\n */\n\n\nfunction scalePoint(point, scale, originPoint) {\n  var distanceFromOrigin = point - originPoint;\n  var scaled = scale * distanceFromOrigin;\n  return originPoint + scaled;\n}\n/**\r\n * Applies a translate/scale delta to a point\r\n */\n\n\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n  if (boxScale !== undefined) {\n    point = scalePoint(point, boxScale, originPoint);\n  }\n\n  return scalePoint(point, scale, originPoint) + translate;\n}\n/**\r\n * Applies a translate/scale delta to an axis\r\n */\n\n\nfunction applyAxisDelta(axis, translate, scale, originPoint, boxScale) {\n  if (translate === void 0) {\n    translate = 0;\n  }\n\n  if (scale === void 0) {\n    scale = 1;\n  }\n\n  axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n  axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\r\n * Applies a translate/scale delta to a box\r\n */\n\n\nfunction applyBoxDelta(box, _a) {\n  var x = _a.x,\n      y = _a.y;\n  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\r\n * Apply a transform to an axis from the latest resolved motion values.\r\n * This function basically acts as a bridge between a flat motion value map\r\n * and applyAxisDelta\r\n */\n\n\nfunction applyAxisTransforms(final, axis, transforms, _a) {\n  var key = _a[0],\n      scaleKey = _a[1],\n      originKey = _a[2]; // Copy the current axis to the final axis before mutation\n\n  final.min = axis.min;\n  final.max = axis.max;\n  var originPoint = mix(axis.min, axis.max, transforms[originKey] || 0.5); // Apply the axis delta to the final axis\n\n  applyAxisDelta(final, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\r\n * The names of the motion values we want to apply as translation, scale and origin.\r\n */\n\n\nvar xKeys = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\r\n * Apply a transform to a box from the latest resolved motion values.\r\n */\n\nfunction applyBoxTransforms(finalBox, box, transforms) {\n  applyAxisTransforms(finalBox.x, box.x, transforms, xKeys);\n  applyAxisTransforms(finalBox.y, box.y, transforms, yKeys);\n}\n/**\r\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\r\n */\n\n\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\n  point -= translate;\n  point = scalePoint(point, 1 / scale, originPoint);\n\n  if (boxScale !== undefined) {\n    point = scalePoint(point, 1 / boxScale, originPoint);\n  }\n\n  return point;\n}\n/**\r\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\r\n */\n\n\nfunction removeAxisDelta(axis, translate, scale, origin, boxScale) {\n  if (translate === void 0) {\n    translate = 0;\n  }\n\n  if (scale === void 0) {\n    scale = 1;\n  }\n\n  if (origin === void 0) {\n    origin = 0.5;\n  }\n\n  var originPoint = mix(axis.min, axis.max, origin) - translate;\n  axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\n  axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\r\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\r\n * and acts as a bridge between motion values and removeAxisDelta\r\n */\n\n\nfunction removeAxisTransforms(axis, transforms, _a) {\n  var key = _a[0],\n      scaleKey = _a[1],\n      originKey = _a[2];\n  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale);\n}\n/**\r\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\r\n * and acts as a bridge between motion values and removeAxisDelta\r\n */\n\n\nfunction removeBoxTransforms(box, transforms) {\n  removeAxisTransforms(box.x, transforms, xKeys);\n  removeAxisTransforms(box.y, transforms, yKeys);\n}\n/**\r\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\r\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\r\n */\n\n\nfunction applyTreeDeltas(box, treeScale, treePath) {\n  treeScale.x = treeScale.y = 1;\n  var treeLength = treePath.length;\n\n  for (var i = 0; i < treeLength; i++) {\n    var parent_1 = treePath[i];\n    var delta = parent_1.delta;\n    applyBoxDelta(box, delta);\n    treeScale.x *= delta.x.scale;\n    treeScale.y *= delta.y.scale;\n  }\n}\n\nvar clampProgress = clamp(0, 1);\n/**\r\n * Returns true if the provided value is within maxDistance of the provided target\r\n */\n\nfunction isNear(value, target, maxDistance) {\n  if (target === void 0) {\n    target = 0;\n  }\n\n  if (maxDistance === void 0) {\n    maxDistance = 0.01;\n  }\n\n  return distance(value, target) < maxDistance;\n}\n/**\r\n * Calculate the translate needed to be applied to source to get target\r\n */\n\n\nfunction calcTranslate(source, target, origin) {\n  var sourcePoint = mix(source.min, source.max, origin);\n  var targetPoint = mix(target.min, target.max, origin);\n  return targetPoint - sourcePoint;\n}\n/**\r\n * Calculate a transform origin relative to the source axis, between 0-1, that results\r\n * in an asthetically pleasing scale/transform needed to project from source to target.\r\n */\n\n\nfunction calcOrigin(source, target) {\n  var origin = 0.5;\n  var sourceLength = source.max - source.min;\n  var targetLength = target.max - target.min;\n\n  if (targetLength > sourceLength) {\n    origin = progress(target.min, target.max - sourceLength, source.min);\n  } else if (sourceLength > targetLength) {\n    origin = progress(source.min, source.max - targetLength, target.min);\n  }\n\n  return clampProgress(origin);\n}\n/**\r\n * Update the AxisDelta with a transform that projects source into target.\r\n *\r\n * The transform `origin` is optional. If not provided, it'll be automatically\r\n * calculated based on the relative positions of the two bounding boxes.\r\n */\n\n\nfunction updateAxisDelta(delta, source, target, origin) {\n  var sourceLength = source.max - source.min;\n  var targetLength = target.max - target.min;\n  delta.origin = origin === undefined ? calcOrigin(source, target) : origin;\n  delta.originPoint = mix(source.min, source.max, delta.origin);\n  delta.scale = targetLength / sourceLength;\n  if (isNear(delta.scale, 1, 0.0001)) delta.scale = 1;\n  delta.translate = calcTranslate(source, target, delta.origin);\n  if (isNear(delta.translate)) delta.translate = 0;\n}\n/**\r\n * Update the BoxDelta with a transform that projects the source into the target.\r\n *\r\n * The transform `origin` is optional. If not provided, it'll be automatically\r\n * calculated based on the relative positions of the two bounding boxes.\r\n */\n\n\nfunction updateBoxDelta(delta, source, target, origin) {\n  updateAxisDelta(delta.x, source.x, target.x, origin);\n  updateAxisDelta(delta.y, source.y, target.y, origin);\n} // Call a handler once for each axis\n\n\nfunction eachAxis(handler) {\n  return [handler(\"x\"), handler(\"y\")];\n}\n\nvar isKeyframesTarget = function (v) {\n  return Array.isArray(v);\n};\n\nvar underDampedSpring = function () {\n  return {\n    type: \"spring\",\n    stiffness: 500,\n    damping: 25,\n    restDelta: 0.5,\n    restSpeed: 10\n  };\n};\n\nvar overDampedSpring = function (to) {\n  return {\n    type: \"spring\",\n    stiffness: 700,\n    damping: to === 0 ? 100 : 35\n  };\n};\n\nvar linearTween = function () {\n  return {\n    ease: \"linear\",\n    duration: 0.3\n  };\n};\n\nvar keyframes = function (values) {\n  return {\n    type: \"keyframes\",\n    duration: 0.8,\n    values: values\n  };\n};\n\nvar defaultTransitions = {\n  x: underDampedSpring,\n  y: underDampedSpring,\n  z: underDampedSpring,\n  rotate: underDampedSpring,\n  rotateX: underDampedSpring,\n  rotateY: underDampedSpring,\n  rotateZ: underDampedSpring,\n  scaleX: overDampedSpring,\n  scaleY: overDampedSpring,\n  scale: overDampedSpring,\n  opacity: linearTween,\n  backgroundColor: linearTween,\n  color: linearTween,\n  default: overDampedSpring\n};\n\nvar getDefaultTransition = function (valueKey, to) {\n  var transitionFactory;\n\n  if (isKeyframesTarget(to)) {\n    transitionFactory = keyframes;\n  } else {\n    transitionFactory = defaultTransitions[valueKey] || defaultTransitions.default;\n  }\n\n  return __assign({\n    to: to\n  }, transitionFactory(to));\n};\n/**\r\n * A Popmotion action that accepts a single `to` prop. When it starts, it immediately\r\n * updates with `to` and then completes. By using this we can compose instant transitions\r\n * in with the same logic that applies `delay` or returns a `Promise` etc.\r\n *\r\n * Accepting `duration` is a little bit of a hack that simply defers the completetion of\r\n * the animation until after the duration finishes. This is for situations when you're **only**\r\n * animating non-animatable values and then setting something on `transitionEnd`. Really\r\n * you want this to fire after the \"animation\" finishes, rather than instantly.\r\n *\r\n * ```\r\n * animate={{\r\n *   display: 'block',\r\n *   transitionEnd: { display: 'none' }\r\n * }}\r\n * ```\r\n */\n\n\nvar just = function (_a) {\n  var to = _a.to,\n      duration = _a.duration;\n  return action(function (_a) {\n    var update = _a.update,\n        complete = _a.complete;\n    update(to);\n    duration ? delay(duration).start({\n      complete: complete\n    }) : complete();\n  });\n};\n\nvar easingDefinitionToFunction = function (definition) {\n  if (Array.isArray(definition)) {\n    // If cubic bezier definition, create bezier curve\n    invariant(definition.length === 4, \"Cubic bezier arrays must contain four numerical values.\");\n    var x1 = definition[0],\n        y1 = definition[1],\n        x2 = definition[2],\n        y2 = definition[3];\n    return cubicBezier(x1, y1, x2, y2);\n  } else if (typeof definition === \"string\") {\n    // Else lookup from table\n    invariant(easingLookup[definition] !== undefined, \"Invalid easing type '\" + definition + \"'\");\n    return easingLookup[definition];\n  }\n\n  return definition;\n};\n\nvar isEasingArray = function (ease) {\n  return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\nvar isDurationAnimation = function (v) {\n  return v.hasOwnProperty(\"duration\") || v.hasOwnProperty(\"repeatDelay\");\n};\n/**\r\n * Check if a value is animatable. Examples:\r\n *\r\n * ✅: 100, \"100px\", \"#fff\"\r\n * ❌: \"block\", \"url(2.jpg)\"\r\n * @param value\r\n *\r\n * @internal\r\n */\n\n\nvar isAnimatable = function (key, value) {\n  // If the list of keys tat might be non-animatable grows, replace with Set\n  if (key === \"zIndex\") return false; // If it's a number or a keyframes array, we can animate it. We might at some point\n  // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n  // but for now lets leave it like this for performance reasons\n\n  if (typeof value === \"number\" || Array.isArray(value)) return true;\n\n  if (typeof value === \"string\" && // It's animatable if we have a string\n  complex.test(value) && // And it contains numbers and/or colors\n  !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n  ) {\n      return true;\n    }\n\n  return false;\n};\n/**\r\n * Converts seconds to milliseconds\r\n *\r\n * @param seconds - Time in seconds.\r\n * @return milliseconds - Converted time in milliseconds.\r\n */\n\n\nvar secondsToMilliseconds = function (seconds) {\n  return seconds * 1000;\n};\n\nvar transitions = {\n  tween: tween,\n  spring: spring,\n  keyframes: keyframes$1,\n  inertia: inertia,\n  just: just\n};\nvar transitionOptionParser = {\n  tween: function (opts) {\n    if (opts.ease) {\n      var ease = isEasingArray(opts.ease) ? opts.ease[0] : opts.ease;\n      opts.ease = easingDefinitionToFunction(ease);\n    }\n\n    return opts;\n  },\n  keyframes: function (_a) {\n    var from = _a.from,\n        to = _a.to,\n        velocity = _a.velocity,\n        opts = __rest(_a, [\"from\", \"to\", \"velocity\"]);\n\n    if (opts.values && opts.values[0] === null) {\n      var values = __spreadArrays(opts.values);\n\n      values[0] = from;\n      opts.values = values;\n    }\n\n    if (opts.ease) {\n      opts.easings = isEasingArray(opts.ease) ? opts.ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(opts.ease);\n    }\n\n    opts.ease = linear;\n    return opts;\n  }\n};\n\nvar isTransitionDefined = function (_a) {\n  var when = _a.when,\n      delay = _a.delay,\n      delayChildren = _a.delayChildren,\n      staggerChildren = _a.staggerChildren,\n      staggerDirection = _a.staggerDirection,\n      transition = __rest(_a, [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\"]);\n\n  return Object.keys(transition).length;\n};\n\nvar getTransitionDefinition = function (key, to, transitionDefinition) {\n  var delay = transitionDefinition ? transitionDefinition.delay : 0; // If no object, return default transition\n  // A better way to handle this would be to deconstruct out all the shared Orchestration props\n  // and see if there's any props remaining\n\n  if (transitionDefinition === undefined || !isTransitionDefined(transitionDefinition)) {\n    return __assign({\n      delay: delay\n    }, getDefaultTransition(key, to));\n  }\n\n  var valueTransitionDefinition = transitionDefinition[key] || transitionDefinition.default || transitionDefinition;\n\n  if (valueTransitionDefinition.type === false) {\n    return {\n      delay: valueTransitionDefinition.hasOwnProperty(\"delay\") ? valueTransitionDefinition.delay : delay,\n      to: isKeyframesTarget(to) ? to[to.length - 1] : to,\n      type: \"just\"\n    };\n  } else if (isKeyframesTarget(to)) {\n    return __assign(__assign({\n      values: to,\n      duration: 0.8,\n      delay: delay,\n      ease: \"linear\"\n    }, valueTransitionDefinition), {\n      // This animation must be keyframes if we're animating through an array\n      type: \"keyframes\"\n    });\n  } else {\n    return __assign({\n      type: \"tween\",\n      to: to,\n      delay: delay\n    }, valueTransitionDefinition);\n  }\n};\n\nvar preprocessOptions = function (type, opts) {\n  return transitionOptionParser[type] ? transitionOptionParser[type](opts) : opts;\n};\n\nvar getAnimation = function (key, value, target, transition) {\n  var origin = value.get();\n  var isOriginAnimatable = isAnimatable(key, origin);\n  var isTargetAnimatable = isAnimatable(key, target); // TODO we could probably improve this check to ensure both values are of the same type -\n  // for instance 100 to #fff. This might live better in Popmotion.\n\n  warning(isOriginAnimatable === isTargetAnimatable, \"You are trying to animate \" + key + \" from \\\"\" + origin + \"\\\" to \\\"\" + target + \"\\\". \" + origin + \" is not an animatable value - to enable this animation set \" + origin + \" to a value animatable to \" + target + \" via the `style` property.\"); // Parse the `transition` prop and return options for the Popmotion animation\n\n  var _a = getTransitionDefinition(key, target, transition),\n      _b = _a.type,\n      type = _b === void 0 ? \"tween\" : _b,\n      transitionDefinition = __rest(_a, [\"type\"]); // If this is an animatable pair of values, return an animation, otherwise use `just`\n\n\n  var actionFactory = isOriginAnimatable && isTargetAnimatable ? transitions[type] : just;\n  var opts = preprocessOptions(type, __assign({\n    from: origin,\n    velocity: value.getVelocity()\n  }, transitionDefinition)); // Convert duration from Framer Motion's seconds into Popmotion's milliseconds\n\n  if (isDurationAnimation(opts)) {\n    if (opts.duration) {\n      opts.duration = secondsToMilliseconds(opts.duration);\n    }\n\n    if (opts.repeatDelay) {\n      opts.repeatDelay = secondsToMilliseconds(opts.repeatDelay);\n    }\n  }\n\n  return [actionFactory, opts];\n};\n/**\r\n * Start animation on a value. This function completely encapsulates Popmotion-specific logic.\r\n *\r\n * @internal\r\n */\n\n\nfunction startAnimation(key, value, target, _a) {\n  if (_a === void 0) {\n    _a = {};\n  }\n\n  var _b = _a.delay,\n      delay$1 = _b === void 0 ? 0 : _b,\n      transition = __rest(_a, [\"delay\"]);\n\n  return value.start(function (complete) {\n    var activeAnimation;\n\n    var _a = getAnimation(key, value, target, transition),\n        animationFactory = _a[0],\n        _b = _a[1],\n        valueDelay = _b.delay,\n        options = __rest(_b, [\"delay\"]);\n\n    if (valueDelay !== undefined) {\n      delay$1 = valueDelay;\n    }\n\n    var animate = function () {\n      var animation = animationFactory(options); // Bind animation opts to animation\n\n      activeAnimation = animation.start({\n        update: function (v) {\n          return value.set(v);\n        },\n        complete: complete\n      });\n    }; // If we're delaying this animation, only resolve it **after** the delay to\n    // ensure the value's resolve velocity is up-to-date.\n\n\n    if (delay$1) {\n      activeAnimation = delay(secondsToMilliseconds(delay$1)).start({\n        complete: animate\n      });\n    } else {\n      animate();\n    }\n\n    return function () {\n      if (activeAnimation) activeAnimation.stop();\n    };\n  });\n}\n/**\r\n * Measure and return the element bounding box.\r\n *\r\n * We convert the box into an AxisBox2D to make it easier to work with each axis\r\n * individually and programmatically.\r\n *\r\n * This function optionally accepts a transformPagePoint function which allows us to compensate\r\n * for, for instance, measuring the element within a scaled plane like a Framer devivce preview component.\r\n */\n\n\nfunction getBoundingBox(element, transformPagePoint) {\n  var box = element.getBoundingClientRect();\n  return convertBoundingBoxToAxisBox(transformBoundingBox(box, transformPagePoint));\n}\n/**\r\n * A VisualElement for HTMLElements\r\n */\n\n\nvar HTMLVisualElement =\n/** @class */\nfunction (_super) {\n  __extends(HTMLVisualElement, _super);\n\n  function HTMLVisualElement() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\r\n     *\r\n     */\n\n\n    _this.defaultConfig = {\n      enableHardwareAcceleration: true,\n      allowTransformNone: true\n    };\n    /**\r\n     * A mutable record of styles we want to apply directly to the rendered Element\r\n     * every frame. We use a mutable data structure to reduce GC during animations.\r\n     */\n\n    _this.style = {};\n    /**\r\n     * A record of styles we only want to apply via React. This gets set in useMotionValues\r\n     * and applied in the render function. I'd prefer this to live somewhere else to decouple\r\n     * VisualElement from React but works for now.\r\n     */\n\n    _this.reactStyle = {};\n    /**\r\n     * A mutable record of CSS variables we want to apply directly to the rendered Element\r\n     * every frame. We use a mutable data structure to reduce GC during animations.\r\n     */\n\n    _this.vars = {};\n    /**\r\n     * A mutable record of transforms we want to apply directly to the rendered Element\r\n     * every frame. We use a mutable data structure to reduce GC during animations.\r\n     */\n\n    _this.transform = {};\n    /**\r\n     * A mutable record of transform origins we want to apply directly to the rendered Element\r\n     * every frame. We use a mutable data structure to reduce GC during animations.\r\n     */\n\n    _this.transformOrigin = {};\n    /**\r\n     * A mutable record of transform keys we want to apply to the rendered Element. We order\r\n     * this to order transforms in the desired order. We use a mutable data structure to reduce GC during animations.\r\n     */\n\n    _this.transformKeys = [];\n    _this.config = _this.defaultConfig;\n    /**\r\n     * ========================================\r\n     * Layout\r\n     * ========================================\r\n     */\n\n    _this.isLayoutProjectionEnabled = false;\n    /**\r\n     * A boolean that flags whether this component has children that need to be update\r\n     * when this component changes layout.\r\n     */\n\n    _this.hasLayoutChildren = false;\n    /**\r\n     * A set of layout update event handlers. These are only called once all layouts have been read,\r\n     * making it safe to perform DOM write operations.\r\n     */\n\n    _this.layoutUpdateListeners = new Set();\n    /**\r\n     * Keep track of whether the viewport box has been updated since the last render.\r\n     * If it has, we want to fire the onViewportBoxUpdate listener.\r\n     */\n\n    _this.hasViewportBoxUpdated = false;\n    /**\r\n     * The visual target we want to project our component into on a given frame\r\n     * before applying transforms defined in `animate` or `style`.\r\n     *\r\n     * This is considered mutable to avoid object creation on each frame.\r\n     */\n\n    _this.targetBoxFinal = axisBox();\n    /**\r\n     * The overall scale of the local coordinate system as transformed by all parents\r\n     * of this component. We use this for scale correction on our calculated layouts\r\n     * and scale-affected values like `boxShadow`.\r\n     *\r\n     * This is considered mutable to avoid object creation on each frame.\r\n     */\n\n    _this.treeScale = {\n      x: 1,\n      y: 1\n    };\n    /**\r\n     * The delta between the boxCorrected and the desired\r\n     * targetBox (before user-set transforms are applied). The calculated output will be\r\n     * handed to the renderer and used as part of the style correction calculations, for\r\n     * instance calculating how to display the desired border-radius correctly.\r\n     *\r\n     * This is considered mutable to avoid object creation on each frame.\r\n     */\n\n    _this.delta = delta();\n    /**\r\n     * The delta between the boxCorrected and the desired targetBoxFinal. The calculated\r\n     * output will be handed to the renderer and used to project the boxCorrected into\r\n     * the targetBoxFinal.\r\n     *\r\n     * This is considered mutable to avoid object creation on each frame.\r\n     */\n\n    _this.deltaFinal = delta();\n    /**\r\n     *\r\n     */\n\n    _this.stopLayoutAxisAnimation = {\n      x: function () {},\n      y: function () {}\n    };\n    _this.isTargetBoxLocked = false;\n    /**\r\n     *\r\n     */\n\n    _this.axisProgress = {\n      x: motionValue(0),\n      y: motionValue(0)\n    };\n    return _this;\n  }\n  /**\r\n   * When a value is removed, we want to make sure it's removed from all rendered data structures.\r\n   */\n\n\n  HTMLVisualElement.prototype.removeValue = function (key) {\n    _super.prototype.removeValue.call(this, key);\n\n    delete this.vars[key];\n    delete this.style[key];\n  };\n  /**\r\n   * Empty the mutable data structures by re-creating them. We can do this every React render\r\n   * as the comparative workload to the rest of the render is very low and this is also when\r\n   * we want to reflect values that might have been removed by the render.\r\n   */\n\n\n  HTMLVisualElement.prototype.clean = function () {\n    this.style = {};\n    this.vars = {};\n    this.transform = {};\n  };\n\n  HTMLVisualElement.prototype.updateConfig = function (config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    this.config = __assign(__assign({}, this.defaultConfig), config);\n  };\n  /**\r\n   * Read a value directly from the HTMLElement style.\r\n   */\n\n\n  HTMLVisualElement.prototype.read = function (key) {\n    return this.getComputedStyle()[key] || 0;\n  };\n  /**\r\n   * Read a value directly from the HTMLElement in case it's not defined by a Motion\r\n   * prop. If it's a transform, we just return a pre-defined default value as reading these\r\n   * out of a matrix is either error-prone or can incur a big payload for little benefit.\r\n   */\n\n\n  HTMLVisualElement.prototype.readNativeValue = function (key) {\n    if (isTransformProp(key)) {\n      var defaultValueType = getDefaultValueType(key);\n      return defaultValueType ? defaultValueType.default || 0 : 0;\n    } else {\n      return this.read(key);\n    }\n  };\n\n  HTMLVisualElement.prototype.enableLayoutProjection = function () {\n    this.isLayoutProjectionEnabled = true;\n    forEachParent(this, function (parent) {\n      return parent.hasLayoutChildren = true;\n    });\n  };\n\n  HTMLVisualElement.prototype.hide = function () {\n    if (this.isVisible === false) return;\n    this.isVisible = false;\n    this.scheduleRender();\n  };\n\n  HTMLVisualElement.prototype.show = function () {\n    if (this.isVisible === true) return;\n    this.isVisible = true;\n    this.scheduleRender();\n  };\n  /**\r\n   * Register an event listener to fire when the layout is updated. We might want to expose support\r\n   * for this via a `motion` prop.\r\n   */\n\n\n  HTMLVisualElement.prototype.onLayoutUpdate = function (callback) {\n    var _this = this;\n\n    this.layoutUpdateListeners.add(callback);\n    return function () {\n      return _this.layoutUpdateListeners.delete(callback);\n    };\n  };\n  /**\r\n   * To be called when all layouts are successfully updated. In turn we can notify layoutUpdate\r\n   * subscribers.\r\n   */\n\n\n  HTMLVisualElement.prototype.layoutReady = function (config) {\n    var _this = this;\n\n    this.layoutUpdateListeners.forEach(function (listener) {\n      listener(_this.box, _this.prevViewportBox || _this.box, config);\n    });\n  };\n  /**\r\n   * Measure and return the Element's bounding box. We convert it to a AxisBox2D\r\n   * structure to make it easier to work on each individual axis generically.\r\n   */\n\n\n  HTMLVisualElement.prototype.getBoundingBox = function () {\n    var transformPagePoint = this.config.transformPagePoint;\n    return getBoundingBox(this.element, transformPagePoint);\n  };\n\n  HTMLVisualElement.prototype.getBoundingBoxWithoutTransforms = function () {\n    var bbox = this.getBoundingBox();\n    removeBoxTransforms(bbox, this.latest);\n    return bbox;\n  };\n  /**\r\n   * Return the computed style after a render.\r\n   */\n\n\n  HTMLVisualElement.prototype.getComputedStyle = function () {\n    return window.getComputedStyle(this.element);\n  };\n  /**\r\n   *\r\n   */\n\n\n  HTMLVisualElement.prototype.snapshotBoundingBox = function () {\n    this.prevViewportBox = this.getBoundingBoxWithoutTransforms();\n    /**\r\n     * Update targetBox to match the prevViewportBox. This is just to ensure\r\n     * that targetBox is affected by scroll in the same way as the measured box\r\n     */\n\n    var _a = this.axisProgress,\n        x = _a.x,\n        y = _a.y;\n\n    if (!this.isTargetBoxLocked && !x.isAnimating() && !y.isAnimating()) {\n      this.targetBox = copyAxisBox(this.prevViewportBox);\n    }\n  };\n\n  HTMLVisualElement.prototype.measureLayout = function () {\n    this.box = this.getBoundingBox();\n    this.boxCorrected = copyAxisBox(this.box);\n    if (!this.targetBox) this.targetBox = copyAxisBox(this.box);\n  };\n  /**\r\n   * Ensure the targetBox reflects the latest visual box on screen\r\n   */\n\n\n  HTMLVisualElement.prototype.refreshTargetBox = function () {\n    this.targetBox = this.getBoundingBoxWithoutTransforms();\n  };\n\n  HTMLVisualElement.prototype.lockTargetBox = function () {\n    this.isTargetBoxLocked = true;\n  };\n\n  HTMLVisualElement.prototype.unlockTargetBox = function () {\n    this.stopLayoutAnimation();\n    this.isTargetBoxLocked = false;\n  };\n  /**\r\n   * Reset the transform on the current Element. This is called as part\r\n   * of a batched process across the entire layout tree. To remove this write\r\n   * cycle it'd be interesting to see if it's possible to \"undo\" all the current\r\n   * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\r\n   * works\r\n   */\n\n\n  HTMLVisualElement.prototype.resetTransform = function () {\n    this.element.style.transform = \"none\"; // Ensure that whatever happens next, we restore our transform\n\n    this.scheduleRender();\n  };\n  /**\r\n   * Set new min/max boundaries to project an axis into\r\n   */\n\n\n  HTMLVisualElement.prototype.setAxisTarget = function (axis, min, max) {\n    var targetAxis = this.targetBox[axis];\n    targetAxis.min = min;\n    targetAxis.max = max; // Flag that we want to fire the onViewportBoxUpdate event handler\n\n    this.hasViewportBoxUpdated = true;\n    /**\r\n     * If this component re-renders we need to ensure that any children performing\r\n     * layout projection also update\r\n     *\r\n     * TODO: This recursively traverses all children for each axis and for each component. A performance\r\n     * improvement would be to:\r\n     *  1. Flag the root component as dirty and schedule it to update pre-render\r\n     *  2. Recursively traverse tree from root layout component during this update\r\n     *      scheduling renders and updating deltas\r\n     */\n\n    scheduleChildrenLayoutRender(this);\n  };\n  /**\r\n   *\r\n   */\n\n\n  HTMLVisualElement.prototype.startLayoutAxisAnimation = function (axis, transition) {\n    var _this = this;\n\n    var progress = this.axisProgress[axis];\n    var _a = this.targetBox[axis],\n        min = _a.min,\n        max = _a.max;\n    var length = max - min;\n    progress.clearListeners();\n    progress.set(min);\n    progress.set(min); // Set twice to hard-reset velocity\n\n    progress.onChange(function (v) {\n      return _this.setAxisTarget(axis, v, v + length);\n    });\n    return startAnimation(axis, progress, 0, transition);\n  };\n\n  HTMLVisualElement.prototype.stopLayoutAnimation = function () {\n    var _this = this;\n\n    eachAxis(function (axis) {\n      return _this.axisProgress[axis].stop();\n    });\n  };\n  /**\r\n   * Update the layout deltas to reflect the relative positions of the layout\r\n   * and the desired target box\r\n   */\n\n\n  HTMLVisualElement.prototype.updateLayoutDeltas = function (isReactRender) {\n    var _a, _b;\n    /**\r\n     * Ensure that all the parent deltas are up-to-date before calculating this delta.\r\n     *\r\n     * TODO: This approach is exceptionally wasteful as every child will update\r\n     * the deltas of its parent even if it's already updated for this frame.\r\n     * We can optimise this by replacing this to a call directly to the root VisualElement\r\n     * which then runs iteration from the top-down, but only once per framestamp.\r\n     */\n\n\n    this.treePath.forEach(function (p) {\n      return p.updateLayoutDeltas(isReactRender);\n    });\n    /**\r\n     * Early return if layout reprojection isn't enabled\r\n     */\n\n    if (!this.isLayoutProjectionEnabled || !this.box) return;\n    /**\r\n     * Reset the corrected box with the latest values from box, as we're then going\r\n     * to perform mutative operations on it.\r\n     */\n\n    resetBox(this.boxCorrected, this.box);\n    /**\r\n     * Apply all the parent deltas to this box to produce the corrected box. This\r\n     * is the layout box, as it will appear on screen as a result of the transforms of its parents.\r\n     */\n\n    applyTreeDeltas(this.boxCorrected, this.treeScale, this.treePath);\n    /**\r\n     * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\r\n     * This is the final box that we will then project into by calculating a transform delta and\r\n     * applying it to the corrected box.\r\n     */\n\n    applyBoxTransforms(this.targetBoxFinal, this.targetBox, this.latest);\n    /**\r\n     * Update the delta between the corrected box and the target box before user-set transforms were applied.\r\n     * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\r\n     * for our layout reprojection, but still allow them to be scaled correctly by the user.\r\n     * It might be that to simplify this we may want to accept that user-set scale is also corrected\r\n     * and we wouldn't have to keep and calc both deltas, OR we could support a user setting\r\n     * to allow people to choose whether these styles are corrected based on just the\r\n     * layout reprojection or the final bounding box.\r\n     */\n\n    updateBoxDelta(this.delta, this.boxCorrected, this.targetBox);\n    /**\r\n     * Update the delta between the corrected box and the final target box, after\r\n     * user-set transforms are applied to it. This will be used by the renderer to\r\n     * create a transform style that will reproject the element from its actual layout\r\n     * into the desired bounding box.\r\n     */\n\n    updateBoxDelta(this.deltaFinal, this.boxCorrected, this.targetBoxFinal);\n    /**\r\n     * If we have a listener for the viewport box, fire it.\r\n     * TODO: Instead of manually checking this, use framesync postRender\r\n     */\n\n    if (!isReactRender) {\n      this.hasViewportBoxUpdated && ((_b = (_a = this.config).onViewportBoxUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, this.targetBox, this.delta));\n      this.hasViewportBoxUpdated = false;\n    }\n  };\n  /**\r\n   * ========================================\r\n   * Build & render\r\n   * ========================================\r\n   */\n\n  /**\r\n   * Build a style prop using the latest resolved MotionValues\r\n   */\n\n\n  HTMLVisualElement.prototype.build = function (isReactRender) {\n    if (this.isVisible !== undefined) {\n      this.style.visibility = this.isVisible ? \"visible\" : \"hidden\";\n    }\n\n    this.isLayoutProjectionEnabled && this.box && this.updateLayoutDeltas(isReactRender);\n    buildHTMLStyles(this.latest, this.style, this.vars, this.transform, this.transformOrigin, this.transformKeys, this.config, this.isLayoutProjectionEnabled && !!this.box, this.delta, this.deltaFinal, this.treeScale, this.targetBoxFinal);\n  };\n  /**\r\n   * Render the Element by rebuilding and applying the latest styles and vars.\r\n   */\n\n\n  HTMLVisualElement.prototype.render = function () {\n    // Rebuild the latest animated values into style and vars caches.\n    this.build(false); // Directly assign style into the Element's style prop. In tests Object.assign is the\n    // fastest way to assign styles.\n\n    Object.assign(this.element.style, this.style); // Loop over any CSS variables and assign those.\n\n    for (var key in this.vars) {\n      this.element.style.setProperty(key, this.vars[key]);\n    }\n  };\n\n  return HTMLVisualElement;\n}(VisualElement);\n\nfunction scheduleChildrenLayoutRender(element) {\n  if (element.isLayoutProjectionEnabled) {\n    element.scheduleRender();\n  }\n\n  if (element.hasLayoutChildren) {\n    element.children.forEach(scheduleChildrenLayoutRender);\n  }\n}\n\nfunction forEachParent(child, callback) {\n  var parent = child.parent;\n\n  while (parent) {\n    callback(parent);\n    parent = parent.parent;\n  }\n}\n/**\r\n * Creates a constant value over the lifecycle of a component.\r\n *\r\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\r\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\r\n * you can ensure that initialisers don't execute twice or more.\r\n */\n\n\nfunction useConstant(init) {\n  var ref = useRef(null);\n\n  if (ref.current === null) {\n    ref.current = init();\n  }\n\n  return ref.current;\n}\n\nfunction calcOrigin$1(origin, offset, size) {\n  return typeof origin === \"string\" ? origin : px.transform(offset + size * origin);\n}\n/**\r\n * The SVG transform origin defaults are different to CSS and is less intuitive,\r\n * so we use the measured dimensions of the SVG to reconcile these.\r\n */\n\n\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n  var pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);\n  var pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);\n  return pxOriginX + \" \" + pxOriginY;\n} // Convert a progress 0-1 to a pixels value based on the provided length\n\n\nvar progressToPixels = function (progress, length) {\n  return px.transform(progress * length);\n};\n\nvar dashKeys = {\n  offset: \"stroke-dashoffset\",\n  array: \"stroke-dasharray\"\n};\nvar camelKeys = {\n  offset: \"strokeDashoffset\",\n  array: \"strokeDasharray\"\n};\n/**\r\n * Build SVG path properties. Uses the path's measured length to convert\r\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\r\n * and stroke-dasharray attributes.\r\n *\r\n * This function is mutative to reduce per-frame GC.\r\n */\n\nfunction buildSVGPath(attrs, totalLength, length, spacing, offset, useDashCase) {\n  if (spacing === void 0) {\n    spacing = 1;\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  if (useDashCase === void 0) {\n    useDashCase = true;\n  } // We use dash case when setting attributes directly to the DOM node and camel case\n  // when defining props on a React component.\n\n\n  var keys = useDashCase ? dashKeys : camelKeys; // Build the dash offset\n\n  attrs[keys.offset] = progressToPixels(-offset, totalLength); // Build the dash array\n\n  var pathLength = progressToPixels(length, totalLength);\n  var pathSpacing = progressToPixels(spacing, totalLength);\n  attrs[keys.array] = pathLength + \" \" + pathSpacing;\n}\n\nvar unmeasured = {\n  x: 0,\n  y: 0,\n  width: 0,\n  height: 0\n};\n/**\r\n * Build SVG visual attrbutes, like cx and style.transform\r\n */\n\nfunction buildSVGAttrs(_a, style, vars, attrs, transform, transformOrigin, transformKeys, config, dimensions, totalPathLength) {\n  var attrX = _a.attrX,\n      attrY = _a.attrY,\n      originX = _a.originX,\n      originY = _a.originY,\n      pathLength = _a.pathLength,\n      _b = _a.pathSpacing,\n      pathSpacing = _b === void 0 ? 1 : _b,\n      _c = _a.pathOffset,\n      pathOffset = _c === void 0 ? 0 : _c,\n      // This is object creation, which we try to avoid per-frame.\n  latest = __rest(_a, [\"attrX\", \"attrY\", \"originX\", \"originY\", \"pathLength\", \"pathSpacing\", \"pathOffset\"]);\n  /**\r\n   * With SVG we treat all animated values as attributes rather than CSS, so we build into attrs\r\n   */\n\n\n  buildHTMLStyles(latest, attrs, vars, transform, transformOrigin, transformKeys, config);\n  /**\r\n   * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\r\n   * and copy it into style.\r\n   */\n\n  if (attrs.transform) {\n    style.transform = attrs.transform;\n    delete attrs.transform;\n  } // Parse transformOrigin\n\n\n  if (originX !== undefined || originY !== undefined || style.transform) {\n    style.transformOrigin = calcSVGTransformOrigin(dimensions || unmeasured, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n  } // Treat x/y not as shortcuts but as actual attributes\n\n\n  if (attrX !== undefined) attrs.x = attrX;\n  if (attrY !== undefined) attrs.y = attrY; // Build SVG path if one has been measured\n\n  if (totalPathLength !== undefined && pathLength !== undefined) {\n    buildSVGPath(attrs, totalPathLength, pathLength, pathSpacing, pathOffset, false);\n  }\n\n  return attrs;\n}\n/**\r\n * A set of attribute names that are always read/written as camel case.\r\n */\n\n\nvar camelCaseAttributes = new Set([\"baseFrequency\", \"diffuseConstant\", \"kernelMatrix\", \"kernelUnitLength\", \"keySplines\", \"keyTimes\", \"limitingConeAngle\", \"markerHeight\", \"markerWidth\", \"numOctaves\", \"targetX\", \"targetY\", \"surfaceScale\", \"specularConstant\", \"specularExponent\", \"stdDeviation\", \"tableValues\"]);\nvar CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;\nvar REPLACE_TEMPLATE = \"$1-$2\";\n/**\r\n * Convert camelCase to dash-case properties.\r\n */\n\nvar camelToDash = function (str) {\n  return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();\n};\n/**\r\n * A VisualElement for SVGElements. Inherits from and extends HTMLVisualElement as the two\r\n * share data structures.\r\n */\n\n\nvar SVGVisualElement =\n/** @class */\nfunction (_super) {\n  __extends(SVGVisualElement, _super);\n\n  function SVGVisualElement() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\r\n     * A mutable record of attributes we want to apply directly to the rendered Element\r\n     * every frame. We use a mutable data structure to reduce GC during animations.\r\n     */\n\n\n    _this.attrs = {};\n    /**\r\n     * We disable hardware acceleration for SVG transforms as they're not currently able to be accelerated.\r\n     */\n\n    _this.defaultConfig = {\n      enableHardwareAcceleration: false\n    };\n    /**\r\n     * Without duplicating this call from HTMLVisualElement we end up with HTMLVisualElement.defaultConfig\r\n     * being assigned to config\r\n     */\n\n    _this.config = _this.defaultConfig;\n    return _this;\n  }\n  /**\r\n   * Measure the SVG element on mount. This can affect page rendering so there might be a\r\n   * better time to perform this - for instance dynamically only if there's a transform-origin dependent\r\n   * transform being set (like rotate)\r\n   */\n\n\n  SVGVisualElement.prototype.mount = function (element) {\n    _super.prototype.mount.call(this, element);\n\n    this.measure();\n  };\n  /**\r\n   * Update the SVG dimensions and path length\r\n   */\n\n\n  SVGVisualElement.prototype.measure = function () {\n    try {\n      this.dimensions = typeof this.element.getBBox === \"function\" ? this.element.getBBox() : this.element.getBoundingClientRect();\n    } catch (e) {\n      // Most likely trying to measure an unrendered element under Firefox\n      this.dimensions = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n    }\n\n    if (isPath(this.element)) {\n      this.totalPathLength = this.element.getTotalLength();\n    }\n  };\n  /**\r\n   * Empty the mutable data structures in case attrs have been removed between renders.\r\n   */\n\n\n  SVGVisualElement.prototype.clean = function () {\n    _super.prototype.clean.call(this);\n\n    this.attrs = {};\n  };\n  /**\r\n   * Read an attribute directly from the SVGElement\r\n   */\n\n\n  SVGVisualElement.prototype.read = function (key) {\n    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n    return this.element.getAttribute(key);\n  };\n\n  SVGVisualElement.prototype.build = function () {\n    buildSVGAttrs(this.latest, this.style, this.vars, this.attrs, this.transform, this.transformOrigin, this.transformKeys, this.config, this.dimensions, this.totalPathLength);\n  };\n\n  SVGVisualElement.prototype.render = function () {\n    // Update HTML styles and CSS variables\n    _super.prototype.render.call(this); // Loop through attributes and apply them to the SVGElement\n\n\n    for (var key in this.attrs) {\n      this.element.setAttribute(camelToDash(key), this.attrs[key]);\n    }\n  };\n\n  return SVGVisualElement;\n}(HTMLVisualElement);\n\nfunction isPath(element) {\n  return element.tagName === \"path\";\n}\n/**\r\n * @internal\r\n */\n\n/**\r\n * @internal\r\n */\n\n\nvar svgElements = [\"animate\", \"circle\", \"clipPath\", \"defs\", \"desc\", \"ellipse\", \"feBlend\", \"feColorMatrix\", \"feComponentTransfer\", \"feComposite\", \"feConvolveMatrix\", \"feDiffuseLighting\", \"feDisplacementMap\", \"feDistantLight\", \"feDropShadow\", \"feFlood\", \"feFuncA\", \"feFuncB\", \"feFuncG\", \"feFuncR\", \"feGaussianBlur\", \"feImage\", \"feMerge\", \"feMergeNode\", \"feMorphology\", \"feOffset\", \"fePointLight\", \"feSpecularLighting\", \"feSpotLight\", \"feTile\", \"feTurbulence\", \"filter\", \"foreignObject\", \"g\", \"image\", \"line\", \"linearGradient\", \"marker\", \"mask\", \"metadata\", \"path\", \"pattern\", \"polygon\", \"polyline\", \"radialGradient\", \"rect\", \"stop\", \"svg\", \"switch\", \"symbol\", \"text\", \"textPath\", \"tspan\", \"use\", \"view\"];\nvar svgTagNames = new Set(svgElements);\n/**\r\n * Determine whether this is a HTML or SVG component based on if the provided\r\n * Component is a string and a recognised SVG tag. A potentially better way to\r\n * do this would be to offer a `motion.customSVG` function and determine this\r\n * when we generate the `motion.circle` etc components.\r\n */\n\nfunction isSVGComponent(Component) {\n  return typeof Component === \"string\" && svgTagNames.has(Component);\n}\n/**\r\n * @public\r\n */\n\n\nvar PresenceContext = createContext(null);\n/**\r\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\r\n * to access information about whether it's still present in the React tree.\r\n *\r\n * ```jsx\r\n * import { usePresence } from \"framer-motion\"\r\n *\r\n * export const Component = () => {\r\n *   const [isPresent, safeToRemove] = usePresence()\r\n *\r\n *   useEffect(() => {\r\n *     !isPresent setTimeout(safeToRemove, 1000)\r\n *   }, [isPresent])\r\n *\r\n *   return <div />\r\n * }\r\n * ```\r\n *\r\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\r\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\r\n *\r\n * @public\r\n */\n\nfunction usePresence() {\n  var context = useContext(PresenceContext);\n  if (context === null) return [true, null];\n  var isPresent = context.isPresent,\n      onExitComplete = context.onExitComplete,\n      register = context.register; // It's safe to call the following hooks conditionally (after an early return) because the context will always\n  // either be null or non-null for the lifespan of the component.\n  // Replace with useOpaqueId when released in React\n\n  var id = useUniqueId();\n  useEffect(function () {\n    return register(id);\n  }, []);\n\n  var safeToRemove = function () {\n    return onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete(id);\n  };\n\n  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\n}\n/**\r\n * @public\r\n */\n\n\nfunction useIsPresent() {\n  var context = useContext(PresenceContext);\n  return context === null ? true : context.isPresent;\n}\n\nvar counter = 0;\n\nvar incrementId = function () {\n  return counter++;\n};\n\nvar useUniqueId = function () {\n  return useConstant(incrementId);\n};\n/**\r\n * DOM-flavoured variation of the useVisualElement hook. Used to create either a HTMLVisualElement\r\n * or SVGVisualElement for the component.\r\n */\n\n\nvar useDomVisualElement = function (Component, props, parent, isStatic, ref) {\n  var visualElement = useConstant(function () {\n    var DOMVisualElement = isSVGComponent(Component) ? SVGVisualElement : HTMLVisualElement;\n    return new DOMVisualElement(parent, ref);\n  });\n  visualElement.updateConfig(__assign({\n    enableHardwareAcceleration: !isStatic\n  }, props));\n  visualElement.layoutId = props.layoutId;\n  var isPresent = useIsPresent();\n  visualElement.isPresent = props.isPresent !== undefined ? props.isPresent : isPresent;\n  return visualElement;\n};\n/**\r\n * A list of all valid MotionProps.\r\n *\r\n * @internalremarks\r\n * This doesn't throw if a `MotionProp` name is missing - it should.\r\n */\n\n\nvar validMotionProps = new Set([\"initial\", \"animate\", \"exit\", \"style\", \"variants\", \"transition\", \"transformTemplate\", \"transformValues\", \"custom\", \"inherit\", \"static\", \"layout\", \"layoutId\", \"onLayoutAnimationComplete\", \"onViewportBoxUpdate\", \"onAnimationStart\", \"onAnimationComplete\", \"onUpdate\", \"onDragStart\", \"onDrag\", \"onDragEnd\", \"onMeasureDragConstraints\", \"onDirectionLock\", \"onDragTransitionEnd\", \"drag\", \"dragControls\", \"dragListener\", \"dragConstraints\", \"dragDirectionLock\", \"dragElastic\", \"dragMomentum\", \"dragPropagation\", \"dragTransition\", \"onPan\", \"onPanStart\", \"onPanEnd\", \"onPanSessionStart\", \"onTap\", \"onTapStart\", \"onTapCancel\", \"whileHover\", \"whileTap\", \"onHoverEnd\", \"onHoverStart\"]);\n/**\r\n * Check whether a prop name is a valid `MotionProp` key.\r\n *\r\n * @param key - Name of the property to check\r\n * @returns `true` is key is a valid `MotionProp`.\r\n *\r\n * @public\r\n */\n\nfunction isValidMotionProp(key) {\n  return validMotionProps.has(key);\n}\n\nvar isPropValid = function (key) {\n  return !isValidMotionProp(key);\n};\n/**\r\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\r\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\r\n * of these should be passed to the underlying DOM node.\r\n *\r\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\r\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\r\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\r\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\r\n *\r\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\r\n * actually required.\r\n */\n\n\ntry {\n  var emotionIsPropValid_1 = require(\"@emotion/is-prop-valid\").default;\n\n  isPropValid = function (key) {\n    // Handle events explicitly as Emotion validates them all as true\n    if (key.startsWith(\"on\")) {\n      return !isValidMotionProp(key);\n    } else {\n      return emotionIsPropValid_1(key);\n    }\n  };\n} catch (_a) {// We don't need to actually do anything here - the fallback is the existing `isPropValid`.\n}\n\nfunction filterProps(props) {\n  var domProps = {};\n\n  for (var key in props) {\n    if (isPropValid(key)) domProps[key] = props[key];\n  }\n\n  return domProps;\n}\n\nfunction buildHTMLProps(visualElement, _a) {\n  var drag = _a.drag; // The `any` isn't ideal but it is the type of createElement props argument\n\n  var htmlProps = {\n    style: __assign(__assign(__assign({}, visualElement.reactStyle), visualElement.style), visualElement.vars)\n  };\n\n  if (!!drag) {\n    // Disable text selection\n    htmlProps.style.userSelect = \"none\"; // Disable the ghost element when a user drags\n\n    htmlProps.draggable = false;\n  }\n\n  return htmlProps;\n}\n/**\r\n * Build React props for SVG elements\r\n */\n\n\nfunction buildSVGProps(visualElement) {\n  return __assign(__assign({}, visualElement.attrs), {\n    style: __assign({}, visualElement.reactStyle)\n  });\n}\n\nfunction render(Component, props, visualElement) {\n  // Only filter props from components we control, ie `motion.div`. If this\n  // is a custom component pass along everything provided to it.\n  var forwardedProps = typeof Component === \"string\" ? filterProps(props) : props;\n  /**\r\n   * Every render, empty and rebuild the animated values to be applied to our Element.\r\n   * During animation these data structures are used in a mutable fashion to reduce\r\n   * garbage collection, but between renders we can flush them to remove values\r\n   * that might have been taken out of the provided props.\r\n   */\n\n  visualElement.clean();\n  visualElement.build(true); // Generate props to visually render this component\n\n  var visualProps = isSVGComponent(Component) ? buildSVGProps(visualElement) : buildHTMLProps(visualElement, props);\n  return createElement(Component, __assign(__assign(__assign({}, forwardedProps), {\n    ref: visualElement.ref\n  }), visualProps));\n}\n\nfunction isCSSVariable$1(value) {\n  return typeof value === \"string\" && value.startsWith(\"var(--\");\n}\n/**\r\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\r\n *\r\n * ```\r\n * `var(--foo, #fff)` => [`--foo`, '#fff']\r\n * ```\r\n *\r\n * @param current\r\n */\n\n\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\n\nfunction parseCSSVariable(current) {\n  var match = cssVariableRegex.exec(current);\n  if (!match) return [,];\n  var token = match[1],\n      fallback = match[2];\n  return [token, fallback];\n}\n\nvar maxDepth = 4;\n\nfunction getVariableValue(current, element, depth) {\n  if (depth === void 0) {\n    depth = 1;\n  }\n\n  invariant(depth <= maxDepth, \"Max CSS variable fallback depth detected in property \\\"\" + current + \"\\\". This may indicate a circular fallback dependency.\");\n\n  var _a = parseCSSVariable(current),\n      token = _a[0],\n      fallback = _a[1]; // No CSS variable detected\n\n\n  if (!token) return; // Attempt to read this CSS variable off the element\n\n  var resolved = window.getComputedStyle(element).getPropertyValue(token);\n\n  if (resolved) {\n    return resolved;\n  } else if (isCSSVariable$1(fallback)) {\n    // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n    return getVariableValue(fallback, element, depth + 1);\n  } else {\n    return fallback;\n  }\n}\n/**\r\n * Resolve CSS variables from\r\n *\r\n * @internal\r\n */\n\n\nfunction resolveCSSVariables(visualElement, _a, transitionEnd) {\n  var target = __rest(_a, []);\n\n  var element = visualElement.getInstance();\n  if (!(element instanceof HTMLElement)) return {\n    target: target,\n    transitionEnd: transitionEnd\n  }; // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n  // only if they change but I think this reads clearer and this isn't a performance-critical path.\n\n  if (transitionEnd) {\n    transitionEnd = __assign({}, transitionEnd);\n  } // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n\n\n  visualElement.forEachValue(function (value) {\n    var current = value.get();\n    if (!isCSSVariable$1(current)) return;\n    var resolved = getVariableValue(current, element);\n    if (resolved) value.set(resolved);\n  }); // Cycle through every target property and resolve CSS variables. Currently\n  // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n\n  for (var key in target) {\n    var current = target[key];\n    if (!isCSSVariable$1(current)) continue;\n    var resolved = getVariableValue(current, element);\n    if (!resolved) continue; // Clone target if it hasn't already been\n\n    target[key] = resolved; // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n    // CSS variable. This will ensure that after the animation the component will reflect\n    // changes in the value of the CSS variable.\n\n    if (transitionEnd && transitionEnd[key] === undefined) {\n      transitionEnd[key] = current;\n    }\n  }\n\n  return {\n    target: target,\n    transitionEnd: transitionEnd\n  };\n}\n\nvar positionalKeys = new Set([\"width\", \"height\", \"top\", \"left\", \"right\", \"bottom\", \"x\", \"y\"]);\n\nvar isPositionalKey = function (key) {\n  return positionalKeys.has(key);\n};\n\nvar hasPositionalKey = function (target) {\n  return Object.keys(target).some(isPositionalKey);\n};\n\nvar setAndResetVelocity = function (value, to) {\n  // Looks odd but setting it twice doesn't render, it'll just\n  // set both prev and current to the latest value\n  value.set(to, false);\n  value.set(to);\n};\n\nvar isNumOrPxType = function (v) {\n  return v === number || v === px;\n};\n\nvar BoundingBoxDimension;\n\n(function (BoundingBoxDimension) {\n  BoundingBoxDimension[\"width\"] = \"width\";\n  BoundingBoxDimension[\"height\"] = \"height\";\n  BoundingBoxDimension[\"left\"] = \"left\";\n  BoundingBoxDimension[\"right\"] = \"right\";\n  BoundingBoxDimension[\"top\"] = \"top\";\n  BoundingBoxDimension[\"bottom\"] = \"bottom\";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\n\nvar getPosFromMatrix = function (matrix, pos) {\n  return parseFloat(matrix.split(\", \")[pos]);\n};\n\nvar getTranslateFromMatrix = function (pos2, pos3) {\n  return function (_bbox, _a) {\n    var transform = _a.transform;\n    if (transform === \"none\" || !transform) return 0;\n    var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n\n    if (matrix3d) {\n      return getPosFromMatrix(matrix3d[1], pos3);\n    } else {\n      var matrix = transform.match(/^matrix\\((.+)\\)$/);\n\n      if (matrix) {\n        return getPosFromMatrix(matrix[1], pos2);\n      } else {\n        return 0;\n      }\n    }\n  };\n};\n\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\nvar nonTranslationalTransformKeys = transformProps.filter(function (key) {\n  return !transformKeys.has(key);\n});\n\nfunction removeNonTranslationalTransform(visualElement) {\n  var removedTransforms = [];\n  nonTranslationalTransformKeys.forEach(function (key) {\n    var value = visualElement.getValue(key);\n\n    if (value !== undefined) {\n      removedTransforms.push([key, value.get()]);\n      value.set(key.startsWith(\"scale\") ? 1 : 0);\n    }\n  }); // Apply changes to element before measurement\n\n  if (removedTransforms.length) visualElement.render();\n  return removedTransforms;\n}\n\nvar positionalValues = {\n  // Dimensions\n  width: function (_a) {\n    var x = _a.x;\n    return x.max - x.min;\n  },\n  height: function (_a) {\n    var y = _a.y;\n    return y.max - y.min;\n  },\n  top: function (_bbox, _a) {\n    var top = _a.top;\n    return parseFloat(top);\n  },\n  left: function (_bbox, _a) {\n    var left = _a.left;\n    return parseFloat(left);\n  },\n  bottom: function (_a, _b) {\n    var y = _a.y;\n    var top = _b.top;\n    return parseFloat(top) + (y.max - y.min);\n  },\n  right: function (_a, _b) {\n    var x = _a.x;\n    var left = _b.left;\n    return parseFloat(left) + (x.max - x.min);\n  },\n  // Transform\n  x: getTranslateFromMatrix(4, 13),\n  y: getTranslateFromMatrix(5, 14)\n};\n\nvar convertChangedValueTypes = function (target, visualElement, changedKeys) {\n  var originBbox = visualElement.getBoundingBox();\n  var elementComputedStyle = visualElement.getComputedStyle();\n  var display = elementComputedStyle.display,\n      top = elementComputedStyle.top,\n      left = elementComputedStyle.left,\n      bottom = elementComputedStyle.bottom,\n      right = elementComputedStyle.right,\n      transform = elementComputedStyle.transform;\n  var originComputedStyle = {\n    top: top,\n    left: left,\n    bottom: bottom,\n    right: right,\n    transform: transform\n  }; // If the element is currently set to display: \"none\", make it visible before\n  // measuring the target bounding box\n\n  if (display === \"none\") {\n    visualElement.setStaticValues(\"display\", target.display || \"block\");\n  } // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n\n\n  visualElement.render();\n  var targetBbox = visualElement.getBoundingBox();\n  changedKeys.forEach(function (key) {\n    // Restore styles to their **calculated computed style**, not their actual\n    // originally set style. This allows us to animate between equivalent pixel units.\n    var value = visualElement.getValue(key);\n    setAndResetVelocity(value, positionalValues[key](originBbox, originComputedStyle));\n    target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n  });\n  return target;\n};\n\nvar checkAndConvertChangedValueTypes = function (visualElement, target, origin, transitionEnd) {\n  if (origin === void 0) {\n    origin = {};\n  }\n\n  if (transitionEnd === void 0) {\n    transitionEnd = {};\n  }\n\n  target = __assign({}, target);\n  transitionEnd = __assign({}, transitionEnd);\n  var targetPositionalKeys = Object.keys(target).filter(isPositionalKey); // We want to remove any transform values that could affect the element's bounding box before\n  // it's measured. We'll reapply these later.\n\n  var removedTransformValues = [];\n  var hasAttemptedToRemoveTransformValues = false;\n  var changedValueTypeKeys = [];\n  targetPositionalKeys.forEach(function (key) {\n    var value = visualElement.getValue(key);\n    if (!visualElement.hasValue(key)) return;\n    var from = origin[key];\n    var to = target[key];\n    var fromType = findDimensionValueType(from);\n    var toType; // TODO: The current implementation of this basically throws an error\n    // if you try and do value conversion via keyframes. There's probably\n    // a way of doing this but the performance implications would need greater scrutiny,\n    // as it'd be doing multiple resize-remeasure operations.\n\n    if (isKeyframesTarget(to)) {\n      var numKeyframes = to.length;\n\n      for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {\n        if (!toType) {\n          toType = findDimensionValueType(to[i]);\n          invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), \"Keyframes must be of the same dimension as the current value\");\n        } else {\n          invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n        }\n      }\n    } else {\n      toType = findDimensionValueType(to);\n    }\n\n    if (fromType !== toType) {\n      // If they're both just number or px, convert them both to numbers rather than\n      // relying on resize/remeasure to convert (which is wasteful in this situation)\n      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n        var current = value.get();\n\n        if (typeof current === \"string\") {\n          value.set(parseFloat(current));\n        }\n\n        if (typeof to === \"string\") {\n          target[key] = parseFloat(to);\n        } else if (Array.isArray(to) && toType === px) {\n          target[key] = to.map(parseFloat);\n        }\n      } else {\n        // If we're going to do value conversion via DOM measurements, we first\n        // need to remove non-positional transform values that could affect the bbox measurements.\n        if (!hasAttemptedToRemoveTransformValues) {\n          removedTransformValues = removeNonTranslationalTransform(visualElement);\n          hasAttemptedToRemoveTransformValues = true;\n        }\n\n        changedValueTypeKeys.push(key);\n        transitionEnd[key] = transitionEnd[key] !== undefined ? transitionEnd[key] : target[key];\n        setAndResetVelocity(value, to);\n      }\n    }\n  });\n\n  if (changedValueTypeKeys.length) {\n    var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys); // If we removed transform values, reapply them before the next render\n\n    if (removedTransformValues.length) {\n      removedTransformValues.forEach(function (_a) {\n        var key = _a[0],\n            value = _a[1];\n        visualElement.getValue(key).set(value);\n      });\n    } // Reapply original values\n\n\n    visualElement.render();\n    return {\n      target: convertedTarget,\n      transitionEnd: transitionEnd\n    };\n  } else {\n    return {\n      target: target,\n      transitionEnd: transitionEnd\n    };\n  }\n};\n/**\r\n * Convert value types for x/y/width/height/top/left/bottom/right\r\n *\r\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\r\n *\r\n * @internal\r\n */\n\n\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : {\n    target: target,\n    transitionEnd: transitionEnd\n  };\n}\n/**\r\n * Parse a DOM variant to make it animatable. This involves resolving CSS variables\r\n * and ensuring animations like \"20%\" => \"calc(50vw)\" are performed in pixels.\r\n */\n\n\nvar parseDomVariant = function (visualElement, target, origin, transitionEnd) {\n  var resolved = resolveCSSVariables(visualElement, target, transitionEnd);\n  target = resolved.target;\n  transitionEnd = resolved.transitionEnd;\n  return unitConversion(visualElement, target, origin, transitionEnd);\n};\n/**\r\n * Use callback either only on the initial render or on all renders. In concurrent mode\r\n * the \"initial\" render might run multiple times\r\n *\r\n * @param callback - Callback to run\r\n * @param isInitialOnly - Set to `true` to only run on initial render, or `false` for all renders. Defaults to `false`.\r\n *\r\n * @public\r\n */\n\n\nfunction useInitialOrEveryRender(callback, isInitialOnly) {\n  if (isInitialOnly === void 0) {\n    isInitialOnly = false;\n  }\n\n  var isInitialRender = useRef(true);\n\n  if (!isInitialOnly || isInitialOnly && isInitialRender.current) {\n    callback();\n  }\n\n  isInitialRender.current = false;\n}\n/**\r\n * Control animations on one or more components.\r\n *\r\n * @public\r\n */\n\n\nvar AnimationControls =\n/** @class */\nfunction () {\n  function AnimationControls() {\n    /**\r\n     * Track whether the host component has mounted.\r\n     *\r\n     * @internal\r\n     */\n    this.hasMounted = false;\n    /**\r\n     * Pending animations that are started before a component is mounted.\r\n     *\r\n     * @internal\r\n     */\n\n    this.pendingAnimations = [];\n    /**\r\n     * A collection of linked component animation controls.\r\n     *\r\n     * @internal\r\n     */\n\n    this.componentControls = new Set();\n  }\n  /**\r\n   * Set variants on this and all child components.\r\n   *\r\n   * @param variants - The variants to set\r\n   *\r\n   * @internal\r\n   */\n\n\n  AnimationControls.prototype.setVariants = function (variants) {\n    this.variants = variants;\n    this.componentControls.forEach(function (controls) {\n      return controls.setVariants(variants);\n    });\n  };\n  /**\r\n   * Set a default transition on this and all child components\r\n   *\r\n   * @param transition - The default transition to set\r\n   *\r\n   * @internal\r\n   */\n\n\n  AnimationControls.prototype.setDefaultTransition = function (transition) {\n    this.defaultTransition = transition;\n    this.componentControls.forEach(function (controls) {\n      return controls.setDefaultTransition(transition);\n    });\n  };\n  /**\r\n   * Subscribes a component's animation controls to this.\r\n   *\r\n   * @param controls - The controls to subscribe\r\n   * @returns An unsubscribe function.\r\n   *\r\n   * @internal\r\n   */\n\n\n  AnimationControls.prototype.subscribe = function (controls) {\n    var _this = this;\n\n    this.componentControls.add(controls);\n    if (this.variants) controls.setVariants(this.variants);\n    if (this.defaultTransition) controls.setDefaultTransition(this.defaultTransition);\n    return function () {\n      return _this.componentControls.delete(controls);\n    };\n  };\n  /**\r\n   * Starts an animation on all linked components.\r\n   *\r\n   * @remarks\r\n   *\r\n   * ```jsx\r\n   * controls.start(\"variantLabel\")\r\n   * controls.start({\r\n   *   x: 0,\r\n   *   transition: { duration: 1 }\r\n   * })\r\n   * ```\r\n   *\r\n   * @param definition - Properties or variant label to animate to\r\n   * @param transition - Optional `transtion` to apply to a variant\r\n   * @returns - A `Promise` that resolves when all animations have completed.\r\n   *\r\n   * @public\r\n   */\n\n\n  AnimationControls.prototype.start = function (definition, transitionOverride) {\n    var _this = this;\n\n    if (this.hasMounted) {\n      var animations_1 = [];\n      this.componentControls.forEach(function (controls) {\n        var animation = controls.start(definition, {\n          transitionOverride: transitionOverride\n        });\n        animations_1.push(animation);\n      });\n      return Promise.all(animations_1);\n    } else {\n      return new Promise(function (resolve) {\n        _this.pendingAnimations.push({\n          animation: [definition, transitionOverride],\n          resolve: resolve\n        });\n      });\n    }\n  };\n  /**\r\n   * Instantly set to a set of properties or a variant.\r\n   *\r\n   * ```jsx\r\n   * // With properties\r\n   * controls.set({ opacity: 0 })\r\n   *\r\n   * // With variants\r\n   * controls.set(\"hidden\")\r\n   * ```\r\n   *\r\n   * @internalremarks\r\n   * We could perform a similar trick to `.start` where this can be called before mount\r\n   * and we maintain a list of of pending actions that get applied on mount. But the\r\n   * expectation of `set` is that it happens synchronously and this would be difficult\r\n   * to do before any children have even attached themselves. It's also poor practise\r\n   * and we should discourage render-synchronous `.start` calls rather than lean into this.\r\n   *\r\n   * @public\r\n   */\n\n\n  AnimationControls.prototype.set = function (definition) {\n    invariant(this.hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n    return this.componentControls.forEach(function (controls) {\n      return controls.apply(definition);\n    });\n  };\n  /**\r\n   * Stops animations on all linked components.\r\n   *\r\n   * ```jsx\r\n   * controls.stop()\r\n   * ```\r\n   *\r\n   * @public\r\n   */\n\n\n  AnimationControls.prototype.stop = function () {\n    this.componentControls.forEach(function (controls) {\n      return controls.stop();\n    });\n  };\n  /**\r\n   * Initialises the animation controls.\r\n   *\r\n   * @internal\r\n   */\n\n\n  AnimationControls.prototype.mount = function () {\n    var _this = this;\n\n    this.hasMounted = true;\n    this.pendingAnimations.forEach(function (_a) {\n      var animation = _a.animation,\n          resolve = _a.resolve;\n      return _this.start.apply(_this, animation).then(resolve);\n    });\n  };\n  /**\r\n   * Stops all child animations when the host component unmounts.\r\n   *\r\n   * @internal\r\n   */\n\n\n  AnimationControls.prototype.unmount = function () {\n    this.hasMounted = false;\n    this.stop();\n  };\n\n  return AnimationControls;\n}();\n/**\r\n * @internal\r\n */\n\n\nvar animationControls = function () {\n  return new AnimationControls();\n};\n/**\r\n * @internal\r\n */\n\n\nvar MotionContext = createContext({\n  static: false\n});\n\nvar isVariantLabel = function (v) {\n  return typeof v === \"string\" || Array.isArray(v);\n};\n\nvar isAnimationControls = function (v) {\n  return v instanceof AnimationControls;\n};\n/**\r\n * Set up the context for children motion components.\r\n *\r\n * We also use this opportunity to apply `initial` values\r\n */\n\n\nvar useMotionContext = function (parentContext, controls, visualElement, isStatic, _a) {\n  if (isStatic === void 0) {\n    isStatic = false;\n  }\n\n  var initial = _a.initial,\n      animate = _a.animate,\n      variants = _a.variants,\n      whileTap = _a.whileTap,\n      whileHover = _a.whileHover,\n      layoutId = _a.layoutId; // Determine whether this is a root element of an AnimatePresence component\n\n  var presenceContext = useContext(PresenceContext);\n  var presenceId = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id;\n  visualElement.isPresenceRoot = parentContext.presenceId !== presenceId; // Override initial with that from a parent context, if defined\n\n  if ((presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) !== undefined) {\n    initial = presenceContext.initial;\n  }\n\n  var initialState;\n\n  if (initial === false && !isAnimationControls(animate)) {\n    initialState = animate;\n  } else if (typeof initial !== \"boolean\") {\n    initialState = initial;\n  } // Track mounted status so children can detect whether they were present during their\n  // parent's first render\n\n\n  var hasMounted = useRef(false); // We propagate this component's VisualElementAnimationControls *if* we're being provided variants,\n  // if we're being used to control variants, or if we're being passed animation controls.\n  // Otherwise this component should be \"invisible\" to variant propagation. This is a slight concession\n  // to Framer X where every `Frame` is a `motion` component and it might be if we change that in the future\n  // that this restriction is removed.\n\n  var shouldPropagateControls = variants || isVariantLabel(animate) || isVariantLabel(whileTap) || isVariantLabel(whileHover) || isAnimationControls(animate); // If this component's `initial` prop is a variant label, propagate it. Otherwise pass the parent's.\n\n  var targetInitial = isVariantLabel(initialState) ? initialState : parentContext.initial; // If this is a variant tree we need to propagate the `animate` prop in case new children are added after\n  // the tree initially animates.\n\n  var targetAnimate = isVariantLabel(animate) ? animate : parentContext.animate; // Only allow `initial` to trigger context re-renders if this is a `static` component (ie we're on the Framer canvas)\n  // or in another non-animation/interaction environment.\n\n  var initialDependency = isStatic ? targetInitial : null; // Only allow `animate` to trigger context re-renders if it's a variant label. If this is an array of\n  // variant labels there's probably an optimisation to deep-compare but it might be an over-optimisation.\n  // We want to do this as we rely on React's component rendering order each render cycle to determine\n  // the new order of any child components for the `staggerChildren` functionality.\n\n  var animateDependency = shouldPropagateControls && isVariantLabel(targetAnimate) ? targetAnimate : null; // The context to provide to the child. We `useMemo` because although `controls` and `initial` are\n  // unlikely to change, by making the context an object it'll be considered a new value every render.\n  // So all child motion components will re-render as a result.\n\n  var context = useMemo(function () {\n    return {\n      controls: shouldPropagateControls ? controls : parentContext.controls,\n      initial: targetInitial,\n      animate: targetAnimate,\n      visualElement: visualElement,\n      hasMounted: hasMounted,\n      isReducedMotion: parentContext.isReducedMotion,\n      presenceId: presenceId\n    };\n  }, [initialDependency, animateDependency, parentContext.isReducedMotion, animate, layoutId, presenceId]); // Update the `static` property every render. This is unlikely to change but also essentially free.\n\n  context.static = isStatic; // Set initial state. If this is a static component (ie in Framer canvas), respond to updates\n  // in `initial`.\n\n  useInitialOrEveryRender(function () {\n    var initialToApply = initialState || parentContext.initial;\n    initialToApply && controls.apply(initialToApply);\n  }, !isStatic);\n  useEffect(function () {\n    hasMounted.current = true;\n  }, []);\n  return context;\n};\n\nvar checkShouldInheritVariant = function (_a) {\n  var animate = _a.animate,\n      variants = _a.variants,\n      _b = _a.inherit,\n      inherit = _b === void 0 ? true : _b;\n  return inherit && !!variants && (!animate || animate instanceof AnimationControls);\n};\n\nvar isMotionValue = function (value) {\n  return value instanceof MotionValue;\n};\n/**\r\n * Scrape props for MotionValues and add/remove them to this component's\r\n * VisualElement\r\n */\n\n\nfunction useMotionValues(visualElement, props) {\n  var prev = useConstant(empty);\n  /**\r\n   * Remove MotionValues that are no longer present\r\n   */\n\n  for (var key in prev) {\n    var isTransform = isTransformProp(key) || isTransformOriginProp(key);\n    var existsAsProp = props[key];\n    var existsAsStyle = props.style && props.style[key];\n    var propIsMotionValue = existsAsProp && isMotionValue(props[key]);\n    var styleIsMotionValue = existsAsStyle && isMotionValue(props.style[key]);\n    var transformRemoved = isTransform && !existsAsProp && !existsAsStyle;\n    var motionValueRemoved = !isTransform && !propIsMotionValue && !styleIsMotionValue;\n\n    if (transformRemoved || motionValueRemoved) {\n      visualElement.removeValue(key);\n      delete prev[key];\n    }\n  }\n  /**\r\n   * Add incoming MotionValues\r\n   */\n\n\n  addMotionValues(visualElement, prev, props);\n  if (props.style) addMotionValues(visualElement, prev, props.style, true);\n  /**\r\n   * Transform custom values if provided a handler, ie size -> width/height\r\n   * Ideally we'd ditch this by removing support for size and other custom values from Framer.\r\n   */\n\n  if (props.transformValues) {\n    visualElement.reactStyle = props.transformValues(visualElement.reactStyle);\n  }\n}\n/**\r\n * Add incoming MotionValues\r\n *\r\n * TODO: Type the VisualElements properly\r\n */\n\n\nfunction addMotionValues(visualElement, prev, source, isStyle) {\n  if (isStyle === void 0) {\n    isStyle = false;\n  }\n\n  if (isStyle) visualElement.reactStyle = {};\n\n  for (var key in source) {\n    var value = source[key];\n    var foundMotionValue = false;\n\n    if (isMotionValue(value)) {\n      // If this is a MotionValue, add it if it isn't a reserved key\n      if (!reservedNames.has(key)) {\n        visualElement.addValue(key, value);\n        foundMotionValue = true;\n      }\n    } else if (isTransformProp(key) || isTransformOriginProp(key)) {\n      // If this is a transform prop, always create a MotionValue\n      // to ensure we can reconcile them all together.\n      if (!visualElement.hasValue(key)) {\n        visualElement.addValue(key, motionValue(value));\n      } else if (value !== prev[key]) {\n        // If the MotionValue already exists, update it with the\n        // latest incoming value\n        var motion = visualElement.getValue(key);\n        motion.set(value);\n      }\n\n      foundMotionValue = true;\n    } else if (isStyle) {\n      visualElement.reactStyle[key] = value;\n    }\n\n    if (foundMotionValue) prev[key] = value;\n  }\n}\n/**\r\n * These are props we accept as MotionValues but don't want to add\r\n * to the VisualElement\r\n */\n\n\nvar reservedNames = new Set([]);\n\nvar empty = function () {\n  return {};\n};\n\nvar isCustomValue = function (v) {\n  return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\n\nvar resolveFinalValueInKeyframes = function (v) {\n  // TODO maybe throw if v.length - 1 is placeholder token?\n  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n/**\r\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\r\n */\n\n\nvar isNumericalString = function (v) {\n  return /^\\-?\\d*\\.?\\d+$/.test(v);\n};\n/**\r\n * Get the current value of every `MotionValue` in a `VisualElement`\r\n */\n\n\nvar getCurrent = function (visualElement) {\n  var current = {};\n  visualElement.forEachValue(function (value, key) {\n    return current[key] = value.get();\n  });\n  return current;\n};\n/**\r\n * Get the current velocity of every `MotionValue` in a `VisualElement`\r\n */\n\n\nvar getVelocity = function (visualElement) {\n  var velocity = {};\n  visualElement.forEachValue(function (value, key) {\n    return velocity[key] = value.getVelocity();\n  });\n  return velocity;\n};\n/**\r\n * Check if value is a function that returns a `Target`. A generic typeof === 'function'\r\n * check, just helps with typing.\r\n */\n\n\nvar isTargetResolver = function (p) {\n  return typeof p === \"function\";\n};\n/**\r\n * Check if value is a list of variant labels\r\n */\n\n\nvar isVariantLabels = function (v) {\n  return Array.isArray(v);\n};\n/**\r\n * Control animations for a single component\r\n *\r\n * @internal\r\n */\n\n\nvar VisualElementAnimationControls =\n/** @class */\nfunction () {\n  function VisualElementAnimationControls(visualElement, _a) {\n    var _this = this;\n\n    var makeTargetAnimatable = _a.makeTargetAnimatable;\n    /**\r\n     * A reference to the component's latest props. We could probably ditch this in\r\n     * favour to a reference to the `custom` prop now we don't send all props through\r\n     * to target resolvers.\r\n     */\n\n    this.props = {};\n    /**\r\n     * The component's variants, as provided by `variants`\r\n     */\n\n    this.variants = {};\n    /**\r\n     * A set of values that we animate back to when a value is cleared of all overrides.\r\n     */\n\n    this.baseTarget = {};\n    /**\r\n     * A series of target overrides that we can animate to/from when overrides are set/cleared.\r\n     */\n\n    this.overrides = [];\n    /**\r\n     * A series of target overrides as they were originally resolved.\r\n     */\n\n    this.resolvedOverrides = [];\n    /**\r\n     * A Set of currently active override indexes\r\n     */\n\n    this.activeOverrides = new Set();\n    /**\r\n     * A Set of value keys that are currently animating.\r\n     */\n\n    this.isAnimating = new Set();\n    /**\r\n     * Check if the associated `VisualElement` has a key with the provided string.\r\n     * Pre-bound to the class so we can provide directly to the `filter` in `checkForNewValues`.\r\n     */\n\n    this.hasValue = function (key) {\n      return !_this.visualElement.hasValue(key);\n    };\n\n    this.visualElement = visualElement;\n    this.makeTargetAnimatable = makeTargetAnimatable;\n    this.visualElement.forEachValue(function (value, key) {\n      return _this.baseTarget[key] = value.get();\n    });\n  }\n  /**\r\n   * Set the reference to the component's props.\r\n   * @param props -\r\n   */\n\n\n  VisualElementAnimationControls.prototype.setProps = function (props) {\n    this.props = props;\n  };\n  /**\r\n   * Set the reference to the component's variants\r\n   * @param variants -\r\n   */\n\n\n  VisualElementAnimationControls.prototype.setVariants = function (variants) {\n    if (variants) this.variants = variants;\n  };\n  /**\r\n   * Set the component's default transition\r\n   * @param transition -\r\n   */\n\n\n  VisualElementAnimationControls.prototype.setDefaultTransition = function (transition) {\n    if (transition) this.defaultTransition = transition;\n  };\n  /**\r\n   * Set motion values without animation.\r\n   *\r\n   * @param definition -\r\n   * @param isActive -\r\n   */\n\n\n  VisualElementAnimationControls.prototype.setValues = function (definition, _a) {\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.isActive,\n        isActive = _c === void 0 ? new Set() : _c,\n        priority = _b.priority;\n\n    var _d = this.resolveVariant(definition),\n        target = _d.target,\n        transitionEnd = _d.transitionEnd;\n\n    target = this.transformValues(__assign(__assign({}, target), transitionEnd));\n\n    for (var key in target) {\n      if (isActive.has(key)) return;\n      isActive.add(key);\n\n      if (target) {\n        var targetValue = resolveFinalValueInKeyframes(target[key]);\n\n        if (this.visualElement.hasValue(key)) {\n          var value = this.visualElement.getValue(key);\n          value && value.set(targetValue);\n        } else {\n          this.visualElement.addValue(key, motionValue(targetValue));\n        }\n\n        if (!priority) this.baseTarget[key] = targetValue;\n      }\n    }\n  };\n  /**\r\n   * Allows `transformValues` to be set by a component that allows us to\r\n   * transform the values in a given `Target`. This allows Framer Library\r\n   * to extend Framer Motion to animate `Color` variables etc. Currently we have\r\n   * to manually support these extended types here in Framer Motion.\r\n   *\r\n   * @param values -\r\n   */\n\n\n  VisualElementAnimationControls.prototype.transformValues = function (values) {\n    var transformValues = this.props.transformValues;\n    return transformValues ? transformValues(values) : values;\n  };\n  /**\r\n   * Check a `Target` for new values we haven't animated yet, and add them\r\n   * to the `MotionValueMap`.\r\n   *\r\n   * Currently there's functionality here that is DOM-specific, we should allow\r\n   * this functionality to be injected by the factory that creates DOM-specific\r\n   * components.\r\n   *\r\n   * @param target -\r\n   */\n\n\n  VisualElementAnimationControls.prototype.checkForNewValues = function (target) {\n    var newValueKeys = Object.keys(target).filter(this.hasValue);\n    var numNewValues = newValueKeys.length;\n    if (!numNewValues) return;\n\n    for (var i = 0; i < numNewValues; i++) {\n      var key = newValueKeys[i];\n      var targetValue = target[key];\n      var value = null; // If this is a keyframes value, we can attempt to use the first value in the\n      // array as that's going to be the first value of the animation anyway\n\n      if (Array.isArray(targetValue)) {\n        value = targetValue[0];\n      } // If it isn't a keyframes or the first keyframes value was set as `null`, read the\n      // value from the DOM. It might be worth investigating whether to check props (for SVG)\n      // or props.style (for HTML) if the value exists there before attempting to read.\n\n\n      if (value === null) {\n        var readValue = this.visualElement.readNativeValue(key);\n        value = readValue !== undefined ? readValue : target[key];\n        invariant(value !== null, \"No initial value for \\\"\" + key + \"\\\" can be inferred. Ensure an initial value for \\\"\" + key + \"\\\" is defined on the component.\");\n      }\n\n      if (typeof value === \"string\" && isNumericalString(value)) {\n        // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n        value = parseFloat(value);\n      } else if (!findValueType(value) && complex.test(targetValue)) {\n        // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n        value = complex.getAnimatableNone(targetValue);\n      }\n\n      this.visualElement.addValue(key, motionValue(value));\n      this.baseTarget[key] = value;\n    }\n  };\n  /**\r\n   * Resolve a variant from its label or resolver into an actual `Target` we can animate to.\r\n   * @param variant -\r\n   */\n\n\n  VisualElementAnimationControls.prototype.resolveVariant = function (variant) {\n    if (!variant) {\n      return {\n        target: undefined,\n        transition: undefined,\n        transitionEnd: undefined\n      };\n    }\n\n    if (isTargetResolver(variant)) {\n      // resolve current and velocity\n      variant = variant(this.props.custom, getCurrent(this.visualElement), getVelocity(this.visualElement));\n    }\n\n    var _a = variant.transition,\n        transition = _a === void 0 ? this.defaultTransition : _a,\n        transitionEnd = variant.transitionEnd,\n        target = __rest(variant, [\"transition\", \"transitionEnd\"]);\n\n    return {\n      transition: transition,\n      transitionEnd: transitionEnd,\n      target: target\n    };\n  };\n  /**\r\n   * Get the highest active override priority index\r\n   */\n\n\n  VisualElementAnimationControls.prototype.getHighestPriority = function () {\n    if (!this.activeOverrides.size) return 0;\n    return Math.max.apply(Math, Array.from(this.activeOverrides));\n  };\n  /**\r\n   * Set an override. We add this layer of indirection so if, for instance, a tap gesture\r\n   * starts and overrides a hover gesture, when we clear the tap gesture and fallback to the\r\n   * hover gesture, if that hover gesture has changed in the meantime we can go to that rather\r\n   * than the one that was resolved when the hover gesture animation started.\r\n   *\r\n   * @param definition -\r\n   * @param overrideIndex -\r\n   */\n\n\n  VisualElementAnimationControls.prototype.setOverride = function (definition, overrideIndex) {\n    this.overrides[overrideIndex] = definition;\n\n    if (this.children) {\n      this.children.forEach(function (child) {\n        return child.setOverride(definition, overrideIndex);\n      });\n    }\n  };\n  /**\r\n   * Start an override animation.\r\n   * @param overrideIndex -\r\n   */\n\n\n  VisualElementAnimationControls.prototype.startOverride = function (overrideIndex) {\n    var override = this.overrides[overrideIndex];\n\n    if (override) {\n      return this.start(override, {\n        priority: overrideIndex\n      });\n    }\n  };\n  /**\r\n   * Clear an override. We check every value we animated to in this override to see if\r\n   * its present on any lower-priority overrides. If not, we animate it back to its base target.\r\n   * @param overrideIndex -\r\n   */\n\n\n  VisualElementAnimationControls.prototype.clearOverride = function (overrideIndex) {\n    var _this = this;\n\n    if (this.children) {\n      this.children.forEach(function (child) {\n        return child.clearOverride(overrideIndex);\n      });\n    }\n\n    var override = this.overrides[overrideIndex];\n    if (!override) return;\n    this.activeOverrides.delete(overrideIndex);\n    var highest = this.getHighestPriority();\n    this.resetIsAnimating();\n\n    if (highest) {\n      var highestOverride = this.overrides[highest];\n      highestOverride && this.startOverride(highest);\n    } // Figure out which remaining values were affected by the override and animate those\n\n\n    var overrideTarget = this.resolvedOverrides[overrideIndex];\n    if (!overrideTarget) return;\n    var remainingValues = {};\n\n    for (var key in this.baseTarget) {\n      if (overrideTarget[key] !== undefined) {\n        remainingValues[key] = this.baseTarget[key];\n      }\n    }\n\n    this.onStart();\n    this.animate(remainingValues).then(function () {\n      return _this.onComplete();\n    });\n  };\n  /**\r\n   * Apply a target/variant without any animation\r\n   */\n\n\n  VisualElementAnimationControls.prototype.apply = function (definition) {\n    if (Array.isArray(definition)) {\n      return this.applyVariantLabels(definition);\n    } else if (typeof definition === \"string\") {\n      return this.applyVariantLabels([definition]);\n    } else {\n      this.setValues(definition);\n    }\n  };\n  /**\r\n   * Apply variant labels without animation\r\n   */\n\n\n  VisualElementAnimationControls.prototype.applyVariantLabels = function (variantLabelList) {\n    var _this = this;\n\n    var isActive = new Set();\n\n    var reversedList = __spreadArrays(variantLabelList).reverse();\n\n    reversedList.forEach(function (key) {\n      var _a = _this.resolveVariant(_this.variants[key]),\n          target = _a.target,\n          transitionEnd = _a.transitionEnd;\n\n      if (transitionEnd) {\n        _this.setValues(transitionEnd, {\n          isActive: isActive\n        });\n      }\n\n      if (target) {\n        _this.setValues(target, {\n          isActive: isActive\n        });\n      }\n\n      if (_this.children && _this.children.size) {\n        _this.children.forEach(function (child) {\n          return child.applyVariantLabels(variantLabelList);\n        });\n      }\n    });\n  };\n\n  VisualElementAnimationControls.prototype.start = function (definition, opts) {\n    var _this = this;\n\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    if (opts.priority) {\n      this.activeOverrides.add(opts.priority);\n    }\n\n    this.resetIsAnimating(opts.priority);\n    var animation;\n\n    if (isVariantLabels(definition)) {\n      animation = this.animateVariantLabels(definition, opts);\n    } else if (typeof definition === \"string\") {\n      animation = this.animateVariant(definition, opts);\n    } else {\n      animation = this.animate(definition, opts);\n    }\n\n    this.onStart();\n    return animation.then(function () {\n      return _this.onComplete();\n    });\n  };\n\n  VisualElementAnimationControls.prototype.animate = function (animationDefinition, _a) {\n    var _this = this;\n\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.delay,\n        delay = _c === void 0 ? 0 : _c,\n        _d = _b.priority,\n        priority = _d === void 0 ? 0 : _d,\n        transitionOverride = _b.transitionOverride;\n\n    var _e = this.resolveVariant(animationDefinition),\n        target = _e.target,\n        transition = _e.transition,\n        transitionEnd = _e.transitionEnd;\n\n    if (transitionOverride) {\n      transition = transitionOverride;\n    }\n\n    if (!target) return Promise.resolve();\n    target = this.transformValues(target);\n\n    if (transitionEnd) {\n      transitionEnd = this.transformValues(transitionEnd);\n    }\n\n    this.checkForNewValues(target);\n    var origin = this.transformValues(getOrigin(target, transition, this.visualElement));\n\n    if (this.makeTargetAnimatable) {\n      var animatable = this.makeTargetAnimatable(this.visualElement, target, origin, transitionEnd);\n      target = animatable.target;\n      transitionEnd = animatable.transitionEnd;\n    }\n\n    if (priority) {\n      this.resolvedOverrides[priority] = target;\n    }\n\n    this.checkForNewValues(target);\n    var animations = [];\n\n    for (var key in target) {\n      var value = this.visualElement.getValue(key);\n      if (!value || !target || target[key] === undefined) continue;\n      var valueTarget = target[key];\n\n      if (!priority) {\n        this.baseTarget[key] = resolveFinalValueInKeyframes(valueTarget);\n      }\n\n      if (this.isAnimating.has(key)) continue;\n      this.isAnimating.add(key);\n      animations.push(startAnimation(key, value, valueTarget, __assign({\n        delay: delay\n      }, transition)));\n    }\n\n    var allAnimations = Promise.all(animations);\n    return transitionEnd ? allAnimations.then(function () {\n      _this.setValues(transitionEnd, {\n        priority: priority\n      });\n    }) : allAnimations;\n  };\n\n  VisualElementAnimationControls.prototype.animateVariantLabels = function (variantLabels, opts) {\n    var _this = this;\n\n    var animations = __spreadArrays(variantLabels).reverse().map(function (label) {\n      return _this.animateVariant(label, opts);\n    });\n\n    return Promise.all(animations);\n  };\n\n  VisualElementAnimationControls.prototype.animateVariant = function (variantLabel, opts) {\n    var _this = this;\n\n    var when = false;\n    var delayChildren = 0;\n    var staggerChildren = 0;\n    var staggerDirection = 1;\n    var priority = opts && opts.priority || 0;\n    var variant = this.variants[variantLabel];\n    var getAnimations = variant ? function () {\n      return _this.animate(variant, opts);\n    } : function () {\n      return Promise.resolve();\n    };\n    var getChildrenAnimations = this.children ? function () {\n      return _this.animateChildren(variantLabel, delayChildren, staggerChildren, staggerDirection, priority);\n    } : function () {\n      return Promise.resolve();\n    };\n\n    if (variant && this.children) {\n      var transition = this.resolveVariant(variant).transition;\n\n      if (transition) {\n        when = transition.when || when;\n        delayChildren = transition.delayChildren || delayChildren;\n        staggerChildren = transition.staggerChildren || staggerChildren;\n        staggerDirection = transition.staggerDirection || staggerDirection;\n      }\n    }\n\n    if (when) {\n      var _a = when === \"beforeChildren\" ? [getAnimations, getChildrenAnimations] : [getChildrenAnimations, getAnimations],\n          first = _a[0],\n          last = _a[1];\n\n      return first().then(last);\n    } else {\n      return Promise.all([getAnimations(), getChildrenAnimations()]);\n    }\n  };\n\n  VisualElementAnimationControls.prototype.animateChildren = function (variantLabel, delayChildren, staggerChildren, staggerDirection, priority) {\n    if (delayChildren === void 0) {\n      delayChildren = 0;\n    }\n\n    if (staggerChildren === void 0) {\n      staggerChildren = 0;\n    }\n\n    if (staggerDirection === void 0) {\n      staggerDirection = 1;\n    }\n\n    if (priority === void 0) {\n      priority = 0;\n    }\n\n    if (!this.children) {\n      return Promise.resolve();\n    }\n\n    var animations = [];\n    var maxStaggerDuration = (this.children.size - 1) * staggerChildren;\n    var generateStaggerDuration = staggerDirection === 1 ? function (i) {\n      return i * staggerChildren;\n    } : function (i) {\n      return maxStaggerDuration - i * staggerChildren;\n    };\n    Array.from(this.children).forEach(function (childControls, i) {\n      var animation = childControls.animateVariant(variantLabel, {\n        priority: priority,\n        delay: delayChildren + generateStaggerDuration(i)\n      });\n      animations.push(animation);\n    });\n    return Promise.all(animations);\n  };\n\n  VisualElementAnimationControls.prototype.onStart = function () {\n    var onAnimationStart = this.props.onAnimationStart;\n    onAnimationStart && onAnimationStart();\n  };\n\n  VisualElementAnimationControls.prototype.onComplete = function () {\n    var onAnimationComplete = this.props.onAnimationComplete;\n    onAnimationComplete && onAnimationComplete();\n  };\n\n  VisualElementAnimationControls.prototype.checkOverrideIsAnimating = function (priority) {\n    var numOverrides = this.overrides.length;\n\n    for (var i = priority + 1; i < numOverrides; i++) {\n      var resolvedOverride = this.resolvedOverrides[i];\n\n      if (resolvedOverride) {\n        for (var key in resolvedOverride) {\n          this.isAnimating.add(key);\n        }\n      }\n    }\n  };\n\n  VisualElementAnimationControls.prototype.resetIsAnimating = function (priority) {\n    if (priority === void 0) {\n      priority = 0;\n    }\n\n    this.isAnimating.clear(); // If this isn't the highest priority gesture, block the animation\n    // of anything that's currently being animated\n\n    if (priority < this.getHighestPriority()) {\n      this.checkOverrideIsAnimating(priority);\n    }\n\n    if (this.children) {\n      this.children.forEach(function (child) {\n        return child.resetIsAnimating(priority);\n      });\n    }\n  };\n\n  VisualElementAnimationControls.prototype.stop = function () {\n    this.visualElement.forEachValue(function (value) {\n      return value.stop();\n    });\n  };\n  /**\r\n   * Add the controls of a child component.\r\n   * @param controls -\r\n   */\n\n\n  VisualElementAnimationControls.prototype.addChild = function (controls) {\n    if (!this.children) {\n      this.children = new Set();\n    }\n\n    this.children.add(controls); // We set child overrides when `setOverride` is called, but also have to do it here\n    // as the first time `setOverride` is called all the children might not have been added yet.\n\n    this.overrides.forEach(function (override, i) {\n      override && controls.setOverride(override, i);\n    });\n  };\n\n  VisualElementAnimationControls.prototype.removeChild = function (controls) {\n    if (!this.children) {\n      return;\n    }\n\n    this.children.delete(controls);\n  };\n\n  VisualElementAnimationControls.prototype.resetChildren = function () {\n    if (this.children) this.children.clear();\n  };\n\n  return VisualElementAnimationControls;\n}();\n\nfunction getOriginFromTransition(key, transition) {\n  if (!transition) return;\n  var valueTransition = transition[key] || transition[\"default\"] || transition;\n  return valueTransition.from;\n}\n\nfunction getOrigin(target, transition, visualElement) {\n  var _a, _b;\n\n  var origin = {};\n\n  for (var key in target) {\n    origin[key] = (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();\n  }\n\n  return origin;\n}\n/**\r\n * Creates an imperative set of controls to trigger animations.\r\n *\r\n * This allows a consolidated, uniform API for animations, to be triggered by other APIs like the `animate` prop, or the gesture handlers.\r\n *\r\n * @internal\r\n */\n\n\nfunction useVisualElementAnimation(visualElement, props, config) {\n  var subscribeToParentControls = checkShouldInheritVariant(props);\n  var variants = props.variants,\n      transition = props.transition;\n  var parentControls = useContext(MotionContext).controls;\n  var presenceContext = useContext(PresenceContext);\n  var controls = useConstant(function () {\n    return new VisualElementAnimationControls(visualElement, config);\n  }); // Reset and resubscribe children every render to ensure stagger order is correct\n\n  if (!presenceContext || presenceContext.isPresent) {\n    controls.resetChildren();\n    controls.setProps(props);\n    controls.setVariants(variants);\n    controls.setDefaultTransition(transition);\n  } // We have to subscribe to the parent controls within a useEffect rather than during render,\n  // as\n\n\n  useEffect(function () {\n    if (subscribeToParentControls && parentControls) {\n      parentControls.addChild(controls);\n    }\n  });\n  useEffect(function () {\n    return function () {\n      // Remove reference to onAnimationComplete from controls. All the MotionValues\n      // are unsubscribed from this component separately. We let animations run out\n      // as they might be animating other components.\n      var onAnimationComplete = props.onAnimationComplete,\n          unmountProps = __rest(props, [\"onAnimationComplete\"]);\n\n      controls.setProps(unmountProps);\n      parentControls && parentControls.removeChild(controls);\n    };\n  }, []);\n  return controls;\n}\n/**\r\n * @internal\r\n */\n\n\nvar MotionPluginContext = createContext({\n  transformPagePoint: function (p) {\n    return p;\n  },\n  features: []\n});\n/**\r\n * @remarks For now I think this should remain a private API for our own use\r\n * until we can figure out a nicer way of allowing people to add these\r\n *\r\n * @internal\r\n */\n\nfunction MotionPlugins(_a) {\n  var children = _a.children,\n      props = __rest(_a, [\"children\"]);\n\n  var pluginContext = useContext(MotionPluginContext);\n  var value = useRef(__assign({}, pluginContext)).current; // Mutative to prevent triggering rerenders in all listening\n  // components every time this component renders\n\n  for (var key in props) {\n    value[key] = props[key];\n  }\n\n  return createElement(MotionPluginContext.Provider, {\n    value: value\n  }, children);\n}\n\nfunction createLock(name) {\n  var lock = null;\n  return function () {\n    var openLock = function () {\n      lock = null;\n    };\n\n    if (lock === null) {\n      lock = name;\n      return openLock;\n    }\n\n    return false;\n  };\n}\n\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\nvar globalVerticalLock = createLock(\"dragVertical\");\n\nfunction getGlobalLock(drag) {\n  var lock = false;\n\n  if (drag === \"y\") {\n    lock = globalVerticalLock();\n  } else if (drag === \"x\") {\n    lock = globalHorizontalLock();\n  } else {\n    var openHorizontal_1 = globalHorizontalLock();\n    var openVertical_1 = globalVerticalLock();\n\n    if (openHorizontal_1 && openVertical_1) {\n      lock = function () {\n        openHorizontal_1();\n        openVertical_1();\n      };\n    } else {\n      // Release the locks because we don't use them\n      if (openHorizontal_1) openHorizontal_1();\n      if (openVertical_1) openVertical_1();\n    }\n  }\n\n  return lock;\n}\n\nvar isViewportScrollBlocked = false;\nvar isBrowser = typeof window !== \"undefined\";\n\nif (isBrowser) {\n  document.addEventListener(\"touchmove\", function (event) {\n    if (isViewportScrollBlocked) {\n      event.preventDefault();\n    }\n  }, {\n    passive: false\n  });\n}\n\nvar blockViewportScroll = function () {\n  return isViewportScrollBlocked = true;\n};\n\nvar unblockViewportScroll = function () {\n  return isViewportScrollBlocked = false;\n};\n\nfunction addDomEvent(target, eventName, handler, options) {\n  if (!handler) return;\n  target.addEventListener(eventName, handler, options);\n  return function () {\n    return target.removeEventListener(eventName, handler, options);\n  };\n}\n/**\r\n * Attaches an event listener directly to the provided DOM element.\r\n *\r\n * Bypassing React's event system can be desirable, for instance when attaching non-passive\r\n * event handlers.\r\n *\r\n * ```jsx\r\n * const ref = useRef(null)\r\n *\r\n * useDomEvent(ref, 'wheel', onWheel, { passive: false })\r\n *\r\n * return <div ref={ref} />\r\n * ```\r\n *\r\n * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.\r\n * @param eventName - Name of the event you want listen for.\r\n * @param handler - Function to fire when receiving the event.\r\n * @param options - Options to pass to `Event.addEventListener`.\r\n *\r\n * @public\r\n */\n\n\nfunction useDomEvent(ref, eventName, handler, options) {\n  useEffect(function () {\n    var element = ref.current;\n\n    if (handler && element) {\n      return addDomEvent(element, eventName, handler, options);\n    }\n  }, [ref, eventName, handler, options]);\n}\n\nfunction isMouseEvent(event) {\n  // PointerEvent inherits from MouseEvent so we can't use a straight instanceof check.\n  if (typeof PointerEvent !== \"undefined\" && event instanceof PointerEvent) {\n    return !!(event.pointerType === \"mouse\");\n  }\n\n  return event instanceof MouseEvent;\n}\n\nfunction isTouchEvent(event) {\n  var hasTouches = !!event.touches;\n  return hasTouches;\n}\n/**\r\n * Filters out events not attached to the primary pointer (currently left mouse button)\r\n * @param eventHandler\r\n */\n\n\nfunction filterPrimaryPointer(eventHandler) {\n  if (!eventHandler) return undefined;\n  return function (event) {\n    var isMouseEvent = event instanceof MouseEvent;\n    var isPrimaryPointer = !isMouseEvent || isMouseEvent && event.button === 0;\n\n    if (isPrimaryPointer) {\n      eventHandler(event);\n    }\n  };\n}\n\nvar defaultPagePoint = {\n  pageX: 0,\n  pageY: 0\n};\n\nfunction pointFromTouch(e, pointType) {\n  if (pointType === void 0) {\n    pointType = \"page\";\n  }\n\n  var primaryTouch = e.touches[0] || e.changedTouches[0];\n  var point = primaryTouch || defaultPagePoint;\n  return {\n    x: point[pointType + \"X\"],\n    y: point[pointType + \"Y\"]\n  };\n}\n\nfunction pointFromMouse(point, pointType) {\n  if (pointType === void 0) {\n    pointType = \"page\";\n  }\n\n  return {\n    x: point[pointType + \"X\"],\n    y: point[pointType + \"Y\"]\n  };\n}\n\nfunction extractEventInfo(event, pointType) {\n  if (pointType === void 0) {\n    pointType = \"page\";\n  }\n\n  return {\n    point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)\n  };\n}\n\nfunction getViewportPointFromEvent(event) {\n  return extractEventInfo(event, \"client\");\n}\n\nvar wrapHandler = function (handler, shouldFilterPrimaryPointer) {\n  if (shouldFilterPrimaryPointer === void 0) {\n    shouldFilterPrimaryPointer = false;\n  }\n\n  if (!handler) return;\n\n  var listener = function (event) {\n    return handler(event, extractEventInfo(event));\n  };\n\n  return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;\n};\n\nvar isBrowser$1 = typeof window !== \"undefined\"; // We check for event support via functions in case they've been mocked by a testing suite.\n\nvar supportsPointerEvents = function () {\n  return isBrowser$1 && window.onpointerdown === null;\n};\n\nvar supportsTouchEvents = function () {\n  return isBrowser$1 && window.ontouchstart === null;\n};\n\nvar supportsMouseEvents = function () {\n  return isBrowser$1 && window.onmousedown === null;\n};\n\nvar mouseEventNames = {\n  pointerdown: \"mousedown\",\n  pointermove: \"mousemove\",\n  pointerup: \"mouseup\",\n  pointercancel: \"mousecancel\",\n  pointerover: \"mouseover\",\n  pointerout: \"mouseout\",\n  pointerenter: \"mouseenter\",\n  pointerleave: \"mouseleave\"\n};\nvar touchEventNames = {\n  pointerdown: \"touchstart\",\n  pointermove: \"touchmove\",\n  pointerup: \"touchend\",\n  pointercancel: \"touchcancel\"\n};\n\nfunction getPointerEventName(name) {\n  if (supportsPointerEvents()) {\n    return name;\n  } else if (supportsTouchEvents()) {\n    return touchEventNames[name];\n  } else if (supportsMouseEvents()) {\n    return mouseEventNames[name];\n  }\n\n  return name;\n}\n\nfunction addPointerEvent(target, eventName, handler, options) {\n  return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\n\nfunction usePointerEvent(ref, eventName, handler, options) {\n  return useDomEvent(ref, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\n/** @public */\n\n\nvar Point;\n\n(function (Point) {\n  /** @beta */\n  Point.subtract = function (a, b) {\n    return {\n      x: a.x - b.x,\n      y: a.y - b.y\n    };\n  };\n  /** @beta */\n\n\n  Point.relativeTo = function (idOrElem) {\n    var elem;\n\n    var getElem = function () {\n      // Caching element here could be leaky because of React lifecycle\n      if (elem !== undefined) return elem;\n\n      if (typeof idOrElem === \"string\") {\n        elem = document.getElementById(idOrElem);\n      } else {\n        elem = idOrElem;\n      }\n\n      return elem;\n    };\n\n    return function (_a) {\n      var x = _a.x,\n          y = _a.y;\n      var localElem = getElem();\n      if (!localElem) return undefined;\n      var rect = localElem.getBoundingClientRect();\n      return {\n        x: x - rect.left - window.scrollX,\n        y: y - rect.top - window.scrollY\n      };\n    };\n  };\n})(Point || (Point = {}));\n/**\r\n * @internal\r\n */\n\n\nvar PanSession =\n/** @class */\nfunction () {\n  function PanSession(event, handlers, _a) {\n    var _this = this;\n\n    var transformPagePoint = (_a === void 0 ? {} : _a).transformPagePoint;\n    /**\r\n     * @internal\r\n     */\n\n    this.startEvent = null;\n    /**\r\n     * @internal\r\n     */\n\n    this.lastMoveEvent = null;\n    /**\r\n     * @internal\r\n     */\n\n    this.lastMoveEventInfo = null;\n    /**\r\n     * @internal\r\n     */\n\n    this.handlers = {};\n\n    this.updatePoint = function () {\n      if (!(_this.lastMoveEvent && _this.lastMoveEventInfo)) return;\n      var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\n      var isPanStarted = _this.startEvent !== null; // Only start panning if the offset is larger than 3 pixels. If we make it\n      // any larger than this we'll want to reset the pointer history\n      // on the first update to avoid visual snapping to the cursoe.\n\n      var isDistancePastThreshold = distance(info.offset, {\n        x: 0,\n        y: 0\n      }) >= 3;\n      if (!isPanStarted && !isDistancePastThreshold) return;\n      var point = info.point;\n      var timestamp = getFrameData().timestamp;\n\n      _this.history.push(__assign(__assign({}, point), {\n        timestamp: timestamp\n      }));\n\n      var _a = _this.handlers,\n          onStart = _a.onStart,\n          onMove = _a.onMove;\n\n      if (!isPanStarted) {\n        onStart && onStart(_this.lastMoveEvent, info);\n        _this.startEvent = _this.lastMoveEvent;\n      }\n\n      onMove && onMove(_this.lastMoveEvent, info);\n    }; // If we have more than one touch, don't start detecting this gesture\n\n\n    if (isTouchEvent(event) && event.touches.length > 1) return;\n    this.handlers = handlers;\n    this.transformPagePoint = transformPagePoint;\n    var info = extractEventInfo(event);\n    var initialInfo = transformPoint(info, this.transformPagePoint);\n    var point = initialInfo.point;\n    var timestamp = getFrameData().timestamp;\n    this.history = [__assign(__assign({}, point), {\n      timestamp: timestamp\n    })];\n    var onSessionStart = handlers.onSessionStart;\n    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n    var removeOnPointerMove = addPointerEvent(window, \"pointermove\", function (event, info) {\n      return _this.handlePointerMove(event, info);\n    });\n    var removeOnPointerUp = addPointerEvent(window, \"pointerup\", function (event, info) {\n      return _this.handlePointerUp(event, info);\n    });\n\n    this.removeListeners = function () {\n      removeOnPointerMove && removeOnPointerMove();\n      removeOnPointerUp && removeOnPointerUp();\n    };\n  }\n\n  PanSession.prototype.handlePointerMove = function (event, info) {\n    this.lastMoveEvent = event;\n    this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint); // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n\n    if (isMouseEvent(event) && event.buttons === 0) {\n      this.handlePointerUp(event, info);\n      return;\n    } // Throttle mouse move event to once per frame\n\n\n    sync.update(this.updatePoint, true);\n  };\n\n  PanSession.prototype.handlePointerUp = function (event, info) {\n    this.end();\n    var onEnd = this.handlers.onEnd;\n    if (!onEnd) return;\n    var panInfo = getPanInfo(transformPoint(info, this.transformPagePoint), this.history);\n    onEnd && onEnd(event, panInfo);\n  };\n\n  PanSession.prototype.updateHandlers = function (handlers) {\n    this.handlers = handlers;\n  };\n\n  PanSession.prototype.end = function () {\n    this.removeListeners && this.removeListeners();\n    cancelSync.update(this.updatePoint);\n    unblockViewportScroll();\n  };\n\n  return PanSession;\n}();\n\nfunction transformPoint(info, transformPagePoint) {\n  return transformPagePoint ? {\n    point: transformPagePoint(info.point)\n  } : info;\n}\n\nfunction getPanInfo(_a, history) {\n  var point = _a.point;\n  return {\n    point: point,\n    delta: Point.subtract(point, lastDevicePoint(history)),\n    offset: Point.subtract(point, startDevicePoint(history)),\n    velocity: getVelocity$1(history, 0.1)\n  };\n}\n\nfunction startDevicePoint(history) {\n  return history[0];\n}\n\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\n\nfunction getVelocity$1(history, timeDelta) {\n  if (history.length < 2) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var i = history.length - 1;\n  var timestampedPoint = null;\n  var lastPoint = lastDevicePoint(history);\n\n  while (i >= 0) {\n    timestampedPoint = history[i];\n\n    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {\n      break;\n    }\n\n    i--;\n  }\n\n  if (!timestampedPoint) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n\n  if (time === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n\n  return currentVelocity;\n}\n/**\r\n * Apply constraints to a point. These constraints are both physical along an\r\n * axis, and an elastic factor that determines how much to constrain the point\r\n * by if it does lie outside the defined parameters.\r\n */\n\n\nfunction applyConstraints(point, _a, elastic) {\n  var min = _a.min,\n      max = _a.max;\n\n  if (min !== undefined && point < min) {\n    // If we have a min point defined, and this is outside of that, constrain\n    point = elastic ? mix(min, point, elastic) : Math.max(point, min);\n  } else if (max !== undefined && point > max) {\n    // If we have a max point defined, and this is outside of that, constrain\n    point = elastic ? mix(max, point, elastic) : Math.min(point, max);\n  }\n\n  return point;\n}\n/**\r\n * Calculates a min projection point based on a pointer, pointer progress\r\n * within the drag target, and constraints.\r\n *\r\n * For instance if an element was 100px width, we were dragging from 0.25\r\n * along this axis, the pointer is at 200px, and there were no constraints,\r\n * we would calculate a min projection point of 175px.\r\n */\n\n\nfunction calcConstrainedMinPoint(point, length, progress, constraints, elastic) {\n  // Calculate a min point for this axis and apply it to the current pointer\n  var min = point - length * progress;\n  return constraints ? applyConstraints(min, constraints, elastic) : min;\n}\n/**\r\n * Calculate constraints in terms of the viewport when\r\n * defined relatively to the measured axis.\r\n */\n\n\nfunction calcRelativeAxisConstraints(axis, min, max) {\n  var constraints = {};\n  var length = axis.max - axis.min;\n\n  if (min !== undefined) {\n    constraints.min = axis.min + min;\n  }\n\n  if (max !== undefined) {\n    constraints.max = Math.max(axis.min + max - length, axis.min + max);\n  }\n\n  return constraints;\n}\n/**\r\n * Calculate constraints in terms of the viewport when\r\n * defined relatively to the measured bounding box.\r\n */\n\n\nfunction calcRelativeConstraints(layoutBox, _a) {\n  var top = _a.top,\n      left = _a.left,\n      bottom = _a.bottom,\n      right = _a.right;\n  return {\n    x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)\n  };\n}\n/**\r\n * Calculate viewport constraints when defined as another viewport-relative axis\r\n */\n\n\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n  var _a;\n\n  var min = constraintsAxis.min - layoutAxis.min;\n  var max = constraintsAxis.max - layoutAxis.max; // If the constraints axis is actually smaller than the layout axis then we can\n  // flip the constraints\n\n  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {\n    _a = [max, min], min = _a[0], max = _a[1];\n  }\n\n  return {\n    min: layoutAxis.min + min,\n    max: layoutAxis.min + max\n  };\n}\n/**\r\n * Calculate viewport constraints when defined as another viewport-relative box\r\n */\n\n\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n  return {\n    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)\n  };\n}\n/**\r\n * Calculate the an axis position based on two axes and a progress value.\r\n */\n\n\nfunction calcPositionFromProgress(axis, constraints, progress) {\n  var axisLength = axis.max - axis.min;\n  var min = mix(constraints.min, constraints.max - axisLength, progress);\n  return {\n    min: min,\n    max: min + axisLength\n  };\n}\n\nvar elementDragControls = new WeakMap();\n/**\r\n *\r\n */\n\nvar lastPointerEvent;\n\nvar VisualElementDragControls =\n/** @class */\nfunction () {\n  function VisualElementDragControls(_a) {\n    var visualElement = _a.visualElement;\n    /**\r\n     * Track whether we're currently dragging.\r\n     *\r\n     * @internal\r\n     */\n\n    this.isDragging = false;\n    /**\r\n     * The current direction of drag, or `null` if both.\r\n     *\r\n     * @internal\r\n     */\n\n    this.currentDirection = null;\n    /**\r\n     * The permitted boundaries of travel, in pixels.\r\n     *\r\n     * @internal\r\n     */\n\n    this.constraints = false;\n    /**\r\n     * A reference to the host component's latest props.\r\n     *\r\n     * @internal\r\n     */\n\n    this.props = {};\n    /**\r\n     * Track the initial position of the cursor relative to the dragging element\r\n     * when dragging starts as a value of 0-1 on each axis. We then use this to calculate\r\n     * an ideal bounding box for the VisualElement renderer to project into every frame.\r\n     *\r\n     * @internal\r\n     */\n\n    this.cursorProgress = {\n      x: 0.5,\n      y: 0.5\n    }; // This is a reference to the global drag gesture lock, ensuring only one component\n    // can \"capture\" the drag of one or both axes.\n    // TODO: Look into moving this into pansession?\n\n    this.openGlobalLock = null;\n    /**\r\n     * @internal\r\n     */\n\n    this.panSession = null;\n    this.visualElement = visualElement;\n    this.visualElement.enableLayoutProjection();\n    elementDragControls.set(visualElement, this);\n  }\n  /**\r\n   * Instantiate a PanSession for the drag gesture\r\n   *\r\n   * @public\r\n   */\n\n\n  VisualElementDragControls.prototype.start = function (originEvent, _a) {\n    var _this = this;\n\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.snapToCursor,\n        snapToCursor = _c === void 0 ? false : _c,\n        cursorProgress = _b.cursorProgress;\n    /**\r\n     * If this drag session has been manually triggered by the user, it might be from an event\r\n     * outside the draggable element. If snapToCursor is set to true, we need to measure the position\r\n     * of the element and snap it to the cursor.\r\n     */\n\n\n    snapToCursor && this.snapToCursor(originEvent);\n\n    var onSessionStart = function () {\n      // Initiate viewport scroll blocking on touch start. This is a very aggressive approach\n      // which has come out of the difficulty in us being able to do this once a scroll gesture\n      // has initiated in mobile browsers. This means if there's a horizontally-scrolling carousel\n      // on a page we can't let a user scroll the page itself from it. Ideally what we'd do is\n      // trigger this once we've got a scroll direction determined. This approach sort-of worked\n      // but if the component was dragged too far in a single frame page scrolling would initiate.\n      blockViewportScroll(); // Stop any animations on both axis values immediately. This allows the user to throw and catch\n      // the component.\n\n      _this.stopMotion();\n    };\n\n    var onStart = function (event, info) {\n      var _a, _b; // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n\n\n      var _c = _this.props,\n          drag = _c.drag,\n          dragPropagation = _c.dragPropagation;\n\n      if (drag && !dragPropagation) {\n        if (_this.openGlobalLock) _this.openGlobalLock();\n        _this.openGlobalLock = getGlobalLock(drag); // If we don 't have the lock, don't start dragging\n\n        if (!_this.openGlobalLock) return;\n      }\n      /**\r\n       * Record the progress of the mouse within the draggable element on each axis.\r\n       * onPan, we're going to use this to calculate a new bounding box for the element to\r\n       * project into. This will ensure that even if the DOM element moves via a relayout, it'll\r\n       * stick to the correct place under the pointer.\r\n       */\n\n\n      _this.prepareBoundingBox();\n\n      _this.visualElement.lockTargetBox();\n      /**\r\n       * Resolve the drag constraints. These are either set as top/right/bottom/left constraints\r\n       * relative to the element's layout, or a ref to another element. Both need converting to\r\n       * viewport coordinates.\r\n       */\n\n\n      _this.resolveDragConstraints();\n      /**\r\n       * When dragging starts, we want to find where the cursor is relative to the bounding box\r\n       * of the element. Every frame, we calculate a new bounding box using this relative position\r\n       * and let the visualElement renderer figure out how to reproject the element into this bounding\r\n       * box.\r\n       *\r\n       * By doing it this way, rather than applying an x/y transform directly to the element,\r\n       * we can ensure the component always visually sticks to the cursor as we'd expect, even\r\n       * if the DOM element itself changes layout as a result of React updates the user might\r\n       * make based on the drag position.\r\n       */\n\n\n      var point = getViewportPointFromEvent(event).point;\n      eachAxis(function (axis) {\n        var _a = _this.visualElement.targetBox[axis],\n            min = _a.min,\n            max = _a.max;\n        _this.cursorProgress[axis] = cursorProgress ? cursorProgress[axis] : progress(min, max, point[axis]);\n      }); // Set current drag status\n\n      _this.isDragging = true;\n      _this.currentDirection = null; // Fire onDragStart event\n\n      (_b = (_a = _this.props).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a, event, info);\n    };\n\n    var onMove = function (event, info) {\n      var _a, _b, _c, _d;\n\n      var _e = _this.props,\n          dragPropagation = _e.dragPropagation,\n          dragDirectionLock = _e.dragDirectionLock; // If we didn't successfully receive the gesture lock, early return.\n\n      if (!dragPropagation && !_this.openGlobalLock) return;\n      var offset = info.offset; // Attempt to detect drag direction if directionLock is true\n\n      if (dragDirectionLock && _this.currentDirection === null) {\n        _this.currentDirection = getCurrentDirection(offset); // If we've successfully set a direction, notify listener\n\n        if (_this.currentDirection !== null) {\n          (_b = (_a = _this.props).onDirectionLock) === null || _b === void 0 ? void 0 : _b.call(_a, _this.currentDirection);\n        }\n\n        return;\n      } // Update each point with the latest position\n\n\n      _this.updateAxis(\"x\", event);\n\n      _this.updateAxis(\"y\", event); // Fire onDrag event\n\n\n      (_d = (_c = _this.props).onDrag) === null || _d === void 0 ? void 0 : _d.call(_c, event, info); // Update the last pointer event\n\n      lastPointerEvent = event;\n    };\n\n    var onEnd = function (event, info) {\n      return _this.stop(event, info);\n    };\n\n    var transformPagePoint = this.props.transformPagePoint;\n    this.panSession = new PanSession(originEvent, {\n      onSessionStart: onSessionStart,\n      onStart: onStart,\n      onMove: onMove,\n      onEnd: onEnd\n    }, {\n      transformPagePoint: transformPagePoint\n    });\n  };\n  /**\r\n   * Ensure the component's layout and target bounding boxes are up-to-date.\r\n   */\n\n\n  VisualElementDragControls.prototype.prepareBoundingBox = function () {\n    var element = this.visualElement.getInstance();\n    var transform = element.style.transform;\n    this.visualElement.resetTransform();\n    this.visualElement.measureLayout();\n    element.style.transform = transform;\n    this.visualElement.refreshTargetBox();\n  };\n\n  VisualElementDragControls.prototype.resolveDragConstraints = function () {\n    var dragConstraints = this.props.dragConstraints;\n\n    if (dragConstraints) {\n      this.constraints = isRefObject(dragConstraints) ? this.resolveRefConstraints(this.visualElement.box, dragConstraints) : calcRelativeConstraints(this.visualElement.box, dragConstraints);\n    } else {\n      this.constraints = false;\n    }\n  };\n\n  VisualElementDragControls.prototype.resolveRefConstraints = function (layoutBox, constraints) {\n    var _a = this.props,\n        onMeasureDragConstraints = _a.onMeasureDragConstraints,\n        transformPagePoint = _a.transformPagePoint;\n    var constraintsElement = constraints.current;\n    invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n    this.constraintsBox = getBoundingBox(constraintsElement, transformPagePoint);\n    var measuredConstraints = calcViewportConstraints(layoutBox, this.constraintsBox);\n    /**\r\n     * If there's an onMeasureDragConstraints listener we call it and\r\n     * if different constraints are returned, set constraints to that\r\n     */\n\n    if (onMeasureDragConstraints) {\n      var userConstraints = onMeasureDragConstraints(convertAxisBoxToBoundingBox(measuredConstraints));\n\n      if (userConstraints) {\n        measuredConstraints = convertBoundingBoxToAxisBox(userConstraints);\n      }\n    }\n\n    return measuredConstraints;\n  };\n\n  VisualElementDragControls.prototype.cancelDrag = function () {\n    unblockViewportScroll();\n    this.isDragging = false;\n    this.panSession && this.panSession.end();\n    this.panSession = null;\n\n    if (!this.props.dragPropagation && this.openGlobalLock) {\n      this.openGlobalLock();\n      this.openGlobalLock = null;\n    }\n  };\n\n  VisualElementDragControls.prototype.stop = function (event, info) {\n    var _a;\n\n    this.visualElement.unlockTargetBox();\n    (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\n    this.panSession = null;\n    var isDragging = this.isDragging;\n    this.cancelDrag();\n    if (!isDragging) return;\n    var _b = this.props,\n        dragMomentum = _b.dragMomentum,\n        dragElastic = _b.dragElastic,\n        onDragEnd = _b.onDragEnd;\n\n    if (dragMomentum || dragElastic) {\n      var velocity = info.velocity;\n      this.animateDragEnd(velocity);\n    }\n\n    onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event, info);\n  };\n\n  VisualElementDragControls.prototype.snapToCursor = function (event) {\n    this.prepareBoundingBox();\n    this.cursorProgress.x = 0.5;\n    this.cursorProgress.y = 0.5;\n    this.updateAxis(\"x\", event);\n    this.updateAxis(\"y\", event);\n  };\n  /**\r\n   * Update the specified axis with the latest pointer information.\r\n   */\n\n\n  VisualElementDragControls.prototype.updateAxis = function (axis, event) {\n    var _a;\n\n    var _b = this.props,\n        drag = _b.drag,\n        dragElastic = _b.dragElastic; // If we're not dragging this axis, do an early return.\n\n    if (!shouldDrag(axis, drag, this.currentDirection)) return; // Get the actual layout bounding box of the element\n\n    var axisLayout = this.visualElement.box[axis]; // Calculate its current length. In the future we might want to lerp this to animate\n    // between lengths if the layout changes as we change the DOM\n\n    var axisLength = axisLayout.max - axisLayout.min; // Get the initial progress that the pointer sat on this axis on gesture start.\n\n    var axisProgress = this.cursorProgress[axis];\n    var point = getViewportPointFromEvent(event).point; // Calculate a new min point based on the latest pointer position, constraints and elastic\n\n    var min = calcConstrainedMinPoint(point[axis], axisLength, axisProgress, (_a = this.constraints) === null || _a === void 0 ? void 0 : _a[axis], dragElastic); // Update the axis viewport target with this new min and the length\n\n    this.visualElement.setAxisTarget(axis, min, min + axisLength);\n  };\n\n  VisualElementDragControls.prototype.updateProps = function (_a) {\n    var _b = _a.drag,\n        drag = _b === void 0 ? false : _b,\n        _c = _a.dragDirectionLock,\n        dragDirectionLock = _c === void 0 ? false : _c,\n        _d = _a.dragPropagation,\n        dragPropagation = _d === void 0 ? false : _d,\n        _e = _a.dragConstraints,\n        dragConstraints = _e === void 0 ? false : _e,\n        _f = _a.dragElastic,\n        dragElastic = _f === void 0 ? 0.35 : _f,\n        _g = _a.dragMomentum,\n        dragMomentum = _g === void 0 ? true : _g,\n        remainingProps = __rest(_a, [\"drag\", \"dragDirectionLock\", \"dragPropagation\", \"dragConstraints\", \"dragElastic\", \"dragMomentum\"]);\n\n    this.props = __assign({\n      drag: drag,\n      dragDirectionLock: dragDirectionLock,\n      dragPropagation: dragPropagation,\n      dragConstraints: dragConstraints,\n      dragElastic: dragElastic,\n      dragMomentum: dragMomentum\n    }, remainingProps);\n  };\n\n  VisualElementDragControls.prototype.animateDragEnd = function (velocity) {\n    var _this = this;\n\n    var _a = this.props,\n        drag = _a.drag,\n        dragMomentum = _a.dragMomentum,\n        dragElastic = _a.dragElastic,\n        dragTransition = _a.dragTransition;\n    var momentumAnimations = eachAxis(function (axis) {\n      if (!shouldDrag(axis, drag, _this.currentDirection)) {\n        return;\n      }\n\n      var transition = _this.constraints ? _this.constraints[axis] : {};\n      /**\r\n       * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\r\n       * of spring animations so we should look into adding a disable spring option to `inertia`.\r\n       * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\r\n       * using the value of `dragElastic`.\r\n       */\n\n      var bounceStiffness = dragElastic ? 200 : 1000000;\n      var bounceDamping = dragElastic ? 40 : 10000000;\n\n      var inertia = __assign(__assign({\n        type: \"inertia\",\n        velocity: dragMomentum ? velocity[axis] : 0,\n        bounceStiffness: bounceStiffness,\n        bounceDamping: bounceDamping,\n        timeConstant: 750,\n        restDelta: 1,\n        restSpeed: 10\n      }, dragTransition), transition); // If we're not animating on an externally-provided `MotionValue` we can use the\n      // component's animation controls which will handle interactions with whileHover (etc),\n      // otherwise we just have to animate the `MotionValue` itself.\n\n\n      return _this.visualElement.startLayoutAxisAnimation(axis, inertia);\n    }); // Run all animations and then resolve the new drag constraints.\n\n    return Promise.all(momentumAnimations).then(function () {\n      var _a, _b;\n\n      (_b = (_a = _this.props).onDragTransitionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);\n    });\n  };\n\n  VisualElementDragControls.prototype.stopMotion = function () {\n    this.visualElement.stopLayoutAnimation();\n  };\n\n  VisualElementDragControls.prototype.scalePoint = function () {\n    var _this = this;\n\n    var _a = this.props,\n        drag = _a.drag,\n        dragConstraints = _a.dragConstraints;\n    if (!isRefObject(dragConstraints) || !this.constraintsBox) return; // Stop any current animations as there can be some visual glitching if we resize mid animation\n\n    this.stopMotion(); // Record the relative progress of the targetBox relative to the constraintsBox\n\n    var boxProgress = {\n      x: 0,\n      y: 0\n    };\n    eachAxis(function (axis) {\n      boxProgress[axis] = calcOrigin(_this.visualElement.targetBox[axis], _this.constraintsBox[axis]);\n    });\n    /**\r\n     * For each axis, calculate the current progress of the layout axis within the constraints.\r\n     * Then, using the latest layout and constraints measurements, reposition the new layout axis\r\n     * proportionally within the constraints.\r\n     */\n\n    this.prepareBoundingBox();\n    this.resolveDragConstraints();\n    eachAxis(function (axis) {\n      if (!shouldDrag(axis, drag, null)) return; // Calculate the position of the targetBox relative to the constraintsBox using the\n      // previously calculated progress\n\n      var _a = calcPositionFromProgress(_this.visualElement.targetBox[axis], _this.constraintsBox[axis], boxProgress[axis]),\n          min = _a.min,\n          max = _a.max;\n\n      _this.visualElement.setAxisTarget(axis, min, max);\n    });\n  };\n\n  VisualElementDragControls.prototype.mount = function (visualElement) {\n    var _this = this;\n\n    var element = visualElement.getInstance();\n    /**\r\n     * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\r\n     */\n\n    var stopPointerListener = addPointerEvent(element, \"pointerdown\", function (event) {\n      var _a = _this.props,\n          drag = _a.drag,\n          _b = _a.dragListener,\n          dragListener = _b === void 0 ? true : _b;\n      drag && dragListener && _this.start(event);\n    });\n    /**\r\n     * Attach a window resize listener to scale the draggable target within its defined\r\n     * constraints as the window resizes.\r\n     */\n\n    var stopResizeListener = addDomEvent(window, \"resize\", function () {\n      _this.scalePoint();\n    });\n    /**\r\n     * Ensure drag constraints are resolved correctly relative to the dragging element\r\n     * whenever its layout changes.\r\n     */\n\n    var stopLayoutUpdateListener = visualElement.onLayoutUpdate(function () {\n      if (_this.isDragging) _this.resolveDragConstraints();\n    });\n    /**\r\n     * If the previous component with this same layoutId was dragging at the time\r\n     * it was unmounted, we want to continue the same gesture on this component.\r\n     */\n\n    var prevSnapshot = visualElement.prevSnapshot;\n    (prevSnapshot === null || prevSnapshot === void 0 ? void 0 : prevSnapshot.isDragging) && this.start(lastPointerEvent, {\n      cursorProgress: prevSnapshot.cursorProgress\n    });\n    /**\r\n     * Return a function that will teardown the drag gesture\r\n     */\n\n    return function () {\n      stopPointerListener === null || stopPointerListener === void 0 ? void 0 : stopPointerListener();\n      stopResizeListener === null || stopResizeListener === void 0 ? void 0 : stopResizeListener();\n      stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();\n\n      _this.cancelDrag();\n    };\n  };\n\n  return VisualElementDragControls;\n}();\n\nfunction shouldDrag(direction, drag, currentDirection) {\n  return (drag === true || drag === direction) && (currentDirection === null || currentDirection === direction);\n}\n/**\r\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\r\n * than the provided threshold, return `null`.\r\n *\r\n * @param offset - The x/y offset from origin.\r\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\r\n */\n\n\nfunction getCurrentDirection(offset, lockThreshold) {\n  if (lockThreshold === void 0) {\n    lockThreshold = 10;\n  }\n\n  var direction = null;\n\n  if (Math.abs(offset.y) > lockThreshold) {\n    direction = \"y\";\n  } else if (Math.abs(offset.x) > lockThreshold) {\n    direction = \"x\";\n  }\n\n  return direction;\n}\n/**\r\n * A hook that allows an element to be dragged.\r\n *\r\n * @internal\r\n */\n\n\nfunction useDrag(props, visualElement) {\n  var groupDragControls = props.dragControls;\n  var transformPagePoint = useContext(MotionPluginContext).transformPagePoint;\n  var dragControls = useConstant(function () {\n    return new VisualElementDragControls({\n      visualElement: visualElement\n    });\n  });\n  dragControls.updateProps(__assign(__assign({}, props), {\n    transformPagePoint: transformPagePoint\n  })); // If we've been provided a DragControls for manual control over the drag gesture,\n  // subscribe this component to it on mount.\n\n  useEffect(function () {\n    return groupDragControls && groupDragControls.subscribe(dragControls);\n  }, [dragControls]); // Mount the drag controls with the visualElement\n\n  useEffect(function () {\n    return dragControls.mount(visualElement);\n  }, []);\n}\n\nvar makeRenderlessComponent = function (hook) {\n  return function (props) {\n    hook(props);\n    return null;\n  };\n};\n\nvar Drag = {\n  key: \"drag\",\n  shouldRender: function (props) {\n    return !!props.drag;\n  },\n  Component: makeRenderlessComponent(function (_a) {\n    var visualElement = _a.visualElement,\n        props = __rest(_a, [\"visualElement\"]);\n\n    return useDrag(props, visualElement);\n  })\n};\n\nfunction useUnmountEffect(callback) {\n  return useEffect(function () {\n    return function () {\n      return callback();\n    };\n  }, []);\n}\n/**\r\n *\r\n * @param handlers -\r\n * @param ref -\r\n *\r\n * @internalremarks\r\n * Currently this sets new pan gesture functions every render. The memo route has been explored\r\n * in the past but ultimately we're still creating new functions every render. An optimisation\r\n * to explore is creating the pan gestures and loading them into a `ref`.\r\n *\r\n * @internal\r\n */\n\n\nfunction usePanGesture(_a, ref) {\n  var onPan = _a.onPan,\n      onPanStart = _a.onPanStart,\n      onPanEnd = _a.onPanEnd,\n      onPanSessionStart = _a.onPanSessionStart;\n  var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\n  var panSession = useRef(null);\n  var transformPagePoint = useContext(MotionPluginContext).transformPagePoint;\n  var handlers = {\n    onSessionStart: onPanSessionStart,\n    onStart: onPanStart,\n    onMove: onPan,\n    onEnd: function (event, info) {\n      panSession.current = null;\n      onPanEnd && onPanEnd(event, info);\n    }\n  };\n  useEffect(function () {\n    if (panSession.current !== null) {\n      panSession.current.updateHandlers(handlers);\n    }\n  });\n\n  function onPointerDown(event) {\n    panSession.current = new PanSession(event, handlers, {\n      transformPagePoint: transformPagePoint\n    });\n  }\n\n  usePointerEvent(ref, \"pointerdown\", hasPanEvents && onPointerDown);\n  useUnmountEffect(function () {\n    return panSession.current && panSession.current.end();\n  });\n}\n/**\r\n * Recursively traverse up the tree to check whether the provided child node\r\n * is the parent or a descendant of it.\r\n *\r\n * @param parent - Element to find\r\n * @param child - Element to test against parent\r\n */\n\n\nvar isNodeOrChild = function (parent, child) {\n  if (!child) {\n    return false;\n  } else if (parent === child) {\n    return true;\n  } else {\n    return isNodeOrChild(parent, child.parentElement);\n  }\n};\n\nvar order$1 = [\"whileHover\", \"whileTap\", \"whileDrag\"];\n\nvar getGesturePriority = function (gesture) {\n  return order$1.indexOf(gesture) + 1;\n};\n\nvar tapGesturePriority = getGesturePriority(\"whileTap\");\n/**\r\n * @param handlers -\r\n * @internal\r\n */\n\nfunction useTapGesture(_a, ref) {\n  var onTap = _a.onTap,\n      onTapStart = _a.onTapStart,\n      onTapCancel = _a.onTapCancel,\n      whileTap = _a.whileTap,\n      controls = _a.controls;\n  var hasTapListeners = onTap || onTapStart || onTapCancel || whileTap;\n  var isTapping = useRef(false);\n  var cancelPointerEventListener = useRef(null);\n\n  function removePointerUp() {\n    cancelPointerEventListener.current && cancelPointerEventListener.current();\n    cancelPointerEventListener.current = null;\n  }\n\n  if (whileTap && controls) {\n    controls.setOverride(whileTap, tapGesturePriority);\n  } // We load this event handler into a ref so we can later refer to\n  // onPointerUp.current which will always have reference to the latest props\n\n\n  var onPointerUp = useRef(null);\n\n  onPointerUp.current = function (event, info) {\n    var element = ref.current;\n    removePointerUp();\n    if (!isTapping.current || !element) return;\n    isTapping.current = false;\n\n    if (controls && whileTap) {\n      controls.clearOverride(tapGesturePriority);\n    } // Check the gesture lock - if we get it, it means no drag gesture is active\n    // and we can safely fire the tap gesture.\n\n\n    var openGestureLock = getGlobalLock(true);\n    if (!openGestureLock) return;\n    openGestureLock();\n\n    if (!isNodeOrChild(element, event.target)) {\n      onTapCancel && onTapCancel(event, info);\n    } else {\n      onTap && onTap(event, info);\n    }\n  };\n\n  function onPointerDown(event, info) {\n    removePointerUp();\n    cancelPointerEventListener.current = addPointerEvent(window, \"pointerup\", function (event, info) {\n      return onPointerUp.current(event, info);\n    });\n    var element = ref.current;\n    if (!element || isTapping.current) return;\n    isTapping.current = true;\n    onTapStart && onTapStart(event, info);\n\n    if (controls && whileTap) {\n      controls.startOverride(tapGesturePriority);\n    }\n  }\n\n  usePointerEvent(ref, \"pointerdown\", hasTapListeners ? onPointerDown : undefined);\n  useUnmountEffect(removePointerUp);\n}\n\nvar hoverPriority = getGesturePriority(\"whileHover\");\n\nvar filterTouch = function (listener) {\n  return function (event, info) {\n    if (isMouseEvent(event)) listener(event, info);\n  };\n};\n/**\r\n *\r\n * @param props\r\n * @param ref\r\n * @internal\r\n */\n\n\nfunction useHoverGesture(_a, ref) {\n  var whileHover = _a.whileHover,\n      onHoverStart = _a.onHoverStart,\n      onHoverEnd = _a.onHoverEnd,\n      controls = _a.controls;\n\n  if (whileHover && controls) {\n    controls.setOverride(whileHover, hoverPriority);\n  }\n\n  usePointerEvent(ref, \"pointerenter\", filterTouch(function (event, info) {\n    if (onHoverStart) onHoverStart(event, info);\n\n    if (whileHover && controls) {\n      controls.startOverride(hoverPriority);\n    }\n  }));\n  usePointerEvent(ref, \"pointerleave\", filterTouch(function (event, info) {\n    if (onHoverEnd) onHoverEnd(event, info);\n\n    if (whileHover && controls) {\n      controls.clearOverride(hoverPriority);\n    }\n  }));\n}\n/**\r\n * Add pan and tap gesture recognition to an element.\r\n *\r\n * @param props - Gesture event handlers\r\n * @param ref - React `ref` containing a DOM `Element`\r\n * @public\r\n */\n\n\nfunction useGestures(props, ref) {\n  usePanGesture(props, ref);\n  useTapGesture(props, ref);\n  useHoverGesture(props, ref);\n}\n\nvar gestureProps = [\"onPan\", \"onPanStart\", \"onPanEnd\", \"onPanSessionStart\", \"onTap\", \"onTapStart\", \"onTapCancel\", \"whileTap\", \"whileHover\", \"onHoverStart\", \"onHoverEnd\"];\nvar Gestures = {\n  key: \"gestures\",\n  shouldRender: function (props) {\n    return gestureProps.some(function (key) {\n      return props.hasOwnProperty(key);\n    });\n  },\n  Component: makeRenderlessComponent(function (_a) {\n    var visualElement = _a.visualElement,\n        props = __rest(_a, [\"visualElement\"]);\n\n    useGestures(props, visualElement);\n  })\n};\nvar Exit = {\n  key: \"exit\",\n  shouldRender: function (props) {\n    return !!props.exit && !checkShouldInheritVariant(props);\n  },\n  Component: makeRenderlessComponent(function (props) {\n    var animate = props.animate,\n        controls = props.controls,\n        exit = props.exit;\n\n    var _a = usePresence(),\n        isPresent = _a[0],\n        onExitComplete = _a[1];\n\n    var presenceContext = useContext(PresenceContext);\n    var isPlayingExitAnimation = useRef(false);\n    var custom = (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== undefined ? presenceContext.custom : props.custom;\n    useEffect(function () {\n      if (!isPresent) {\n        if (!isPlayingExitAnimation.current && exit) {\n          controls.setProps(__assign(__assign({}, props), {\n            custom: custom\n          }));\n          controls.start(exit).then(onExitComplete);\n        }\n\n        isPlayingExitAnimation.current = true;\n      } else if (isPlayingExitAnimation.current && animate && typeof animate !== \"boolean\" && !(animate instanceof AnimationControls)) {\n        controls.start(animate);\n      }\n\n      if (isPresent) {\n        isPlayingExitAnimation.current = false;\n      }\n    }, [animate, controls, custom, exit, isPresent, onExitComplete, props]);\n  })\n};\nvar AnimatePropType;\n\n(function (AnimatePropType) {\n  AnimatePropType[\"Target\"] = \"Target\";\n  AnimatePropType[\"VariantLabel\"] = \"VariantLabel\";\n  AnimatePropType[\"AnimationSubscription\"] = \"AnimationSubscription\";\n})(AnimatePropType || (AnimatePropType = {}));\n\nfunction shallowCompare(next, prev) {\n  if (prev === null) return false;\n  var prevLength = prev.length;\n  if (prevLength !== next.length) return false;\n\n  for (var i = 0; i < prevLength; i++) {\n    if (prev[i] !== next[i]) return false;\n  }\n\n  return true;\n}\n\nvar hasUpdated = function (prev, next) {\n  return next !== undefined && (Array.isArray(prev) && Array.isArray(next) ? !shallowCompare(next, prev) : prev !== next);\n};\n\nfunction targetWithoutTransition(_a, mergeTransitionEnd) {\n  if (mergeTransitionEnd === void 0) {\n    mergeTransitionEnd = false;\n  }\n\n  var transition = _a.transition,\n      transitionEnd = _a.transitionEnd,\n      target = __rest(_a, [\"transition\", \"transitionEnd\"]);\n\n  return mergeTransitionEnd ? __assign(__assign({}, target), transitionEnd) : target;\n}\n/**\r\n * Handle the `animate` prop when its an object of values, ie:\r\n *\r\n * ```jsx\r\n * <motion.div animate={{ opacity: 1 }} />\r\n * ```\r\n *\r\n * @internalremarks\r\n * It might be worth consolidating this with `use-variants`\r\n *\r\n * ```jsx\r\n * <motion.div animate=\"visible\" />\r\n * ```\r\n *\r\n * @param target\r\n * @param controls\r\n * @param values\r\n * @param transition\r\n *\r\n * @internal\r\n */\n\n\nfunction useAnimateProp(targetAndTransition, controls, visualElement, defaultTransition) {\n  var isInitialRender = useRef(true);\n  var prevValues = useRef(null);\n\n  if (!prevValues.current) {\n    prevValues.current = targetWithoutTransition(targetAndTransition, true);\n  }\n\n  useEffect(function () {\n    var targetToAnimate = {}; // These are the values we're actually animating\n\n    var animatingTarget = targetWithoutTransition(targetAndTransition); // This is the target as it'll be once transitionEnd values are applied\n\n    var finalTarget = targetWithoutTransition(targetAndTransition, true); // Detect which values have changed between renders\n\n    for (var key in animatingTarget) {\n      // This value should animate on mount if this value doesn't already exist (wasn't\n      // defined in `style` or `initial`) or if it does exist and it's already changed.\n      var shouldAnimateOnMount = isInitialRender.current && (!visualElement.hasValue(key) || visualElement.getValue(key).get() !== finalTarget[key]); // If this value has updated between renders or it's we're animating this value on mount,\n      // add it to the animate target.\n\n      var isValidValue = finalTarget[key] !== null;\n      var valueHasUpdated = hasUpdated(prevValues.current[key], finalTarget[key]);\n\n      if (isValidValue && (valueHasUpdated || shouldAnimateOnMount)) {\n        targetToAnimate[key] = animatingTarget[key];\n      }\n    }\n\n    isInitialRender.current = false;\n    prevValues.current = __assign(__assign({}, prevValues.current), finalTarget);\n\n    if (Object.keys(targetToAnimate).length) {\n      controls.start(__assign(__assign({}, targetToAnimate), {\n        transition: targetAndTransition.transition || defaultTransition,\n        transitionEnd: targetAndTransition.transitionEnd\n      }));\n    }\n  }, [targetAndTransition]);\n}\n\nvar labelsToArray = function (label) {\n  if (!label) {\n    return [];\n  }\n\n  if (Array.isArray(label)) {\n    return label;\n  }\n\n  return [label];\n};\n\nvar resolveVariantLabels = function (variant) {\n  var unresolvedVariant = variant instanceof MotionValue ? variant.get() : variant;\n  return Array.from(new Set(labelsToArray(unresolvedVariant)));\n};\n/**\r\n * Hooks in React sometimes accept a dependency array as their final argument. (ie useEffect/useMemo)\r\n * When values in this array change, React re-runs the dependency. However if the array\r\n * contains a variable number of items, React throws an error.\r\n */\n\n\nvar asDependencyList = function (list) {\n  return [list.join(\",\")];\n};\n\nvar hasVariantChanged = function (oldVariant, newVariant) {\n  return oldVariant.join(\",\") !== newVariant.join(\",\");\n};\n/**\r\n * Handle variants and the `animate` prop when its set as variant labels.\r\n *\r\n * @param initial - Initial variant(s)\r\n * @param animate - Variant(s) to animate to\r\n * @param inherit - `true` is inheriting animations from parent\r\n * @param controls - Animation controls\r\n *\r\n * @internal\r\n */\n\n\nfunction useVariants(initial, animate, inherit, controls) {\n  var targetVariants = resolveVariantLabels(animate);\n  var context = useContext(MotionContext);\n  var parentAlreadyMounted = context.hasMounted && context.hasMounted.current;\n  var hasMounted = useRef(false);\n  useEffect(function () {\n    var shouldAnimate = false;\n\n    if (inherit) {\n      // If we're inheriting variant changes and the parent has already\n      // mounted when this component loads, we need to manually trigger\n      // this animation.\n      shouldAnimate = !!parentAlreadyMounted;\n      targetVariants = resolveVariantLabels(context.animate);\n    } else {\n      shouldAnimate = hasMounted.current || hasVariantChanged(resolveVariantLabels(initial), targetVariants);\n    }\n\n    shouldAnimate && controls.start(targetVariants);\n    hasMounted.current = true;\n  }, asDependencyList(targetVariants));\n}\n/**\r\n * `useAnimationGroupSubscription` allows a component to subscribe to an\r\n * externally-created `AnimationControls`, created by the `useAnimation` hook.\r\n *\r\n * @param animation\r\n * @param controls\r\n *\r\n * @internal\r\n */\n\n\nfunction useAnimationGroupSubscription(animation, controls) {\n  var unsubscribe = useMemo(function () {\n    return animation.subscribe(controls);\n  }, [animation]);\n  useEffect(function () {\n    return function () {\n      unsubscribe && unsubscribe();\n    };\n  }, [unsubscribe]);\n}\n\nvar _a, _b;\n\nvar AnimatePropComponents = (_a = {}, _a[AnimatePropType.Target] = makeRenderlessComponent(function (_a) {\n  var animate = _a.animate,\n      controls = _a.controls,\n      visualElement = _a.visualElement,\n      transition = _a.transition;\n  return useAnimateProp(animate, controls, visualElement, transition);\n}), _a[AnimatePropType.VariantLabel] = makeRenderlessComponent(function (_a) {\n  var animate = _a.animate,\n      _b = _a.inherit,\n      inherit = _b === void 0 ? true : _b,\n      controls = _a.controls,\n      initial = _a.initial;\n  return useVariants(initial, animate, inherit, controls);\n}), _a[AnimatePropType.AnimationSubscription] = makeRenderlessComponent(function (_a) {\n  var animate = _a.animate,\n      controls = _a.controls;\n  return useAnimationGroupSubscription(animate, controls);\n}), _a);\n\nvar isVariantLabel$1 = function (prop) {\n  return Array.isArray(prop) || typeof prop === \"string\";\n};\n\nvar isAnimationSubscription = function (_a) {\n  var animate = _a.animate;\n  return animate instanceof AnimationControls;\n};\n\nvar animationProps = [\"initial\", \"animate\", \"whileTap\", \"whileHover\"];\nvar animatePropTypeTests = (_b = {}, _b[AnimatePropType.Target] = function (props) {\n  return props.animate !== undefined && !isVariantLabel$1(props.animate) && !isAnimationSubscription(props);\n}, _b[AnimatePropType.VariantLabel] = function (props) {\n  return props.variants !== undefined || animationProps.some(function (key) {\n    return typeof props[key] === \"string\";\n  });\n}, _b[AnimatePropType.AnimationSubscription] = isAnimationSubscription, _b);\n\nvar getAnimationComponent = function (props) {\n  var animatePropType = undefined;\n\n  for (var key in AnimatePropType) {\n    if (animatePropTypeTests[key](props)) {\n      animatePropType = key;\n    }\n  }\n\n  return animatePropType ? AnimatePropComponents[animatePropType] : undefined;\n};\n\nfunction tweenAxis(target, prev, next, p) {\n  target.min = mix(prev.min, next.min, p);\n  target.max = mix(prev.max, next.max, p);\n}\n\nvar Presence;\n\n(function (Presence) {\n  Presence[Presence[\"Entering\"] = 0] = \"Entering\";\n  Presence[Presence[\"Present\"] = 1] = \"Present\";\n  Presence[Presence[\"Exiting\"] = 2] = \"Exiting\";\n})(Presence || (Presence = {}));\n\nvar VisibilityAction;\n\n(function (VisibilityAction) {\n  VisibilityAction[VisibilityAction[\"Hide\"] = 0] = \"Hide\";\n  VisibilityAction[VisibilityAction[\"Show\"] = 1] = \"Show\";\n})(VisibilityAction || (VisibilityAction = {}));\n\nvar progressTarget = 1000;\n\nvar Animate =\n/** @class */\nfunction (_super) {\n  __extends(Animate, _super);\n\n  function Animate() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.frameTarget = {\n      x: {\n        min: 0,\n        max: 0\n      },\n      y: {\n        min: 0,\n        max: 0\n      }\n    };\n    _this.stopAxisAnimation = {\n      x: undefined,\n      y: undefined\n    };\n\n    _this.animate = function (target, origin, _a) {\n      if (_a === void 0) {\n        _a = {};\n      }\n\n      var originBox = _a.originBox,\n          targetBox = _a.targetBox,\n          visibilityAction = _a.visibilityAction,\n          config = __rest(_a, [\"originBox\", \"targetBox\", \"visibilityAction\"]);\n\n      var _b = _this.props,\n          visualElement = _b.visualElement,\n          layout = _b.layout;\n      /**\r\n       * Allow the measured origin (prev bounding box) and target (actual layout) to be\r\n       * overridden by the provided config.\r\n       */\n\n      origin = originBox || origin;\n      target = targetBox || target;\n      var boxHasMoved = hasMoved(origin, target);\n      var animations = eachAxis(function (axis) {\n        /**\r\n         * If layout is set to \"position\", we can resize the origin box based on the target\r\n         * box and only animate its position.\r\n         */\n        if (layout === \"position\") {\n          var targetLength = target[axis].max - target[axis].min;\n          origin[axis].max = origin[axis].min + targetLength;\n        }\n\n        if (visualElement.isTargetBoxLocked) {\n          return;\n        } else if (visibilityAction !== undefined) {\n          // If we're meant to show/hide the visualElement, do so\n          visibilityAction === VisibilityAction.Hide ? visualElement.hide() : visualElement.show();\n        } else if (boxHasMoved) {\n          // If the box has moved, animate between it's current visual state and its\n          // final state\n          return _this.animateAxis(axis, target[axis], origin[axis], config);\n        } else {\n          // If the box has remained in the same place, immediately set the axis target\n          // to the final desired state\n          return visualElement.setAxisTarget(axis, target[axis].min, target[axis].max);\n        }\n      }); // Force a render to ensure there's no flash of uncorrected bounding box.\n\n      visualElement.render();\n      /**\r\n       * If this visualElement isn't present (ie it's been removed from the tree by the user but\r\n       * kept in by the tree by AnimatePresence) then call safeToRemove when all axis animations\r\n       * have successfully finished.\r\n       */\n\n      return Promise.all(animations).then(function () {\n        var _a, _b;\n\n        (_a = config.onLayoutAnimationComplete) === null || _a === void 0 ? void 0 : _a.call(config);\n\n        if (visualElement.isPresent) {\n          visualElement.presence = Presence.Present;\n        } else {\n          (_b = config.onLayoutAnimationComplete) === null || _b === void 0 ? void 0 : _b.call(config);\n\n          _this.safeToRemove();\n        }\n      });\n    };\n\n    return _this;\n  }\n\n  Animate.prototype.componentDidMount = function () {\n    var visualElement = this.props.visualElement;\n    visualElement.enableLayoutProjection();\n    this.unsubLayoutReady = visualElement.onLayoutUpdate(this.animate);\n  };\n\n  Animate.prototype.componentWillUnmount = function () {\n    var _this = this;\n\n    this.unsubLayoutReady();\n    eachAxis(function (axis) {\n      var _a, _b;\n\n      return (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a);\n    });\n  };\n  /**\r\n   * TODO: This manually performs animations on the visualElement's layout progress\r\n   * values. It'd be preferable to amend the HTMLVisualElement.startLayoutAxisAnimation\r\n   * API to accept more custom animations like this.\r\n   */\n\n\n  Animate.prototype.animateAxis = function (axis, target, origin, _a) {\n    var _b, _c;\n\n    var _d = _a === void 0 ? {} : _a,\n        transition = _d.transition,\n        crossfadeOpacity = _d.crossfadeOpacity;\n\n    (_c = (_b = this.stopAxisAnimation)[axis]) === null || _c === void 0 ? void 0 : _c.call(_b);\n    var visualElement = this.props.visualElement;\n    var frameTarget = this.frameTarget[axis];\n    var layoutProgress = visualElement.axisProgress[axis];\n    /**\r\n     * Set layout progress back to 0. We set it twice to hard-reset any velocity that might\r\n     * be re-incoporated into a subsequent spring animation.\r\n     */\n\n    layoutProgress.clearListeners();\n    layoutProgress.set(0);\n    layoutProgress.set(0);\n    /**\r\n     * If this is a crossfade animation, create a function that updates both the opacity of this component\r\n     * and the one being crossfaded out.\r\n     */\n\n    var crossfade = crossfadeOpacity && this.createCrossfadeAnimation(crossfadeOpacity);\n    /**\r\n     * Create an animation function to run once per frame. This will tween the visual bounding box from\r\n     * origin to target using the latest progress value.\r\n     */\n\n    var frame = function () {\n      // Convert the latest layoutProgress, which is a value from 0-1000, into a 0-1 progress\n      var p = layoutProgress.get() / progressTarget; // Tween the axis and update the visualElement with the latest values\n\n      tweenAxis(frameTarget, origin, target, p);\n      visualElement.setAxisTarget(axis, frameTarget.min, frameTarget.max); // If this is a crossfade animation, update both elements.\n\n      crossfade === null || crossfade === void 0 ? void 0 : crossfade(p);\n    }; // Synchronously run a frame to ensure there's no flash of the uncorrected bounding box.\n\n\n    frame(); // Start the animation on this axis\n\n    var animation = startAnimation(axis === \"x\" ? \"layoutX\" : \"layoutY\", layoutProgress, progressTarget, transition || this.props.transition || defaultTransition); // Create a function to stop animation on this specific axis\n\n    var unsubscribeProgress = layoutProgress.onChange(frame);\n\n    this.stopAxisAnimation[axis] = function () {\n      layoutProgress.stop();\n      unsubscribeProgress();\n    };\n\n    return animation;\n  };\n\n  Animate.prototype.createCrossfadeAnimation = function (crossfadeOpacity) {\n    var visualElement = this.props.visualElement;\n    var opacity = visualElement.getValue(\"opacity\", 0);\n    return function (p) {\n      opacity.set(easeCrossfadeIn(mix(0, 1, p)));\n      crossfadeOpacity.set(easeCrossfadeOut(mix(1, 0, p)));\n    };\n  };\n\n  Animate.prototype.safeToRemove = function () {\n    var _a, _b;\n\n    (_b = (_a = this.props).safeToRemove) === null || _b === void 0 ? void 0 : _b.call(_a);\n  };\n\n  Animate.prototype.render = function () {\n    return null;\n  };\n\n  return Animate;\n}(Component);\n\nvar AnimateLayout = {\n  key: \"animate-layout\",\n  shouldRender: function (props) {\n    return !!props.layout || !!props.layoutId;\n  },\n  Component: function (props) {\n    var _a = usePresence(),\n        safeToRemove = _a[1];\n\n    return createElement(Animate, __assign({}, props, {\n      safeToRemove: safeToRemove\n    }));\n  }\n};\n\nfunction hasMoved(a, b) {\n  return hasAxisMoved(a.x, b.x) || hasAxisMoved(a.y, b.y);\n}\n\nfunction hasAxisMoved(a, b) {\n  return a.min !== b.min || a.max !== b.max;\n}\n\nvar defaultTransition = {\n  duration: 0.45,\n  ease: [0.4, 0, 0.1, 1]\n};\n\nfunction compress(min, max, easing) {\n  return function (p) {\n    // Could replace ifs with clamp\n    if (p < min) return 0;\n    if (p > max) return 1;\n    return easing(progress(min, max, p));\n  };\n}\n\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, linear$1);\n/**\r\n * Default handlers for batching VisualElements\r\n */\n\nvar defaultHandler = {\n  measureLayout: function (child) {\n    return child.measureLayout();\n  },\n  layoutReady: function (child) {\n    return child.layoutReady();\n  }\n};\n/**\r\n * Sort VisualElements by tree depth, so we process the highest elements first.\r\n */\n\nvar sortByDepth = function (a, b) {\n  return a.depth - b.depth;\n};\n/**\r\n * Create a batcher to process VisualElements\r\n */\n\n\nfunction createBatcher() {\n  var queue = new Set();\n\n  var add = function (child) {\n    return queue.add(child);\n  };\n\n  var flush = function (_a) {\n    var _b = _a === void 0 ? defaultHandler : _a,\n        measureLayout = _b.measureLayout,\n        layoutReady = _b.layoutReady;\n\n    var order = Array.from(queue).sort(sortByDepth);\n    /**\r\n     * Write: Reset any transforms on children elements so we can read their actual layout\r\n     */\n\n    order.forEach(function (child) {\n      return child.resetTransform();\n    });\n    /**\r\n     * Read: Measure the actual layout\r\n     */\n\n    order.forEach(measureLayout);\n    /**\r\n     * Write: Notify the VisualElements they're ready for further write operations.\r\n     */\n\n    order.forEach(layoutReady);\n    /**\r\n     * After all children have started animating, ensure any Entering components are set to Present.\r\n     * If we add deferred animations (set up all animations and then start them in two loops) this\r\n     * could be moved to the start loop. But it needs to happen after all the animations configs\r\n     * are generated in AnimateSharedLayout as this relies on presence data\r\n     */\n\n    order.forEach(function (child) {\n      if (child.isPresent) child.presence = Presence.Present;\n    });\n    queue.clear();\n  };\n\n  return {\n    add: add,\n    flush: flush\n  };\n}\n\nfunction isSharedLayout(context) {\n  return !!context.forceUpdate;\n}\n\nvar SharedLayoutContext = createContext(createBatcher());\n/**\r\n * This component is responsible for scheduling the measuring of the motion component\r\n */\n\nvar Measure =\n/** @class */\nfunction (_super) {\n  __extends(Measure, _super);\n\n  function Measure(props) {\n    var _this = _super.call(this, props) || this;\n    /**\r\n     * If this component isn't the child of a SyncContext, make it responsible for flushing\r\n     * the layout batcher\r\n     */\n\n\n    var syncLayout = props.syncLayout;\n\n    if (!isSharedLayout(syncLayout)) {\n      _this.componentDidUpdate = function () {\n        return syncLayout.flush();\n      };\n    }\n\n    return _this;\n  }\n  /**\r\n   * If this is a child of a SyncContext, register the VisualElement with it on mount.\r\n   */\n\n\n  Measure.prototype.componentDidMount = function () {\n    var _a = this.props,\n        syncLayout = _a.syncLayout,\n        visualElement = _a.visualElement;\n    isSharedLayout(syncLayout) && syncLayout.register(visualElement);\n  };\n  /**\r\n   * If this is a child of a SyncContext, notify it that it needs to re-render. It will then\r\n   * handle the snapshotting.\r\n   *\r\n   * If it is stand-alone component, add it to the batcher.\r\n   */\n\n\n  Measure.prototype.getSnapshotBeforeUpdate = function () {\n    var _a = this.props,\n        syncLayout = _a.syncLayout,\n        visualElement = _a.visualElement;\n\n    if (isSharedLayout(syncLayout)) {\n      syncLayout.syncUpdate();\n    } else {\n      visualElement.snapshotBoundingBox();\n      syncLayout.add(visualElement);\n    }\n\n    return null;\n  };\n\n  Measure.prototype.componentDidUpdate = function () {};\n\n  Measure.prototype.render = function () {\n    return null;\n  };\n\n  return Measure;\n}(React__default.Component);\n\nvar MeasureLayout = {\n  key: \"measure-layout\",\n  shouldRender: function (props) {\n    return !!props.drag || !!props.layout || !!props.layoutId;\n  },\n  Component: function (props) {\n    var syncLayout = useContext(SharedLayoutContext);\n    return React__default.createElement(Measure, __assign({}, props, {\n      syncLayout: syncLayout\n    }));\n  }\n};\n/**\r\n * Currently we load all features synchronously, but it would be better to offer multiple entry points\r\n * that allow these to be loaded in asynchronously.\r\n */\n\nvar defaultFeatures = [MeasureLayout, Drag, Gestures, Exit, AnimateLayout];\n/**\r\n * Load features via renderless components based on the provided MotionProps\r\n */\n\nfunction useFeatures(isStatic, visualElement, controls, props, context, parentContext, shouldInheritVariant) {\n  var plugins = useContext(MotionPluginContext); // If this is a static component, or we're rendering on the server, we don't load\n  // any feature components\n\n  if (isStatic || typeof window === \"undefined\") return null;\n\n  var allFeatures = __spreadArrays(defaultFeatures, plugins.features);\n\n  var numFeatures = allFeatures.length;\n  var features = []; // TODO: Consolidate Animation feature loading strategy with other functionality components\n\n  var Animation = getAnimationComponent(props);\n\n  if (Animation) {\n    features.push(createElement(Animation, {\n      key: \"animation\",\n      initial: props.initial,\n      animate: props.animate,\n      variants: props.variants,\n      transition: props.transition,\n      controls: controls,\n      inherit: shouldInheritVariant,\n      visualElement: visualElement\n    }));\n  } // Decide which features we should render and add them to the returned array\n\n\n  for (var i = 0; i < numFeatures; i++) {\n    var _a = allFeatures[i],\n        shouldRender = _a.shouldRender,\n        key = _a.key,\n        Component = _a.Component;\n\n    if (shouldRender(props, parentContext)) {\n      features.push(createElement(Component, __assign({\n        key: key\n      }, props, {\n        localContext: context,\n        parentContext: parentContext,\n        visualElement: visualElement,\n        controls: controls\n      })));\n    }\n  }\n\n  return features;\n}\n\nfunction useSnapshotOnUnmount(visualElement) {\n  var syncLayout = useContext(SharedLayoutContext);\n  useUnmountEffect(function () {\n    if (isSharedLayout(syncLayout)) syncLayout.remove(visualElement);\n  });\n}\n/**\r\n * Create a `motion` component.\r\n *\r\n * This function accepts a Component argument, which can be either a string (ie \"div\"\r\n * for `motion.div`), or an actual React component.\r\n *\r\n * Alongside this is a config option which provides a way of rendering the provided\r\n * component \"offline\", or outside the React render cycle.\r\n *\r\n * @internal\r\n */\n\n\nfunction createMotionComponent(Component, _a) {\n  var useVisualElement = _a.useVisualElement,\n      render = _a.render,\n      animationControlsConfig = _a.animationControlsConfig;\n\n  function MotionComponent(props, externalRef) {\n    var parentContext = useContext(MotionContext);\n    var shouldInheritVariant = checkShouldInheritVariant(props);\n    /**\r\n     * If a component isStatic, we only visually update it as a\r\n     * result of a React re-render, rather than any interactions or animations.\r\n     * If this component or any ancestor isStatic, we disable hardware acceleration\r\n     * and don't load any additional functionality.\r\n     */\n\n    var isStatic = parentContext.static || props.static || false;\n    /**\r\n     * Create a VisualElement for this component. A VisualElement provides a common\r\n     * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\r\n     * providing a way of rendering to these APIs outside of the React render loop\r\n     * for more performant animations and interactions\r\n     */\n\n    var visualElement = useVisualElement(Component, props, parentContext.visualElement, isStatic, externalRef);\n    /**\r\n     * Scrape MotionValues from props and add/remove them to/from\r\n     * the VisualElement as necessary.\r\n     */\n\n    useMotionValues(visualElement, props);\n    /**\r\n     * Create animation controls for the VisualElement. It might be\r\n     * interesting to try and combine this with VisualElement itself in a further refactor.\r\n     */\n\n    var controls = useVisualElementAnimation(visualElement, props, animationControlsConfig);\n    /**\r\n     * Build the MotionContext to pass on to the next `motion` component.\r\n     */\n\n    var context = useMotionContext(parentContext, controls, visualElement, isStatic, props);\n    /**\r\n     * Load features as renderless components unless the component isStatic\r\n     */\n\n    var features = useFeatures(isStatic, visualElement, controls, props, context, parentContext, shouldInheritVariant);\n    var component = render(Component, props, visualElement);\n    /**\r\n     *\r\n     */\n\n    useSnapshotOnUnmount(visualElement); // The mount order and hierarchy is specific to ensure our element ref is hydrated by the time\n    // all plugins and features has to execute.\n\n    return createElement(Fragment, null, createElement(MotionContext.Provider, {\n      value: context\n    }, component), features);\n  }\n\n  return forwardRef(MotionComponent);\n}\n/**\r\n * DOM-specific config for `motion` components\r\n */\n\n\nvar config = {\n  useVisualElement: useDomVisualElement,\n  render: render,\n  animationControlsConfig: {\n    makeTargetAnimatable: parseDomVariant\n  }\n};\n/**\r\n * Convert any React component into a `motion` component. The provided component\r\n * **must** use `React.forwardRef` to the underlying DOM component you want to animate.\r\n *\r\n * ```jsx\r\n * const Component = React.forwardRef((props, ref) => {\r\n *   return <div ref={ref} />\r\n * })\r\n *\r\n * const MotionComponent = motion.custom(Component)\r\n * ```\r\n *\r\n * @public\r\n */\n\nfunction custom(Component) {\n  return createMotionComponent(Component, config);\n}\n\nvar componentCache = new Map();\n\nfunction get(target, key) {\n  if (key === \"custom\") return target.custom;\n\n  if (!componentCache.has(key)) {\n    componentCache.set(key, createMotionComponent(key, config));\n  }\n\n  return componentCache.get(key);\n}\n/**\r\n * HTML & SVG components, optimised for use with gestures and animation. These can be used as\r\n * drop-in replacements for any HTML & SVG component, all CSS & SVG properties are supported.\r\n *\r\n * @public\r\n */\n\n\nvar motion = new Proxy({\n  custom: custom\n}, {\n  get: get\n});\n\nfunction useForceUpdate() {\n  var _a = useState(0),\n      forcedRenderCount = _a[0],\n      setForcedRenderCount = _a[1];\n\n  return useCallback(function () {\n    return setForcedRenderCount(forcedRenderCount + 1);\n  }, [forcedRenderCount]);\n}\n\nvar presenceId = 0;\n\nfunction getPresenceId() {\n  var id = presenceId;\n  presenceId++;\n  return id;\n}\n\nvar PresenceChild = function (_a) {\n  var children = _a.children,\n      initial = _a.initial,\n      isPresent = _a.isPresent,\n      onExitComplete = _a.onExitComplete,\n      custom = _a.custom;\n  var presenceChildren = useConstant(newChildrenMap);\n  var context = {\n    id: useConstant(getPresenceId),\n    initial: initial,\n    isPresent: isPresent,\n    custom: custom,\n    onExitComplete: function (childId) {\n      presenceChildren.set(childId, true);\n      var allComplete = true;\n      presenceChildren.forEach(function (isComplete) {\n        if (!isComplete) allComplete = false;\n      });\n      allComplete && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n    },\n    register: function (childId) {\n      presenceChildren.set(childId, false);\n      return function () {\n        return presenceChildren.delete(childId);\n      };\n    }\n  };\n  useMemo(function () {\n    presenceChildren.forEach(function (_, key) {\n      return presenceChildren.set(key, false);\n    });\n  }, [isPresent]);\n  return createElement(PresenceContext.Provider, {\n    value: context\n  }, children);\n};\n\nfunction newChildrenMap() {\n  return new Map();\n}\n\nfunction getChildKey(child) {\n  return child.key || \"\";\n}\n\nfunction updateChildLookup(children, allChildren) {\n  var seenChildren = process.env.NODE_ENV !== \"production\" ? new Set() : null;\n  children.forEach(function (child) {\n    var key = getChildKey(child);\n\n    if (process.env.NODE_ENV !== \"production\" && seenChildren) {\n      if (seenChildren.has(key)) {\n        console.warn(\"Children of AnimatePresence require unique keys. \\\"\" + key + \"\\\" is a duplicate.\");\n      }\n\n      seenChildren.add(key);\n    }\n\n    allChildren.set(key, child);\n  });\n}\n\nfunction onlyElements(children) {\n  var filtered = []; // We use forEach here instead of map as map mutates the component key by preprending `.$`\n\n  Children.forEach(children, function (child) {\n    if (isValidElement(child)) filtered.push(child);\n  });\n  return filtered;\n}\n/**\r\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\r\n *\r\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\r\n *\r\n * @library\r\n *\r\n * Any `Frame` components that have an `exit` property defined will animate out when removed from\r\n * the tree.\r\n *\r\n * ```jsx\r\n * import { Frame, AnimatePresence } from 'framer'\r\n *\r\n * // As items are added and removed from `items`\r\n * export function Items({ items }) {\r\n *   return (\r\n *     <AnimatePresence>\r\n *       {items.map(item => (\r\n *         <Frame\r\n *           key={item.id}\r\n *           initial={{ opacity: 0 }}\r\n *           animate={{ opacity: 1 }}\r\n *           exit={{ opacity: 0 }}\r\n *         />\r\n *       ))}\r\n *     </AnimatePresence>\r\n *   )\r\n * }\r\n * ```\r\n *\r\n * You can sequence exit animations throughout a tree using variants.\r\n *\r\n * @motion\r\n *\r\n * Any `motion` components that have an `exit` property defined will animate out when removed from\r\n * the tree.\r\n *\r\n * ```jsx\r\n * import { motion, AnimatePresence } from 'framer-motion'\r\n *\r\n * export const Items = ({ items }) => (\r\n *   <AnimatePresence>\r\n *     {items.map(item => (\r\n *       <motion.div\r\n *         key={item.id}\r\n *         initial={{ opacity: 0 }}\r\n *         animate={{ opacity: 1 }}\r\n *         exit={{ opacity: 0 }}\r\n *       />\r\n *     ))}\r\n *   </AnimatePresence>\r\n * )\r\n * ```\r\n *\r\n * You can sequence exit animations throughout a tree using variants.\r\n *\r\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\r\n * once all `motion` components have finished animating out. Likewise, any components using\r\n * `usePresence` all need to call `safeToRemove`.\r\n *\r\n * @public\r\n */\n\n\nvar AnimatePresence = function (_a) {\n  var children = _a.children,\n      custom = _a.custom,\n      _b = _a.initial,\n      initial = _b === void 0 ? true : _b,\n      onExitComplete = _a.onExitComplete,\n      exitBeforeEnter = _a.exitBeforeEnter; // We want to force a re-render once all exiting animations have finished. We\n  // either use a local forceRender function, or one from a parent context if it exists.\n\n  var forceRender = useForceUpdate();\n  var layoutContext = useContext(SharedLayoutContext);\n\n  if (isSharedLayout(layoutContext)) {\n    forceRender = layoutContext.forceUpdate;\n  }\n\n  var isInitialRender = useRef(true); // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n\n  var filteredChildren = onlyElements(children); // Keep a living record of the children we're actually rendering so we\n  // can diff to figure out which are entering and exiting\n\n  var presentChildren = useRef(filteredChildren); // A lookup table to quickly reference components by key\n\n  var allChildren = useRef(new Map()).current; // A living record of all currently exiting components.\n\n  var exiting = useRef(new Set()).current;\n  updateChildLookup(filteredChildren, allChildren); // If this is the initial component render, just deal with logic surrounding whether\n  // we play onMount animations or not.\n\n  if (isInitialRender.current) {\n    isInitialRender.current = false;\n    return createElement(Fragment, null, filteredChildren.map(function (child) {\n      return createElement(PresenceChild, {\n        key: getChildKey(child),\n        isPresent: true,\n        initial: initial ? undefined : false\n      }, child);\n    }));\n  } // If this is a subsequent render, deal with entering and exiting children\n\n\n  var childrenToRender = __spreadArrays(filteredChildren); // Diff the keys of the currently-present and target children to update our\n  // exiting list.\n\n\n  var presentKeys = presentChildren.current.map(getChildKey);\n  var targetKeys = filteredChildren.map(getChildKey); // Diff the present children with our target children and mark those that are exiting\n\n  var numPresent = presentKeys.length;\n\n  for (var i = 0; i < numPresent; i++) {\n    var key = presentKeys[i];\n\n    if (targetKeys.indexOf(key) === -1) {\n      exiting.add(key);\n    } else {\n      // In case this key has re-entered, remove from the exiting list\n      exiting.delete(key);\n    }\n  } // If we currently have exiting children, and we're deferring rendering incoming children\n  // until after all current children have exiting, empty the childrenToRender array\n\n\n  if (exitBeforeEnter && exiting.size) {\n    childrenToRender = [];\n  } // Loop through all currently exiting components and clone them to overwrite `animate`\n  // with any `exit` prop they might have defined.\n\n\n  exiting.forEach(function (key) {\n    // If this component is actually entering again, early return\n    if (targetKeys.indexOf(key) !== -1) return;\n    var child = allChildren.get(key);\n    if (!child) return;\n    var insertionIndex = presentKeys.indexOf(key);\n\n    var onExit = function () {\n      allChildren.delete(key);\n      exiting.delete(key); // Remove this child from the present children\n\n      var removeIndex = presentChildren.current.findIndex(function (presentChild) {\n        return presentChild.key === key;\n      });\n      presentChildren.current.splice(removeIndex, 1); // Defer re-rendering until all exiting children have indeed left\n\n      if (!exiting.size) {\n        presentChildren.current = filteredChildren;\n        forceRender();\n        onExitComplete && onExitComplete();\n      }\n    };\n\n    childrenToRender.splice(insertionIndex, 0, createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: false,\n      onExitComplete: onExit,\n      custom: custom\n    }, child));\n  }); // Add `MotionContext` even to children that don't need it to ensure we're rendering\n  // the same tree between renders\n\n  childrenToRender = childrenToRender.map(function (child) {\n    var key = child.key;\n    return exiting.has(key) ? child : createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: true\n    }, child);\n  });\n  presentChildren.current = childrenToRender;\n\n  if (process.env.NODE_ENV !== \"production\" && exitBeforeEnter && childrenToRender.length > 1) {\n    console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n  }\n\n  return createElement(Fragment, null, exiting.size ? childrenToRender : childrenToRender.map(function (child) {\n    return cloneElement(child);\n  }));\n};\n\nfunction createSwitchAnimation(child, stack) {\n  if (stack && child !== stack.lead) {\n    return {\n      visibilityAction: VisibilityAction.Hide\n    };\n  } else if (stack && child.presence !== Presence.Entering && child === stack.lead && stack.lead !== stack.prevLead) {\n    return {\n      visibilityAction: VisibilityAction.Show\n    };\n  }\n\n  var originBox;\n  var targetBox;\n\n  if (child.presence === Presence.Entering) {\n    originBox = stack === null || stack === void 0 ? void 0 : stack.getFollowOrigin();\n  } else if (child.presence === Presence.Exiting) {\n    targetBox = stack === null || stack === void 0 ? void 0 : stack.getFollowTarget();\n  }\n\n  return {\n    originBox: originBox,\n    targetBox: targetBox\n  };\n}\n\nfunction createCrossfadeAnimation(child, stack) {\n  var _a, _b, _c;\n\n  var config = {};\n  var stackLead = stack && stack.lead;\n  var stackLeadPresence = stackLead === null || stackLead === void 0 ? void 0 : stackLead.presence;\n\n  if (stack && child === stackLead) {\n    if (child.presence === Presence.Entering) {\n      config.originBox = stack.getFollowOrigin();\n    } else if (child.presence === Presence.Exiting) {\n      config.targetBox = stack.getFollowTarget();\n    }\n  } else if (stack && child === stack.follow) {\n    config.transition = stack.getLeadTransition();\n\n    if (stackLeadPresence === Presence.Entering) {\n      config.targetBox = stack.getLeadTarget();\n    } else if (stackLeadPresence === Presence.Exiting) {\n      config.originBox = stack.getLeadOrigin();\n    }\n  } // If neither the lead or follow component is the root child of AnimatePresence,\n  // don't handle crossfade animations\n\n\n  if (!((_a = stack === null || stack === void 0 ? void 0 : stack.follow) === null || _a === void 0 ? void 0 : _a.isPresenceRoot) && !(stackLead === null || stackLead === void 0 ? void 0 : stackLead.isPresenceRoot)) {\n    return config;\n  }\n\n  if (!stack || child === stackLead) {\n    if (child.presence === Presence.Entering) {\n      config.crossfadeOpacity = (_b = stack === null || stack === void 0 ? void 0 : stack.follow) === null || _b === void 0 ? void 0 : _b.getValue(\"opacity\", 0);\n    }\n  } else if (stack && child === stack.follow) {\n    if (!stackLead || stackLeadPresence === Presence.Entering) ;else if (stackLeadPresence === Presence.Exiting) {\n      config.crossfadeOpacity = (_c = stack === null || stack === void 0 ? void 0 : stack.lead) === null || _c === void 0 ? void 0 : _c.getValue(\"opacity\", 1);\n    }\n  } else {\n    config.visibilityAction = VisibilityAction.Hide;\n  }\n\n  return config;\n}\n/**\r\n * For each layout animation, we want to identify two components\r\n * within a stack that will serve as the \"lead\" and \"follow\" components.\r\n *\r\n * In the switch animation, the lead component performs the entire animation.\r\n * It uses the follow bounding box to animate out from and back to. The follow\r\n * component is hidden.\r\n *\r\n * In the crossfade animation, both the lead and follow components perform\r\n * the entire animation, animating from the follow origin bounding box to the lead\r\n * target bounding box.\r\n *\r\n * Generalising a stack as First In Last Out, *searching from the end* we can\r\n * generally consider the lead component to be:\r\n *  - If the last child is present, the last child\r\n *  - If the last child is exiting, the last *encountered* exiting component\r\n */\n\n\nfunction findLeadAndFollow(stack, _a) {\n  var prevLead = _a[0],\n      prevFollow = _a[1];\n  var lead = undefined;\n  var leadIndex = 0;\n  var follow = undefined; // Find the lead child first\n\n  var numInStack = stack.length;\n  var lastIsPresent = false;\n\n  for (var i = numInStack - 1; i >= 0; i--) {\n    var child = stack[i];\n    var isLastInStack = i === numInStack - 1;\n    if (isLastInStack) lastIsPresent = child.isPresent;\n\n    if (lastIsPresent) {\n      lead = child;\n    } else {\n      // If the child before this will be present, make this the\n      // lead.\n      var prev = stack[i - 1];\n      if (prev && prev.isPresent) lead = child;\n    }\n\n    if (lead) {\n      leadIndex = i;\n      break;\n    }\n  }\n\n  if (!lead) lead = stack[0]; // Find the follow child\n\n  follow = stack[leadIndex - 1]; // If the lead component is exiting, find the closest follow\n  // present component\n\n  if (lead) {\n    for (var i = leadIndex - 1; i >= 0; i--) {\n      var child = stack[i];\n\n      if (child.isPresent) {\n        follow = child;\n        break;\n      }\n    }\n  } // If the lead has changed and the previous lead still exists in the\n  // stack, set it to the previous lead. This allows us to differentiate between\n  // a, b, c(exit) -> a, b(exit), c(exit)\n  // and\n  // a, b(exit), c -> a, b(exit), c(exit)\n\n\n  if (lead !== prevLead && !lastIsPresent && follow === prevFollow && stack.find(function (stackChild) {\n    return stackChild === prevLead;\n  })) {\n    lead = prevLead;\n  }\n\n  return [lead, follow];\n}\n\nvar LayoutStack =\n/** @class */\nfunction () {\n  function LayoutStack() {\n    this.order = []; // Track whether we've ever had a child\n\n    this.hasChildren = false;\n  }\n\n  LayoutStack.prototype.add = function (child) {\n    var _a;\n\n    var layoutOrder = child.config.layoutOrder;\n\n    if (layoutOrder === undefined) {\n      this.order.push(child);\n    } else {\n      var index = this.order.findIndex(function (stackChild) {\n        return layoutOrder <= (stackChild.config.layoutOrder || 0);\n      });\n\n      if (index === -1) {\n        child.presence = this.hasChildren ? Presence.Entering : Presence.Present;\n        index = this.order.length;\n      }\n\n      this.order.splice(index, 0, child);\n    }\n    /**\r\n     *\r\n     */\n    // Load previous values from snapshot into this child\n    // TODO Neaten up\n    // TODO Double check when reimplementing move\n    // TODO Add isDragging status and\n\n\n    if (this.snapshot) {\n      child.prevSnapshot = this.snapshot; // TODO Remove in favour of above\n\n      child.prevViewportBox = this.snapshot.boundingBox;\n      var latest = this.snapshot.latestMotionValues;\n\n      for (var key in latest) {\n        if (!child.hasValue(key)) {\n          child.addValue(key, motionValue(latest[key]));\n        } else {\n          (_a = child.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(latest[key]);\n        }\n      }\n    }\n\n    this.hasChildren = true;\n  };\n\n  LayoutStack.prototype.remove = function (child) {\n    var index = this.order.findIndex(function (stackChild) {\n      return child === stackChild;\n    });\n    if (index !== -1) this.order.splice(index, 1);\n  };\n\n  LayoutStack.prototype.updateLeadAndFollow = function () {\n    this.prevLead = this.lead;\n    this.prevFollow = this.follow;\n\n    var _a = findLeadAndFollow(this.order, [this.lead, this.follow]),\n        lead = _a[0],\n        follow = _a[1];\n\n    this.lead = lead;\n    this.follow = follow;\n  };\n\n  LayoutStack.prototype.updateSnapshot = function () {\n    if (!this.lead) return;\n    var snapshot = {\n      boundingBox: this.lead.prevViewportBox,\n      latestMotionValues: {}\n    };\n    this.lead.forEachValue(function (value, key) {\n      var latest = value.get();\n\n      if (!isTransformProp(latest)) {\n        snapshot.latestMotionValues[key] = latest;\n      }\n    });\n    var dragControls = elementDragControls.get(this.lead);\n\n    if (dragControls && dragControls.isDragging) {\n      snapshot.isDragging = true;\n      snapshot.cursorProgress = dragControls.cursorProgress;\n    }\n\n    this.snapshot = snapshot;\n  };\n\n  LayoutStack.prototype.isLeadPresent = function () {\n    var _a;\n\n    return this.lead && ((_a = this.lead) === null || _a === void 0 ? void 0 : _a.presence) !== Presence.Exiting;\n  };\n\n  LayoutStack.prototype.shouldStackAnimate = function () {\n    return true; // return this.lead && this.lead?.isPresent\n    //     ? this.lead?.props?._shouldAnimate === true\n    //     : this.follow && this.follow?.props._shouldAnimate === true\n  };\n\n  LayoutStack.prototype.getFollowOrigin = function () {\n    var _a; // This shouldAnimate check is quite specifically a fix for the optimisation made in Framer\n    // where components are kept in the tree ready to be re-used\n\n\n    return this.follow // && this.follow.shouldAnimate\n    ? this.follow.prevViewportBox : (_a = this.snapshot) === null || _a === void 0 ? void 0 : _a.boundingBox;\n  };\n\n  LayoutStack.prototype.getFollowTarget = function () {\n    var _a;\n\n    return (_a = this.follow) === null || _a === void 0 ? void 0 : _a.box;\n  };\n\n  LayoutStack.prototype.getLeadOrigin = function () {\n    var _a;\n\n    return (_a = this.lead) === null || _a === void 0 ? void 0 : _a.prevViewportBox;\n  };\n\n  LayoutStack.prototype.getLeadTarget = function () {\n    var _a;\n\n    return (_a = this.lead) === null || _a === void 0 ? void 0 : _a.box;\n  };\n\n  LayoutStack.prototype.getLeadTransition = function () {\n    var _a;\n\n    return (_a = this.lead) === null || _a === void 0 ? void 0 : _a.config.transition;\n  };\n\n  return LayoutStack;\n}();\n/**\r\n * @public\r\n */\n\n\nvar AnimateSharedLayout =\n/** @class */\nfunction (_super) {\n  __extends(AnimateSharedLayout, _super);\n\n  function AnimateSharedLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\r\n     * A list of all the children in the shared layout\r\n     */\n\n\n    _this.children = new Set();\n    /**\r\n     * As animate components with a defined `layoutId` are added/removed to the tree,\r\n     * we store them in order. When one is added, it will animate out from the\r\n     * previous one, and when it's removed, it'll animate to the previous one.\r\n     */\n\n    _this.stacks = new Map();\n    /**\r\n     * Track whether the component has mounted. If it hasn't, the presence of added children\r\n     * are set to Present, whereas if it has they're considered Entering\r\n     */\n\n    _this.hasMounted = false;\n    /**\r\n     * Track whether we already have an update scheduled. If we don't, we'll run snapshots\r\n     * and schedule one.\r\n     */\n\n    _this.updateScheduled = false;\n    /**\r\n     * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\r\n     */\n\n    _this.renderScheduled = false;\n    /**\r\n     * The methods provided to all children in the shared layout tree.\r\n     */\n\n    _this.syncContext = __assign(__assign({}, createBatcher()), {\n      syncUpdate: function (force) {\n        return _this.scheduleUpdate(force);\n      },\n      forceUpdate: function () {\n        // By copying syncContext to itself, when this component re-renders it'll also re-render\n        // all children subscribed to the SharedLayout context.\n        _this.syncContext = __assign({}, _this.syncContext);\n\n        _this.scheduleUpdate(true);\n      },\n      register: function (child) {\n        return _this.addChild(child);\n      },\n      remove: function (child) {\n        return _this.removeChild(child);\n      }\n    });\n    return _this;\n  }\n\n  AnimateSharedLayout.prototype.componentDidMount = function () {\n    this.hasMounted = true;\n    this.updateStacks();\n  };\n\n  AnimateSharedLayout.prototype.componentDidUpdate = function () {\n    this.startLayoutAnimation();\n  };\n\n  AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\n    this.renderScheduled = true;\n    return true;\n  };\n\n  AnimateSharedLayout.prototype.startLayoutAnimation = function () {\n    var _this = this;\n    /**\r\n     * Reset update and render scheduled status\r\n     */\n\n\n    this.renderScheduled = this.updateScheduled = false;\n    var type = this.props.type;\n    /**\r\n     * Update presence metadata based on the latest AnimatePresence status.\r\n     * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\r\n     */\n\n    this.children.forEach(function (child) {\n      if (!child.isPresent) {\n        child.presence = Presence.Exiting;\n      } else if (child.presence !== Presence.Entering) {\n        child.presence = child.presence === Presence.Exiting ? Presence.Entering : Presence.Present;\n      }\n    });\n    /**\r\n     * In every layoutId stack, nominate a component to lead the animation and another\r\n     * to follow\r\n     */\n\n    this.updateStacks();\n    /**\r\n     * Decide which animation to use between shared layoutId components\r\n     */\n\n    var createAnimation = type === \"crossfade\" ? createCrossfadeAnimation : createSwitchAnimation;\n    /**\r\n     * Create a handler which we can use to flush the children animations\r\n     */\n\n    var handler = {\n      measureLayout: function (child) {\n        return child.measureLayout();\n      },\n      layoutReady: function (child) {\n        var layoutId = child.layoutId;\n        child.layoutReady(createAnimation(child, _this.getStack(layoutId)));\n      }\n    };\n    /**\r\n     * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\r\n     * This requires some co-ordination across components to stop layout thrashing\r\n     * and ensure measurements are taken at the correct time.\r\n     *\r\n     * Here we use that same mechanism of schedule/flush.\r\n     */\n\n    this.children.forEach(function (child) {\n      return _this.syncContext.add(child);\n    });\n    this.syncContext.flush(handler);\n    /**\r\n     * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\r\n     */\n\n    this.stacks.forEach(function (stack) {\n      return stack.snapshot = undefined;\n    });\n  };\n\n  AnimateSharedLayout.prototype.updateStacks = function () {\n    this.stacks.forEach(function (stack) {\n      return stack.updateLeadAndFollow();\n    });\n  };\n\n  AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    if (!(force || !this.updateScheduled)) return;\n    /**\r\n     * Flag we've scheduled an update\r\n     */\n\n    this.updateScheduled = true;\n    /**\r\n     * Snapshot children\r\n     */\n\n    this.children.forEach(function (child) {\n      return child.snapshotBoundingBox();\n    });\n    /**\r\n     * Every child keeps a local snapshot, but we also want to record\r\n     * snapshots of the visible children as, if they're are being removed\r\n     * in this render, we can still access them.\r\n     */\n\n    this.stacks.forEach(function (stack) {\n      return stack.updateSnapshot();\n    });\n    /**\r\n     * Force a rerender by setting state if we aren't already going to render.\r\n     */\n\n    if (force || !this.renderScheduled) {\n      this.renderScheduled = true;\n      this.forceUpdate();\n    }\n  };\n\n  AnimateSharedLayout.prototype.addChild = function (child) {\n    this.children.add(child);\n    this.addToStack(child);\n    child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n  };\n\n  AnimateSharedLayout.prototype.removeChild = function (child) {\n    this.scheduleUpdate();\n    this.children.delete(child);\n    this.removeFromStack(child);\n  };\n\n  AnimateSharedLayout.prototype.addToStack = function (child) {\n    var stack = this.getStack(child.layoutId);\n    stack === null || stack === void 0 ? void 0 : stack.add(child);\n  };\n\n  AnimateSharedLayout.prototype.removeFromStack = function (child) {\n    var stack = this.getStack(child.layoutId);\n    stack === null || stack === void 0 ? void 0 : stack.remove(child);\n  };\n  /**\r\n   * Return a stack of animate children based on the provided layoutId.\r\n   * Will create a stack if none currently exists with that layoutId.\r\n   */\n\n\n  AnimateSharedLayout.prototype.getStack = function (id) {\n    if (id === undefined) return; // Create stack if it doesn't already exist\n\n    !this.stacks.has(id) && this.stacks.set(id, new LayoutStack());\n    return this.stacks.get(id);\n  };\n\n  AnimateSharedLayout.prototype.render = function () {\n    return createElement(SharedLayoutContext.Provider, {\n      value: this.syncContext\n    }, this.props.children);\n  };\n\n  return AnimateSharedLayout;\n}(Component);\n/**\r\n * Creates a `MotionValue` to track the state and velocity of a value.\r\n *\r\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * export function MyComponent() {\r\n *   const scale = useMotionValue(1)\r\n *\r\n *   return <Frame scale={scale} />\r\n * }\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * export const MyComponent = () => {\r\n *   const scale = useMotionValue(1)\r\n *\r\n *   return <motion.div style={{ scale }} />\r\n * }\r\n * ```\r\n *\r\n * @param initial - The initial state.\r\n *\r\n * @public\r\n */\n\n\nfunction useMotionValue(initial) {\n  return useConstant(function () {\n    return motionValue(initial);\n  });\n}\n/**\r\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\r\n *\r\n * TODO: Remove and move to library\r\n *\r\n * @internal\r\n */\n\n\nfunction resolveMotionValue(value) {\n  var unwrappedValue = value instanceof MotionValue ? value.get() : value;\n  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;\n}\n\nvar isCustomValueType = function (v) {\n  return typeof v === \"object\" && v.mix;\n};\n\nvar getMixer = function (v) {\n  return isCustomValueType(v) ? v.mix : undefined;\n};\n\nfunction transform() {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  var useImmediate = !Array.isArray(args[0]);\n  var argOffset = useImmediate ? 0 : -1;\n  var inputValue = args[0 + argOffset];\n  var inputRange = args[1 + argOffset];\n  var outputRange = args[2 + argOffset];\n  var options = args[3 + argOffset];\n  var interpolator = interpolate(inputRange, outputRange, __assign({\n    mixer: getMixer(outputRange[0])\n  }, options));\n  return useImmediate ? interpolator(inputValue) : interpolator;\n}\n\nvar isTransformer = function (v) {\n  return typeof v === \"function\";\n};\n\nfunction useTransform(parent, customTransform, to, options) {\n  var comparitor = isTransformer(customTransform) ? [parent] : [parent, customTransform.join(\",\"), to === null || to === void 0 ? void 0 : to.join(\",\")];\n  var transformer = useMemo(function () {\n    return isTransformer(customTransform) ? customTransform : transform(customTransform, to, options);\n  }, comparitor);\n  var initialValue = transformer(parent.get());\n  var value = useMotionValue(initialValue); // Handle subscription to parent\n\n  var unsubscribe = useRef();\n  useMemo(function () {\n    unsubscribe.current && unsubscribe.current();\n    unsubscribe.current = parent.onChange(function (v) {\n      return value.set(transformer(v));\n    }); // Manually set with the latest parent value in case we've re-parented\n\n    value.set(initialValue);\n  }, [parent, value, transformer]);\n  useUnmountEffect(function () {\n    return unsubscribe.current && unsubscribe.current();\n  });\n  return value;\n} // Keep things reasonable and avoid scale: Infinity. In practise we might need\n// to add another value, opacity, that could interpolate scaleX/Y [0,0.01] => [0,1]\n// to simply hide content at unreasonable scales.\n\n\nvar maxScale = 100000;\n\nvar invertScale = function (scale) {\n  return scale > 0.001 ? 1 / scale : maxScale;\n};\n/**\r\n * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse\r\n * of their respective parent scales.\r\n *\r\n * This is useful for undoing the distortion of content when scaling a parent component.\r\n *\r\n * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.\r\n * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output\r\n * of those instead.\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * const MyComponent = () => {\r\n *   const { scaleX, scaleY } = useInvertedScale()\r\n *   return <motion.div style={{ scaleX, scaleY }} />\r\n * }\r\n * ```\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * function MyComponent() {\r\n *   const { scaleX, scaleY } = useInvertedScale()\r\n *   return <Frame scaleX={scaleX} scaleY={scaleY} />\r\n * }\r\n * ```\r\n *\r\n * @public\r\n */\n\n\nfunction useInvertedScale(scale) {\n  var parentScaleX = useMotionValue(1);\n  var parentScaleY = useMotionValue(1);\n  var visualElement = useContext(MotionContext).visualElement;\n  invariant(!!(scale || visualElement), \"If no scale values are provided, useInvertedScale must be used within a child of another motion component.\");\n\n  if (scale) {\n    parentScaleX = scale.scaleX || parentScaleX;\n    parentScaleY = scale.scaleY || parentScaleY;\n  } else if (visualElement) {\n    parentScaleX = visualElement.getValue(\"scaleX\", 1);\n    parentScaleY = visualElement.getValue(\"scaleY\", 1);\n  }\n\n  var scaleX = useTransform(parentScaleX, invertScale);\n  var scaleY = useTransform(parentScaleY, invertScale);\n  return {\n    scaleX: scaleX,\n    scaleY: scaleY\n  };\n}\n\nfunction useOnChange(value, callback) {\n  useEffect(function () {\n    return isMotionValue(value) ? value.onChange(callback) : undefined;\n  }, [value]);\n}\n/**\r\n * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.\r\n *\r\n * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber\r\n * to another `MotionValue`.\r\n *\r\n * @remarks\r\n *\r\n * ```jsx\r\n * const x = useSpring(0, { stiffness: 300 })\r\n * const y = useSpring(x, { damping: 10 })\r\n * ```\r\n *\r\n * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.\r\n * @param springConfig - Configuration options for the spring.\r\n * @returns `MotionValue`\r\n *\r\n * @public\r\n */\n\n\nfunction useSpring(source, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var activeSpringAnimation = useRef(null);\n  var value = useMotionValue(isMotionValue(source) ? source.get() : source);\n  useMemo(function () {\n    return value.attach(function (v, set) {\n      if (activeSpringAnimation.current) {\n        activeSpringAnimation.current.stop();\n      }\n\n      activeSpringAnimation.current = spring(__assign({\n        from: value.get(),\n        to: v,\n        velocity: value.getVelocity()\n      }, config)).start(set);\n      return value.get();\n    });\n  }, Object.values(config));\n  useOnChange(source, function (v) {\n    return value.set(parseFloat(v));\n  });\n  return value;\n}\n\nfunction createScrollMotionValues() {\n  return {\n    scrollX: motionValue(0),\n    scrollY: motionValue(0),\n    scrollXProgress: motionValue(0),\n    scrollYProgress: motionValue(0)\n  };\n}\n\nfunction setProgress(offset, maxOffset, value) {\n  value.set(!offset || !maxOffset ? 0 : offset / maxOffset);\n}\n\nfunction createScrollUpdater(values, getOffsets) {\n  var update = function () {\n    var _a = getOffsets(),\n        xOffset = _a.xOffset,\n        yOffset = _a.yOffset,\n        xMaxOffset = _a.xMaxOffset,\n        yMaxOffset = _a.yMaxOffset; // Set absolute positions\n\n\n    values.scrollX.set(xOffset);\n    values.scrollY.set(yOffset); // Set 0-1 progress\n\n    setProgress(xOffset, xMaxOffset, values.scrollXProgress);\n    setProgress(yOffset, yMaxOffset, values.scrollYProgress);\n  };\n\n  update();\n  return update;\n}\n\nvar isBrowser$2 = typeof window !== \"undefined\";\nvar useIsomorphicLayoutEffect = isBrowser$2 ? useLayoutEffect : useEffect;\n\nvar getElementScrollOffsets = function (element) {\n  return function () {\n    return {\n      xOffset: element.scrollLeft,\n      yOffset: element.scrollTop,\n      xMaxOffset: element.scrollWidth - element.offsetWidth,\n      yMaxOffset: element.scrollHeight - element.offsetHeight\n    };\n  };\n};\n/**\r\n * Returns MotionValues that update when the provided element scrolls:\r\n *\r\n * - `scrollX` — Horizontal scroll distance in pixels.\r\n * - `scrollY` — Vertical scroll distance in pixels.\r\n * - `scrollXProgress` — Horizontal scroll progress between `0` and `1`.\r\n * - `scrollYProgress` — Vertical scroll progress between `0` and `1`.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * import * as React from \"react\"\r\n * import {\r\n *   Frame,\r\n *   useElementScroll,\r\n *   useTransform\r\n * } from \"framer\"\r\n *\r\n * export function MyComponent() {\r\n *   const ref = React.useRef()\r\n *   const { scrollYProgress } = useElementScroll(ref)\r\n *\r\n *   return (\r\n *     <Frame ref={ref}>\r\n *       <Frame scaleX={scrollYProgress} />\r\n *     </Frame>\r\n *   )\r\n * }\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * export const MyComponent = () => {\r\n *   const ref = useRef()\r\n *   const { scrollYProgress } = useElementScroll(ref)\r\n *\r\n *   return (\r\n *     <div ref={ref}>\r\n *       <motion.div style={{ scaleX: scrollYProgress }} />\r\n *     </div>\r\n *   )\r\n * }\r\n * ```\r\n *\r\n * @public\r\n */\n\n\nfunction useElementScroll(ref) {\n  var values = useConstant(createScrollMotionValues);\n  useIsomorphicLayoutEffect(function () {\n    var element = ref.current;\n    invariant(!!element, \"ref provided to useScroll must be passed into a HTML element.\");\n    if (!element) return;\n    var updateScrollValues = createScrollUpdater(values, getElementScrollOffsets(element));\n    var scrollListener = addDomEvent(element, \"scroll\", updateScrollValues, {\n      passive: true\n    });\n    var resizeListener = addDomEvent(element, \"resize\", updateScrollValues);\n    return function () {\n      scrollListener && scrollListener();\n      resizeListener && resizeListener();\n    };\n  }, []);\n  return values;\n}\n\nvar viewportScrollValues = createScrollMotionValues();\n\nfunction getViewportScrollOffsets() {\n  return {\n    xOffset: window.pageXOffset,\n    yOffset: window.pageYOffset,\n    xMaxOffset: document.body.clientWidth - window.innerWidth,\n    yMaxOffset: document.body.clientHeight - window.innerHeight\n  };\n}\n\nvar hasListeners = false;\n\nfunction addEventListeners() {\n  hasListeners = true;\n  if (typeof window === \"undefined\") return;\n  var updateScrollValues = createScrollUpdater(viewportScrollValues, getViewportScrollOffsets);\n  addDomEvent(window, \"scroll\", updateScrollValues, {\n    passive: true\n  });\n  addDomEvent(window, \"resize\", updateScrollValues);\n}\n/**\r\n * Returns MotionValues that update when the viewport scrolls:\r\n *\r\n * - `scrollX` — Horizontal scroll distance in pixels.\r\n * - `scrollY` — Vertical scroll distance in pixels.\r\n * - `scrollXProgress` — Horizontal scroll progress between `0` and `1`.\r\n * - `scrollYProgress` — Vertical scroll progress between `0` and `1`.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * import * as React from \"react\"\r\n * import {\r\n *   Frame,\r\n *   useViewportScroll,\r\n *   useTransform\r\n * } from \"framer\"\r\n *\r\n * export function MyComponent() {\r\n *   const { scrollYProgress } = useViewportScroll()\r\n *   return <Frame scaleX={scrollYProgress} />\r\n * }\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * export const MyComponent = () => {\r\n *   const { scrollYProgress } = useViewportScroll()\r\n *   return <motion.div style={{ scaleX: scrollYProgress }} />\r\n * }\r\n * ```\r\n *\r\n * @public\r\n */\n\n\nfunction useViewportScroll() {\n  useIsomorphicLayoutEffect(function () {\n    !hasListeners && addEventListeners();\n  }, []);\n  return viewportScrollValues;\n}\n/**\r\n * Creates `AnimationControls`, which can be used to manually start, stop\r\n * and sequence animations on one or more components.\r\n *\r\n * The returned `AnimationControls` should be passed to the `animate` property\r\n * of the components you want to animate.\r\n *\r\n * These components can then be animated with the `start` method.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * import * as React from 'react'\r\n * import { Frame, useAnimation } from 'framer'\r\n *\r\n * export function MyComponent(props) {\r\n *    const controls = useAnimation()\r\n *\r\n *    controls.start({\r\n *        x: 100,\r\n *        transition: { duration: 0.5 },\r\n *    })\r\n *\r\n *    return <Frame animate={controls} />\r\n * }\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * import * as React from 'react'\r\n * import { motion, useAnimation } from 'framer-motion'\r\n *\r\n * export function MyComponent(props) {\r\n *    const controls = useAnimation()\r\n *\r\n *    controls.start({\r\n *        x: 100,\r\n *        transition: { duration: 0.5 },\r\n *    })\r\n *\r\n *    return <motion.div animate={controls} />\r\n * }\r\n * ```\r\n *\r\n * @returns Animation controller with `start` and `stop` methods\r\n *\r\n * @public\r\n */\n\n\nfunction useAnimation() {\n  var animationControls = useConstant(function () {\n    return new AnimationControls();\n  });\n  useEffect(function () {\n    animationControls.mount();\n    return function () {\n      return animationControls.unmount();\n    };\n  }, []);\n  return animationControls;\n}\n/**\r\n * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * import * as React from \"react\"\r\n * import { Frame, useCycle } from \"framer\"\r\n *\r\n * export function MyComponent() {\r\n *   const [x, cycleX] = useCycle(0, 50, 100)\r\n *\r\n *   return (\r\n *     <Frame\r\n *       animate={{ x: x }}\r\n *       onTap={() => cycleX()}\r\n *      />\r\n *    )\r\n * }\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * An index value can be passed to the returned `cycle` function to cycle to a specific index.\r\n *\r\n * ```jsx\r\n * import * as React from \"react\"\r\n * import { motion, useCycle } from \"framer-motion\"\r\n *\r\n * export const MyComponent = () => {\r\n *   const [x, cycleX] = useCycle(0, 50, 100)\r\n *\r\n *   return (\r\n *     <motion.div\r\n *       animate={{ x: x }}\r\n *       onTap={() => cycleX()}\r\n *      />\r\n *    )\r\n * }\r\n * ```\r\n *\r\n * @param items - items to cycle through\r\n * @returns [currentState, cycleState]\r\n *\r\n * @public\r\n */\n\n\nfunction useCycle() {\n  var items = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    items[_i] = arguments[_i];\n  } // TODO: After Framer X beta, remove this warning\n\n\n  warning(items.length > 1, \"useCycle syntax has changed. `useCycle([0, 1, 2])` becomes `useCycle(0, 1, 2)`\");\n  var index = useRef(0);\n\n  var _a = useState(items[index.current]),\n      item = _a[0],\n      setItem = _a[1];\n\n  return [item, function (next) {\n    index.current = typeof next !== \"number\" ? wrap(0, items.length, index.current + 1) : next;\n    setItem(items[index.current]);\n  }];\n} // Does this device prefer reduced motion? Returns `null` server-side.\n\n\nvar prefersReducedMotion = motionValue(null);\n\nif (typeof window !== \"undefined\") {\n  if (window.matchMedia) {\n    var motionMediaQuery_1 = window.matchMedia(\"(prefers-reduced-motion)\");\n\n    var setReducedMotionPreferences = function () {\n      return prefersReducedMotion.set(motionMediaQuery_1.matches);\n    };\n\n    motionMediaQuery_1.addListener(setReducedMotionPreferences);\n    setReducedMotionPreferences();\n  } else {\n    prefersReducedMotion.set(false);\n  }\n}\n\nfunction determineShouldReduceMotion(prefersReduced, isReducedMotion) {\n  return typeof isReducedMotion === \"boolean\" ? isReducedMotion : Boolean(prefersReduced);\n}\n/**\r\n * A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.\r\n *\r\n * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing\r\n * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.\r\n *\r\n * It will actively respond to changes and re-render your components with the latest setting.\r\n *\r\n * ```jsx\r\n * export function Sidebar({ isOpen }) {\r\n *   const shouldReduceMotion = useReducedMotion()\r\n *   const closedX = shouldReduceMotion ? 0 : \"-100%\"\r\n *\r\n *   return (\r\n *     <motion.div animate={{\r\n *       opacity: isOpen ? 1 : 0,\r\n *       x: isOpen ? 0 : closedX\r\n *     }} />\r\n *   )\r\n * }\r\n * ```\r\n *\r\n * @return boolean\r\n *\r\n * @public\r\n */\n\n\nfunction useReducedMotion() {\n  var isReducedMotion = useContext(MotionContext).isReducedMotion;\n\n  var _a = useState(determineShouldReduceMotion(prefersReducedMotion.get(), isReducedMotion)),\n      shouldReduceMotion = _a[0],\n      setShouldReduceMotion = _a[1];\n\n  useEffect(function () {\n    return prefersReducedMotion.onChange(function (v) {\n      setShouldReduceMotion(determineShouldReduceMotion(v, isReducedMotion));\n    });\n  }, [setShouldReduceMotion, isReducedMotion]);\n  return shouldReduceMotion;\n}\n/**\r\n * Define accessibility options for a tree. Can be used to force the tree into Reduced Motion mode,\r\n * or disable device detection.\r\n *\r\n * @internal\r\n */\n\n\nfunction ReducedMotion(_a) {\n  var children = _a.children,\n      enabled = _a.enabled;\n  var context = useContext(MotionContext);\n  context = useMemo(function () {\n    return __assign(__assign({}, context), {\n      isReducedMotion: enabled\n    });\n  }, [enabled]);\n  return createElement(MotionContext.Provider, {\n    value: context\n  }, children);\n}\n/**\r\n * Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * const dragControls = useDragControls()\r\n *\r\n * function startDrag(event) {\r\n *   dragControls.start(event, { snapToCursor: true })\r\n * }\r\n *\r\n * return (\r\n *   <>\r\n *     <Frame onTapStart={startDrag} />\r\n *     <Frame drag=\"x\" dragControls={dragControls} />\r\n *   </>\r\n * )\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * const dragControls = useDragControls()\r\n *\r\n * function startDrag(event) {\r\n *   dragControls.start(event, { snapToCursor: true })\r\n * }\r\n *\r\n * return (\r\n *   <>\r\n *     <div onMouseDown={startDrag} />\r\n *     <motion.div drag=\"x\" dragControls={dragControls} />\r\n *   </>\r\n * )\r\n * ```\r\n *\r\n * @public\r\n */\n\n\nvar DragControls =\n/** @class */\nfunction () {\n  function DragControls() {\n    this.componentControls = new Set();\n  }\n  /**\r\n   * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.\r\n   *\r\n   * @internal\r\n   */\n\n\n  DragControls.prototype.subscribe = function (controls) {\n    var _this = this;\n\n    this.componentControls.add(controls);\n    return function () {\n      return _this.componentControls.delete(controls);\n    };\n  };\n  /**\r\n   * Start a drag gesture on every `motion` component that has this set of drag controls\r\n   * passed into it via the `dragControls` prop.\r\n   *\r\n   * ```jsx\r\n   * dragControls.start(e, {\r\n   *   snapToCursor: true\r\n   * })\r\n   * ```\r\n   *\r\n   * @param event - A mouse/touch/pointer event.\r\n   * @param options - Options\r\n   *\r\n   * @public\r\n   */\n\n\n  DragControls.prototype.start = function (event, options) {\n    this.componentControls.forEach(function (controls) {\n      controls.start(event.nativeEvent || event, options);\n    });\n  };\n\n  return DragControls;\n}();\n\nvar createDragControls = function () {\n  return new DragControls();\n};\n/**\r\n * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop\r\n * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we\r\n * might want to initiate that dragging from a different component than the draggable one.\r\n *\r\n * By creating a `dragControls` using the `useDragControls` hook, we can pass this into\r\n * the draggable component's `dragControls` prop. It exposes a `start` method\r\n * that can start dragging from pointer events on other components.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * const dragControls = useDragControls()\r\n *\r\n * function startDrag(event) {\r\n *   dragControls.start(event, { snapToCursor: true })\r\n * }\r\n *\r\n * return (\r\n *   <>\r\n *     <Frame onTapStart={startDrag} />\r\n *     <Frame drag=\"x\" dragControls={dragControls} />\r\n *   </>\r\n * )\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * const dragControls = useDragControls()\r\n *\r\n * function startDrag(event) {\r\n *   dragControls.start(event, { snapToCursor: true })\r\n * }\r\n *\r\n * return (\r\n *   <>\r\n *     <div onMouseDown={startDrag} />\r\n *     <motion.div drag=\"x\" dragControls={dragControls} />\r\n *   </>\r\n * )\r\n * ```\r\n *\r\n * @public\r\n */\n\n\nfunction useDragControls() {\n  return useConstant(createDragControls);\n}\n/**\r\n * Uses the ref that is passed in, or creates a new one\r\n * @param external - External ref\r\n * @internal\r\n */\n\n\nfunction useExternalRef(externalRef) {\n  // We're conditionally calling `useRef` here which is sort of naughty as hooks\n  // shouldn't be called conditionally. However, Framer Motion will break if this\n  // condition changes anyway. It might be possible to use an invariant here to\n  // make it explicit, but I expect changing `ref` is not normal behaviour.\n  var ref = !externalRef || typeof externalRef === \"function\" ? useRef(null) : externalRef; // Handle `ref` functions. Again, calling the hook conditionally is kind of naughty\n  // but `ref` types changing between renders would break Motion anyway. If we receive\n  // bug reports about this, we should track the provided ref and throw an invariant\n  // rather than move the conditional to inside the useEffect as this will be fired\n  // for every Frame component within Framer.\n\n  if (externalRef && typeof externalRef === \"function\") {\n    useEffect(function () {\n      externalRef(ref.current);\n      return function () {\n        return externalRef(null);\n      };\n    }, []);\n  }\n\n  return ref;\n}\n/**\r\n * This is just a very basic VisualElement, more of a hack to keep supporting useAnimatedState with\r\n * the latest APIs.\r\n */\n\n\nvar StateVisualElement =\n/** @class */\nfunction (_super) {\n  __extends(StateVisualElement, _super);\n\n  function StateVisualElement() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.initialState = {};\n    return _this;\n  }\n\n  StateVisualElement.prototype.build = function () {};\n\n  StateVisualElement.prototype.clean = function () {};\n\n  StateVisualElement.prototype.getBoundingBox = function () {\n    return {\n      x: {\n        min: 0,\n        max: 0\n      },\n      y: {\n        min: 0,\n        max: 0\n      }\n    };\n  };\n\n  StateVisualElement.prototype.readNativeValue = function (key) {\n    return this.initialState[key] || 0;\n  };\n\n  StateVisualElement.prototype.render = function () {\n    this.build();\n  };\n\n  return StateVisualElement;\n}(VisualElement);\n/**\r\n * This is not an officially supported API and may be removed\r\n * on any version.\r\n * @internal\r\n */\n\n\nfunction useAnimatedState(initialState) {\n  var _a = useState(initialState),\n      animationState = _a[0],\n      setAnimationState = _a[1];\n\n  var visualElement = useConstant(function () {\n    return new StateVisualElement();\n  });\n  visualElement.updateConfig({\n    onUpdate: function (v) {\n      return setAnimationState(__assign({}, v));\n    }\n  });\n  visualElement.initialState = initialState;\n  var controls = useVisualElementAnimation(visualElement, {}, {});\n  useEffect(function () {\n    visualElement.mount({});\n    return function () {\n      return visualElement.unmount();\n    };\n  }, []);\n  var startAnimation = useConstant(function () {\n    return function (animationDefinition) {\n      return controls.start(animationDefinition);\n    };\n  });\n  return [animationState, startAnimation];\n}\n\nexport { AnimatePresence, AnimateSharedLayout, AnimationControls, DragControls, MotionContext, MotionPluginContext, MotionPlugins, MotionValue, PresenceContext, ReducedMotion, VisualElementAnimationControls, addScaleCorrection, animationControls, createMotionComponent, isValidMotionProp, motion, motionValue, resolveMotionValue, transform, useAnimatedState, useAnimation, useCycle, useDomEvent, useDragControls, useElementScroll, useExternalRef, useGestures, useInvertedScale, useIsPresent, useMotionValue, usePanGesture, usePresence, useReducedMotion, useSpring, useTapGesture, useTransform, useViewportScroll };","map":{"version":3,"sources":["C:/Users/zubin/Receiply/frontend/node_modules/framer-motion/dist/framer-motion.es.js"],"names":["__assign","__spreadArrays","__rest","__extends","sync","getFrameData","cancelSync","velocityPerSecond","mix","clamp","distance","progress","linear","linear$1","circOut","interpolate","wrap","invariant","warning","number","color","complex","px","percent","degrees","vw","vh","scale","alpha","progressPercentage","action","delay","tween","spring","keyframes","keyframes$1","inertia","easingLookup","cubicBezier","React__default","useRef","createContext","useContext","useEffect","createElement","useMemo","Component","forwardRef","Fragment","useCallback","useState","cloneElement","Children","isValidElement","useLayoutEffect","isRefObject","ref","hasOwnProperty","isFloat","value","isNaN","parseFloat","MotionValue","init","_this","timeDelta","lastUpdated","canTrackVelocity","updateAndNotify","v","render","prev","current","updateSubscribers","forEach","notifySubscriber","renderSubscribers","_a","delta","timestamp","postRender","scheduleVelocityCheck","subscriber","velocityCheck","set","prototype","subscribeTo","subscriptions","subscription","updateSubscriber","add","delete","onChange","Set","clearListeners","clear","onRenderRequest","attach","passiveEffect","get","getPrevious","getVelocity","start","animation","stop","Promise","resolve","stopAnimation","then","clearAnimation","isAnimating","destroy","motionValue","VisualElement","parent","children","latest","values","Map","valueSubscriptions","config","update","onUpdate","triggerRender","scheduleRender","element","mount","unmount","externalRef","treePath","depth","subscribe","child","hasValue","key","has","addValue","removeValue","subscribeToValue","unsubscribe","getValue","defaultValue","undefined","forEachValue","callback","getInstance","updateConfig","setSingleStaticValue","setStaticValues","unsubscribeOnChange","unsubscribeOnRender","removeFromParent","_","noop","any","convertBoundingBoxToAxisBox","top","left","right","bottom","x","min","max","y","convertAxisBoxToBoundingBox","transformBoundingBox","transformPoint","topLeft","bottomRight","axisBox","copyAxisBox","box","zeroDelta","translate","origin","originPoint","auto","test","parse","int","transform","Math","round","defaultValueTypes","backgroundColor","outlineColor","fill","stroke","borderColor","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor","borderWidth","borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth","borderRadius","radius","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","width","maxWidth","height","maxHeight","size","padding","paddingTop","paddingRight","paddingBottom","paddingLeft","margin","marginTop","marginRight","marginBottom","marginLeft","rotate","rotateX","rotateY","rotateZ","scaleX","scaleY","scaleZ","skew","skewX","skewY","translateX","translateY","translateZ","z","perspective","opacity","originX","originY","originZ","zIndex","fillOpacity","strokeOpacity","numOctaves","dimensionValueTypes","testValueType","type","findDimensionValueType","find","valueTypes","findValueType","getDefaultValueType","getValueAsType","axes","order","transformProps","operationKey","axesKey","push","sortTransformProps","a","b","indexOf","transformPropSet","isTransformProp","transformOriginProps","isTransformOriginProp","translateAlias","buildTransform","transformKeys","transformTemplate","transformIsDefault","enableHardwareAcceleration","allowTransformNone","transformString","transformHasZ","sort","numTransformKeys","length","i","trim","isCSSVariable","startsWith","pixelsToPercent","pixels","axis","correctBorderRadius","viewportBox","correctBoxShadow","_viewportBox","treeScale","shadow","template","createTransformer","xScale","yScale","averageScale","borderCorrectionDefinition","process","valueScaleCorrection","applyTo","boxShadow","addScaleCorrection","correctors","buildHTMLStyles","style","vars","transformOrigin","isLayoutProjectionEnabled","deltaFinal","targetBox","hasTransform","hasTransformOrigin","transformIsNone","valueType","valueAsType","default","bucket","corrected","num","layoutReprojection","resetAxis","originAxis","resetBox","originBox","scalePoint","point","distanceFromOrigin","scaled","applyPointDelta","boxScale","applyAxisDelta","applyBoxDelta","applyAxisTransforms","final","transforms","scaleKey","originKey","xKeys","yKeys","applyBoxTransforms","finalBox","removePointDelta","removeAxisDelta","removeAxisTransforms","removeBoxTransforms","applyTreeDeltas","treeLength","parent_1","clampProgress","isNear","target","maxDistance","calcTranslate","source","sourcePoint","targetPoint","calcOrigin","sourceLength","targetLength","updateAxisDelta","updateBoxDelta","eachAxis","handler","isKeyframesTarget","Array","isArray","underDampedSpring","stiffness","damping","restDelta","restSpeed","overDampedSpring","to","linearTween","ease","duration","defaultTransitions","getDefaultTransition","valueKey","transitionFactory","just","complete","easingDefinitionToFunction","definition","x1","y1","x2","y2","isEasingArray","isDurationAnimation","isAnimatable","secondsToMilliseconds","seconds","transitions","transitionOptionParser","opts","from","velocity","easings","map","isTransitionDefined","when","delayChildren","staggerChildren","staggerDirection","transition","Object","keys","getTransitionDefinition","transitionDefinition","valueTransitionDefinition","preprocessOptions","getAnimation","isOriginAnimatable","isTargetAnimatable","_b","actionFactory","repeatDelay","startAnimation","delay$1","activeAnimation","animationFactory","valueDelay","options","animate","getBoundingBox","transformPagePoint","getBoundingClientRect","HTMLVisualElement","_super","apply","arguments","defaultConfig","reactStyle","hasLayoutChildren","layoutUpdateListeners","hasViewportBoxUpdated","targetBoxFinal","stopLayoutAxisAnimation","isTargetBoxLocked","axisProgress","call","clean","read","getComputedStyle","readNativeValue","defaultValueType","enableLayoutProjection","forEachParent","hide","isVisible","show","onLayoutUpdate","layoutReady","listener","prevViewportBox","getBoundingBoxWithoutTransforms","bbox","window","snapshotBoundingBox","measureLayout","boxCorrected","refreshTargetBox","lockTargetBox","unlockTargetBox","stopLayoutAnimation","resetTransform","setAxisTarget","targetAxis","scheduleChildrenLayoutRender","startLayoutAxisAnimation","updateLayoutDeltas","isReactRender","p","onViewportBoxUpdate","build","visibility","assign","setProperty","useConstant","calcOrigin$1","offset","calcSVGTransformOrigin","dimensions","pxOriginX","pxOriginY","progressToPixels","dashKeys","array","camelKeys","buildSVGPath","attrs","totalLength","spacing","useDashCase","pathLength","pathSpacing","unmeasured","buildSVGAttrs","totalPathLength","attrX","attrY","_c","pathOffset","camelCaseAttributes","CAMEL_CASE_PATTERN","REPLACE_TEMPLATE","camelToDash","str","replace","toLowerCase","SVGVisualElement","measure","getBBox","e","isPath","getTotalLength","getAttribute","setAttribute","tagName","svgElements","svgTagNames","isSVGComponent","PresenceContext","usePresence","context","isPresent","onExitComplete","register","id","useUniqueId","safeToRemove","useIsPresent","counter","incrementId","useDomVisualElement","props","isStatic","visualElement","DOMVisualElement","layoutId","validMotionProps","isValidMotionProp","isPropValid","emotionIsPropValid_1","require","filterProps","domProps","buildHTMLProps","drag","htmlProps","userSelect","draggable","buildSVGProps","forwardedProps","visualProps","isCSSVariable$1","cssVariableRegex","parseCSSVariable","match","exec","token","fallback","maxDepth","getVariableValue","resolved","getPropertyValue","resolveCSSVariables","transitionEnd","HTMLElement","positionalKeys","isPositionalKey","hasPositionalKey","some","setAndResetVelocity","isNumOrPxType","BoundingBoxDimension","getPosFromMatrix","matrix","pos","split","getTranslateFromMatrix","pos2","pos3","_bbox","matrix3d","nonTranslationalTransformKeys","filter","removeNonTranslationalTransform","removedTransforms","positionalValues","convertChangedValueTypes","changedKeys","originBbox","elementComputedStyle","display","originComputedStyle","targetBbox","checkAndConvertChangedValueTypes","targetPositionalKeys","removedTransformValues","hasAttemptedToRemoveTransformValues","changedValueTypeKeys","fromType","toType","numKeyframes","convertedTarget","unitConversion","parseDomVariant","useInitialOrEveryRender","isInitialOnly","isInitialRender","AnimationControls","hasMounted","pendingAnimations","componentControls","setVariants","variants","controls","setDefaultTransition","defaultTransition","transitionOverride","animations_1","all","animationControls","MotionContext","static","isVariantLabel","isAnimationControls","useMotionContext","parentContext","initial","whileTap","whileHover","presenceContext","presenceId","isPresenceRoot","initialState","shouldPropagateControls","targetInitial","targetAnimate","initialDependency","animateDependency","isReducedMotion","initialToApply","checkShouldInheritVariant","inherit","isMotionValue","useMotionValues","empty","isTransform","existsAsProp","existsAsStyle","propIsMotionValue","styleIsMotionValue","transformRemoved","motionValueRemoved","addMotionValues","transformValues","isStyle","foundMotionValue","reservedNames","motion","isCustomValue","Boolean","toValue","resolveFinalValueInKeyframes","isNumericalString","getCurrent","isTargetResolver","isVariantLabels","VisualElementAnimationControls","makeTargetAnimatable","baseTarget","overrides","resolvedOverrides","activeOverrides","setProps","setValues","isActive","priority","_d","resolveVariant","targetValue","checkForNewValues","newValueKeys","numNewValues","readValue","getAnimatableNone","variant","custom","getHighestPriority","setOverride","overrideIndex","startOverride","override","clearOverride","highest","resetIsAnimating","highestOverride","overrideTarget","remainingValues","onStart","onComplete","applyVariantLabels","variantLabelList","reversedList","reverse","animateVariantLabels","animateVariant","animationDefinition","_e","getOrigin","animatable","animations","valueTarget","allAnimations","variantLabels","label","variantLabel","getAnimations","getChildrenAnimations","animateChildren","first","last","maxStaggerDuration","generateStaggerDuration","childControls","onAnimationStart","onAnimationComplete","checkOverrideIsAnimating","numOverrides","resolvedOverride","addChild","removeChild","resetChildren","getOriginFromTransition","valueTransition","useVisualElementAnimation","subscribeToParentControls","parentControls","unmountProps","MotionPluginContext","features","MotionPlugins","pluginContext","Provider","createLock","name","lock","openLock","globalHorizontalLock","globalVerticalLock","getGlobalLock","openHorizontal_1","openVertical_1","isViewportScrollBlocked","isBrowser","document","addEventListener","event","preventDefault","passive","blockViewportScroll","unblockViewportScroll","addDomEvent","eventName","removeEventListener","useDomEvent","isMouseEvent","PointerEvent","pointerType","MouseEvent","isTouchEvent","hasTouches","touches","filterPrimaryPointer","eventHandler","isPrimaryPointer","button","defaultPagePoint","pageX","pageY","pointFromTouch","pointType","primaryTouch","changedTouches","pointFromMouse","extractEventInfo","getViewportPointFromEvent","wrapHandler","shouldFilterPrimaryPointer","isBrowser$1","supportsPointerEvents","onpointerdown","supportsTouchEvents","ontouchstart","supportsMouseEvents","onmousedown","mouseEventNames","pointerdown","pointermove","pointerup","pointercancel","pointerover","pointerout","pointerenter","pointerleave","touchEventNames","getPointerEventName","addPointerEvent","usePointerEvent","Point","subtract","relativeTo","idOrElem","elem","getElem","getElementById","localElem","rect","scrollX","scrollY","PanSession","handlers","startEvent","lastMoveEvent","lastMoveEventInfo","updatePoint","info","getPanInfo","history","isPanStarted","isDistancePastThreshold","onMove","initialInfo","onSessionStart","removeOnPointerMove","handlePointerMove","removeOnPointerUp","handlePointerUp","removeListeners","buttons","end","onEnd","panInfo","updateHandlers","lastDevicePoint","startDevicePoint","getVelocity$1","timestampedPoint","lastPoint","time","currentVelocity","Infinity","applyConstraints","elastic","calcConstrainedMinPoint","constraints","calcRelativeAxisConstraints","calcRelativeConstraints","layoutBox","calcViewportAxisConstraints","layoutAxis","constraintsAxis","calcViewportConstraints","constraintsBox","calcPositionFromProgress","axisLength","elementDragControls","WeakMap","lastPointerEvent","VisualElementDragControls","isDragging","currentDirection","cursorProgress","openGlobalLock","panSession","originEvent","snapToCursor","stopMotion","dragPropagation","prepareBoundingBox","resolveDragConstraints","onDragStart","dragDirectionLock","getCurrentDirection","onDirectionLock","updateAxis","onDrag","dragConstraints","resolveRefConstraints","onMeasureDragConstraints","constraintsElement","measuredConstraints","userConstraints","cancelDrag","dragMomentum","dragElastic","onDragEnd","animateDragEnd","shouldDrag","axisLayout","updateProps","_f","_g","remainingProps","dragTransition","momentumAnimations","bounceStiffness","bounceDamping","timeConstant","onDragTransitionEnd","boxProgress","stopPointerListener","dragListener","stopResizeListener","stopLayoutUpdateListener","prevSnapshot","direction","lockThreshold","abs","useDrag","groupDragControls","dragControls","makeRenderlessComponent","hook","Drag","shouldRender","useUnmountEffect","usePanGesture","onPan","onPanStart","onPanEnd","onPanSessionStart","hasPanEvents","onPointerDown","isNodeOrChild","parentElement","order$1","getGesturePriority","gesture","tapGesturePriority","useTapGesture","onTap","onTapStart","onTapCancel","hasTapListeners","isTapping","cancelPointerEventListener","removePointerUp","onPointerUp","openGestureLock","hoverPriority","filterTouch","useHoverGesture","onHoverStart","onHoverEnd","useGestures","gestureProps","Gestures","Exit","exit","isPlayingExitAnimation","AnimatePropType","shallowCompare","next","prevLength","hasUpdated","targetWithoutTransition","mergeTransitionEnd","useAnimateProp","targetAndTransition","prevValues","targetToAnimate","animatingTarget","finalTarget","shouldAnimateOnMount","isValidValue","valueHasUpdated","labelsToArray","resolveVariantLabels","unresolvedVariant","asDependencyList","list","join","hasVariantChanged","oldVariant","newVariant","useVariants","targetVariants","parentAlreadyMounted","shouldAnimate","useAnimationGroupSubscription","AnimatePropComponents","Target","VariantLabel","AnimationSubscription","isVariantLabel$1","prop","isAnimationSubscription","animationProps","animatePropTypeTests","getAnimationComponent","animatePropType","tweenAxis","Presence","VisibilityAction","progressTarget","Animate","frameTarget","stopAxisAnimation","visibilityAction","layout","boxHasMoved","hasMoved","Hide","animateAxis","onLayoutAnimationComplete","presence","Present","componentDidMount","unsubLayoutReady","componentWillUnmount","crossfadeOpacity","layoutProgress","crossfade","createCrossfadeAnimation","frame","unsubscribeProgress","easeCrossfadeIn","easeCrossfadeOut","AnimateLayout","hasAxisMoved","compress","easing","defaultHandler","sortByDepth","createBatcher","queue","flush","isSharedLayout","forceUpdate","SharedLayoutContext","Measure","syncLayout","componentDidUpdate","getSnapshotBeforeUpdate","syncUpdate","MeasureLayout","defaultFeatures","useFeatures","shouldInheritVariant","plugins","allFeatures","numFeatures","Animation","localContext","useSnapshotOnUnmount","remove","createMotionComponent","useVisualElement","animationControlsConfig","MotionComponent","component","componentCache","Proxy","useForceUpdate","forcedRenderCount","setForcedRenderCount","getPresenceId","PresenceChild","presenceChildren","newChildrenMap","childId","allComplete","isComplete","getChildKey","updateChildLookup","allChildren","seenChildren","env","NODE_ENV","console","warn","onlyElements","filtered","AnimatePresence","exitBeforeEnter","forceRender","layoutContext","filteredChildren","presentChildren","exiting","childrenToRender","presentKeys","targetKeys","numPresent","insertionIndex","onExit","removeIndex","findIndex","presentChild","splice","createSwitchAnimation","stack","lead","Entering","prevLead","Show","getFollowOrigin","Exiting","getFollowTarget","stackLead","stackLeadPresence","follow","getLeadTransition","getLeadTarget","getLeadOrigin","findLeadAndFollow","prevFollow","leadIndex","numInStack","lastIsPresent","isLastInStack","stackChild","LayoutStack","hasChildren","layoutOrder","index","snapshot","boundingBox","latestMotionValues","updateLeadAndFollow","updateSnapshot","isLeadPresent","shouldStackAnimate","AnimateSharedLayout","stacks","updateScheduled","renderScheduled","syncContext","force","scheduleUpdate","updateStacks","startLayoutAnimation","shouldComponentUpdate","createAnimation","getStack","addToStack","removeFromStack","useMotionValue","resolveMotionValue","unwrappedValue","isCustomValueType","getMixer","args","_i","useImmediate","argOffset","inputValue","inputRange","outputRange","interpolator","mixer","isTransformer","useTransform","customTransform","comparitor","transformer","initialValue","maxScale","invertScale","useInvertedScale","parentScaleX","parentScaleY","useOnChange","useSpring","activeSpringAnimation","createScrollMotionValues","scrollXProgress","scrollYProgress","setProgress","maxOffset","createScrollUpdater","getOffsets","xOffset","yOffset","xMaxOffset","yMaxOffset","isBrowser$2","useIsomorphicLayoutEffect","getElementScrollOffsets","scrollLeft","scrollTop","scrollWidth","offsetWidth","scrollHeight","offsetHeight","useElementScroll","updateScrollValues","scrollListener","resizeListener","viewportScrollValues","getViewportScrollOffsets","pageXOffset","pageYOffset","body","clientWidth","innerWidth","clientHeight","innerHeight","hasListeners","addEventListeners","useViewportScroll","useAnimation","useCycle","items","item","setItem","prefersReducedMotion","matchMedia","motionMediaQuery_1","setReducedMotionPreferences","matches","addListener","determineShouldReduceMotion","prefersReduced","useReducedMotion","shouldReduceMotion","setShouldReduceMotion","ReducedMotion","enabled","DragControls","nativeEvent","createDragControls","useDragControls","useExternalRef","StateVisualElement","useAnimatedState","animationState","setAnimationState"],"mappings":"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","sourcesContent":["import { __assign, __spreadArrays, __rest, __extends } from 'tslib';\r\nimport sync, { getFrameData, cancelSync } from 'framesync';\r\nimport { velocityPerSecond, mix, clamp, distance, progress, linear as linear$1, circOut, interpolate, wrap } from '@popmotion/popcorn';\r\nimport { invariant, warning } from 'hey-listen';\r\nimport { number, color, complex, px, percent, degrees, vw, vh, scale, alpha, progressPercentage } from 'style-value-types';\r\nimport { action, delay, tween, spring, keyframes as keyframes$1, inertia } from 'popmotion';\r\nimport * as easingLookup from '@popmotion/easing';\r\nimport { cubicBezier, linear } from '@popmotion/easing';\r\nimport React__default, { useRef, createContext, useContext, useEffect, createElement, useMemo, Component, forwardRef, Fragment, useCallback, useState, cloneElement, Children, isValidElement, useLayoutEffect } from 'react';\r\n\r\nvar isRefObject = function (ref) {\r\n    return typeof ref === \"object\" && ref.hasOwnProperty(\"current\");\r\n};\r\n\r\nvar isFloat = function (value) {\r\n    return !isNaN(parseFloat(value));\r\n};\r\n/**\r\n * `MotionValue` is used to track the state and velocity of motion values.\r\n *\r\n * @public\r\n */\r\nvar MotionValue = /** @class */ (function () {\r\n    /**\r\n     * @param init - The initiating value\r\n     * @param config - Optional configuration options\r\n     *\r\n     * -  `transformer`: A function to transform incoming values with.\r\n     *\r\n     * @internal\r\n     */\r\n    function MotionValue(init) {\r\n        var _this = this;\r\n        /**\r\n         * Duration, in milliseconds, since last updating frame.\r\n         *\r\n         * @internal\r\n         */\r\n        this.timeDelta = 0;\r\n        /**\r\n         * Timestamp of the last time this `MotionValue` was updated.\r\n         *\r\n         * @internal\r\n         */\r\n        this.lastUpdated = 0;\r\n        /**\r\n         * Tracks whether this value can output a velocity. Currently this is only true\r\n         * if the value is numerical, but we might be able to widen the scope here and support\r\n         * other value types.\r\n         *\r\n         * @internal\r\n         */\r\n        this.canTrackVelocity = false;\r\n        this.updateAndNotify = function (v, render) {\r\n            if (render === void 0) { render = true; }\r\n            _this.prev = _this.current;\r\n            _this.current = v;\r\n            if (_this.updateSubscribers && _this.prev !== _this.current) {\r\n                _this.updateSubscribers.forEach(_this.notifySubscriber);\r\n            }\r\n            if (render && _this.renderSubscribers) {\r\n                _this.renderSubscribers.forEach(_this.notifySubscriber);\r\n            }\r\n            // Update timestamp\r\n            var _a = getFrameData(), delta = _a.delta, timestamp = _a.timestamp;\r\n            if (_this.lastUpdated !== timestamp) {\r\n                _this.timeDelta = delta;\r\n                _this.lastUpdated = timestamp;\r\n                sync.postRender(_this.scheduleVelocityCheck);\r\n            }\r\n        };\r\n        /**\r\n         * Notify a subscriber with the latest value.\r\n         *\r\n         * This is an instanced and bound function to prevent generating a new\r\n         * function once per frame.\r\n         *\r\n         * @param subscriber - The subscriber to notify.\r\n         *\r\n         * @internal\r\n         */\r\n        this.notifySubscriber = function (subscriber) {\r\n            subscriber(_this.current);\r\n        };\r\n        /**\r\n         * Schedule a velocity check for the next frame.\r\n         *\r\n         * This is an instanced and bound function to prevent generating a new\r\n         * function once per frame.\r\n         *\r\n         * @internal\r\n         */\r\n        this.scheduleVelocityCheck = function () { return sync.postRender(_this.velocityCheck); };\r\n        /**\r\n         * Updates `prev` with `current` if the value hasn't been updated this frame.\r\n         * This ensures velocity calculations return `0`.\r\n         *\r\n         * This is an instanced and bound function to prevent generating a new\r\n         * function once per frame.\r\n         *\r\n         * @internal\r\n         */\r\n        this.velocityCheck = function (_a) {\r\n            var timestamp = _a.timestamp;\r\n            if (timestamp !== _this.lastUpdated) {\r\n                _this.prev = _this.current;\r\n            }\r\n        };\r\n        this.set(init, false);\r\n        this.canTrackVelocity = isFloat(this.current);\r\n    }\r\n    /**\r\n     * Subscribes a subscriber function to a subscription list.\r\n     *\r\n     * @param subscriptions - A `Set` of subscribers.\r\n     * @param subscription - A subscriber function.\r\n     */\r\n    MotionValue.prototype.subscribeTo = function (subscriptions, subscription) {\r\n        var _this = this;\r\n        var updateSubscriber = function () { return subscription(_this.current); };\r\n        subscriptions.add(updateSubscriber);\r\n        return function () { return subscriptions.delete(updateSubscriber); };\r\n    };\r\n    /**\r\n     * Adds a function that will be notified when the `MotionValue` is updated.\r\n     *\r\n     * It returns a function that, when called, will cancel the subscription.\r\n     *\r\n     * When calling `onChange` inside a React component, it should be wrapped with the\r\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\r\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\r\n     *\r\n     * @library\r\n     *\r\n     * ```jsx\r\n     * function MyComponent() {\r\n     *   const x = useMotionValue(0)\r\n     *   const y = useMotionValue(0)\r\n     *   const opacity = useMotionValue(1)\r\n     *\r\n     *   useEffect(() => {\r\n     *     function updateOpacity() {\r\n     *       const maxXY = Math.max(x.get(), y.get())\r\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\r\n     *       opacity.set(newOpacity)\r\n     *     }\r\n     *\r\n     *     const unsubscribeX = x.onChange(updateOpacity)\r\n     *     const unsubscribeY = y.onChange(updateOpacity)\r\n     *\r\n     *     return () => {\r\n     *       unsubscribeX()\r\n     *       unsubscribeY()\r\n     *     }\r\n     *   }, [])\r\n     *\r\n     *   return <Frame x={x} />\r\n     * }\r\n     * ```\r\n     *\r\n     * @motion\r\n     *\r\n     * ```jsx\r\n     * export const MyComponent = () => {\r\n     *   const x = useMotionValue(0)\r\n     *   const y = useMotionValue(0)\r\n     *   const opacity = useMotionValue(1)\r\n     *\r\n     *   useEffect(() => {\r\n     *     function updateOpacity() {\r\n     *       const maxXY = Math.max(x.get(), y.get())\r\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\r\n     *       opacity.set(newOpacity)\r\n     *     }\r\n     *\r\n     *     const unsubscribeX = x.onChange(updateOpacity)\r\n     *     const unsubscribeY = y.onChange(updateOpacity)\r\n     *\r\n     *     return () => {\r\n     *       unsubscribeX()\r\n     *       unsubscribeY()\r\n     *     }\r\n     *   }, [])\r\n     *\r\n     *   return <motion.div style={{ x }} />\r\n     * }\r\n     * ```\r\n     *\r\n     * @internalremarks\r\n     *\r\n     * We could look into a `useOnChange` hook if the above lifecycle management proves confusing.\r\n     *\r\n     * ```jsx\r\n     * useOnChange(x, () => {})\r\n     * ```\r\n     *\r\n     * @param subscriber - A function that receives the latest value.\r\n     * @returns A function that, when called, will cancel this subscription.\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.onChange = function (subscription) {\r\n        if (!this.updateSubscribers)\r\n            this.updateSubscribers = new Set();\r\n        return this.subscribeTo(this.updateSubscribers, subscription);\r\n    };\r\n    MotionValue.prototype.clearListeners = function () {\r\n        var _a;\r\n        (_a = this.updateSubscribers) === null || _a === void 0 ? void 0 : _a.clear();\r\n    };\r\n    /**\r\n     * Adds a function that will be notified when the `MotionValue` requests a render.\r\n     *\r\n     * @param subscriber - A function that's provided the latest value.\r\n     * @returns A function that, when called, will cancel this subscription.\r\n     *\r\n     * @internal\r\n     */\r\n    MotionValue.prototype.onRenderRequest = function (subscription) {\r\n        if (!this.renderSubscribers)\r\n            this.renderSubscribers = new Set();\r\n        // Render immediately\r\n        this.notifySubscriber(subscription);\r\n        return this.subscribeTo(this.renderSubscribers, subscription);\r\n    };\r\n    /**\r\n     * Attaches a passive effect to the `MotionValue`.\r\n     *\r\n     * @internal\r\n     */\r\n    MotionValue.prototype.attach = function (passiveEffect) {\r\n        this.passiveEffect = passiveEffect;\r\n    };\r\n    /**\r\n     * Sets the state of the `MotionValue`.\r\n     *\r\n     * @remarks\r\n     *\r\n     * ```jsx\r\n     * const x = useMotionValue(0)\r\n     * x.set(10)\r\n     * ```\r\n     *\r\n     * @param latest - Latest value to set.\r\n     * @param render - Whether to notify render subscribers. Defaults to `true`\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.set = function (v, render) {\r\n        if (render === void 0) { render = true; }\r\n        if (!render || !this.passiveEffect) {\r\n            this.updateAndNotify(v, render);\r\n        }\r\n        else {\r\n            this.passiveEffect(v, this.updateAndNotify);\r\n        }\r\n    };\r\n    /**\r\n     * Returns the latest state of `MotionValue`\r\n     *\r\n     * @returns - The latest state of `MotionValue`\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.get = function () {\r\n        return this.current;\r\n    };\r\n    /**\r\n     * @public\r\n     */\r\n    MotionValue.prototype.getPrevious = function () {\r\n        return this.prev;\r\n    };\r\n    /**\r\n     * Returns the latest velocity of `MotionValue`\r\n     *\r\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.getVelocity = function () {\r\n        // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\r\n        return this.canTrackVelocity\r\n            ? // These casts could be avoided if parseFloat would be typed better\r\n                velocityPerSecond(parseFloat(this.current) -\r\n                    parseFloat(this.prev), this.timeDelta)\r\n            : 0;\r\n    };\r\n    /**\r\n     * Registers a new animation to control this `MotionValue`. Only one\r\n     * animation can drive a `MotionValue` at one time.\r\n     *\r\n     * ```jsx\r\n     * value.start()\r\n     * ```\r\n     *\r\n     * @param animation - A function that starts the provided animation\r\n     *\r\n     * @internal\r\n     */\r\n    MotionValue.prototype.start = function (animation) {\r\n        var _this = this;\r\n        this.stop();\r\n        return new Promise(function (resolve) {\r\n            _this.stopAnimation = animation(resolve);\r\n        }).then(function () { return _this.clearAnimation(); });\r\n    };\r\n    /**\r\n     * Stop the currently active animation.\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.stop = function () {\r\n        if (this.stopAnimation)\r\n            this.stopAnimation();\r\n        this.clearAnimation();\r\n    };\r\n    /**\r\n     * Returns `true` if this value is currently animating.\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.isAnimating = function () {\r\n        return !!this.stopAnimation;\r\n    };\r\n    MotionValue.prototype.clearAnimation = function () {\r\n        this.stopAnimation = null;\r\n    };\r\n    /**\r\n     * Destroy and clean up subscribers to this `MotionValue`.\r\n     *\r\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\r\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\r\n     * created a `MotionValue` via the `motionValue` function.\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.destroy = function () {\r\n        this.updateSubscribers && this.updateSubscribers.clear();\r\n        this.renderSubscribers && this.renderSubscribers.clear();\r\n        this.stop();\r\n    };\r\n    return MotionValue;\r\n}());\r\n/**\r\n * @internal\r\n */\r\nfunction motionValue(init) {\r\n    return new MotionValue(init);\r\n}\r\n\r\n/**\r\n * VisualElement is an abstract class that provides a generic animation-optimised interface to the\r\n * underlying renderer.\r\n *\r\n * Currently many features interact directly with HTMLVisualElement/SVGVisualElement\r\n * but the idea is we can create, for instance, a ThreeVisualElement that extends\r\n * VisualElement and we can quickly offer all the same features.\r\n */\r\nvar VisualElement = /** @class */ (function () {\r\n    function VisualElement(parent, ref) {\r\n        var _this = this;\r\n        // An iterable list of current children\r\n        this.children = new Set();\r\n        // The latest resolved MotionValues\r\n        this.latest = {};\r\n        // A map of MotionValues used to animate this element\r\n        this.values = new Map();\r\n        // Unsubscription callbacks for each MotionValue\r\n        this.valueSubscriptions = new Map();\r\n        // A configuration for this VisualElement, each derived class can extend this.\r\n        this.config = {};\r\n        // A pre-bound call to the user-provided `onUpdate` callback. This won't\r\n        // be called more than once per frame.\r\n        this.update = function () { return _this.config.onUpdate(_this.latest); };\r\n        // Pre-bound version of render\r\n        this.triggerRender = function () { return _this.render(); };\r\n        this.scheduleRender = function () { return sync.render(_this.triggerRender, false, true); };\r\n        // This function gets passed to the rendered component's `ref` prop\r\n        // and is used to mount/unmount the VisualElement\r\n        this.ref = function (element) {\r\n            element ? _this.mount(element) : _this.unmount();\r\n            if (!_this.externalRef)\r\n                return;\r\n            if (typeof _this.externalRef === \"function\") {\r\n                _this.externalRef(element);\r\n            }\r\n            else if (isRefObject(_this.externalRef)) {\r\n                _this.externalRef.current = element;\r\n            }\r\n        };\r\n        // Create a relationship with the provided parent. When we come to replace\r\n        // the auto-animation stuff with VisualElement we might need to make this\r\n        // relationship two-way\r\n        this.parent = parent;\r\n        this.treePath = parent ? __spreadArrays(parent.treePath, [parent]) : [];\r\n        // Calculate the depth of this node in the VisualElement graph\r\n        this.depth = parent ? parent.depth + 1 : 0;\r\n        // A reference to any externally-defined React ref. This might live better\r\n        // outside the VisualElement and be handled in a hook.\r\n        this.externalRef = ref;\r\n    }\r\n    VisualElement.prototype.subscribe = function (child) {\r\n        var _this = this;\r\n        this.children.add(child);\r\n        return function () { return _this.children.delete(child); };\r\n    };\r\n    // Check whether this element has a MotionValue of the provided key\r\n    VisualElement.prototype.hasValue = function (key) {\r\n        return this.values.has(key);\r\n    };\r\n    // Add a MotionValue\r\n    VisualElement.prototype.addValue = function (key, value) {\r\n        if (this.hasValue(key))\r\n            this.removeValue(key);\r\n        this.values.set(key, value);\r\n        this.latest[key] = value.get();\r\n        if (this.element)\r\n            this.subscribeToValue(key, value);\r\n    };\r\n    // Remove a MotionValue\r\n    VisualElement.prototype.removeValue = function (key) {\r\n        var unsubscribe = this.valueSubscriptions.get(key);\r\n        unsubscribe && unsubscribe();\r\n        this.values.delete(key);\r\n        delete this.latest[key];\r\n        this.valueSubscriptions.delete(key);\r\n    };\r\n    VisualElement.prototype.getValue = function (key, defaultValue) {\r\n        var value = this.values.get(key);\r\n        if (value === undefined && defaultValue !== undefined) {\r\n            value = new MotionValue(defaultValue);\r\n            this.addValue(key, value);\r\n        }\r\n        return value;\r\n    };\r\n    // Iterate over all MotionValues\r\n    VisualElement.prototype.forEachValue = function (callback) {\r\n        this.values.forEach(callback);\r\n    };\r\n    // Get the underlying rendered instance of this VisualElement. For instance in\r\n    // HTMLVisualElement this will be a HTMLElement.\r\n    VisualElement.prototype.getInstance = function () {\r\n        return this.element;\r\n    };\r\n    VisualElement.prototype.updateConfig = function (config) {\r\n        if (config === void 0) { config = {}; }\r\n        this.config = __assign({}, config);\r\n    };\r\n    // Set a single `latest` value\r\n    VisualElement.prototype.setSingleStaticValue = function (key, value) {\r\n        this.latest[key] = value;\r\n    };\r\n    // Statically set values to `latest` without needing a MotionValue\r\n    VisualElement.prototype.setStaticValues = function (values, value) {\r\n        if (typeof values === \"string\") {\r\n            this.setSingleStaticValue(values, value);\r\n        }\r\n        else {\r\n            for (var key in values) {\r\n                this.setSingleStaticValue(key, values[key]);\r\n            }\r\n        }\r\n    };\r\n    // Subscribe to changes in a MotionValue\r\n    VisualElement.prototype.subscribeToValue = function (key, value) {\r\n        var _this = this;\r\n        var onChange = function (latest) {\r\n            _this.setSingleStaticValue(key, latest);\r\n            _this.latest[key] = latest;\r\n            _this.config.onUpdate && sync.update(_this.update, false, true);\r\n        };\r\n        var unsubscribeOnChange = value.onChange(onChange);\r\n        var unsubscribeOnRender = value.onRenderRequest(this.scheduleRender);\r\n        this.valueSubscriptions.set(key, function () {\r\n            unsubscribeOnChange();\r\n            unsubscribeOnRender();\r\n        });\r\n    };\r\n    // Mount the VisualElement with the actual DOM element\r\n    VisualElement.prototype.mount = function (element) {\r\n        var _this = this;\r\n        invariant(!!element, \"No ref found. Ensure components created with motion.custom forward refs using React.forwardRef\");\r\n        if (this.parent) {\r\n            this.removeFromParent = this.parent.subscribe(this);\r\n            /**\r\n             * Save a reference to the nearest layout projecting ancestor.\r\n             */\r\n            // this.layoutParent = this.parent.isLayoutProjectionEnabled\r\n            //     ? this.parent\r\n            //     : this.parent.layoutParent\r\n        }\r\n        /**\r\n         * Save the element to this.element as a semantic API, this.current to the VisualElement\r\n         * is compatible with existing RefObject APIs.\r\n         */\r\n        this.element = this.current = element;\r\n        // Subscribe to any pre-existing MotionValues\r\n        this.forEachValue(function (value, key) { return _this.subscribeToValue(key, value); });\r\n    };\r\n    // Unmount the VisualElement and cancel any scheduled updates\r\n    VisualElement.prototype.unmount = function () {\r\n        var _this = this;\r\n        this.forEachValue(function (_, key) { return _this.removeValue(key); });\r\n        cancelSync.update(this.update);\r\n        cancelSync.render(this.render);\r\n        this.removeFromParent && this.removeFromParent();\r\n    };\r\n    return VisualElement;\r\n}());\r\n\r\nfunction noop(any) {\r\n    return any;\r\n}\r\n\r\n/**\r\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\r\n * it's easier to consider each axis individually. This function returns a bounding box\r\n * as a map of single-axis min/max values.\r\n */\r\nfunction convertBoundingBoxToAxisBox(_a) {\r\n    var top = _a.top, left = _a.left, right = _a.right, bottom = _a.bottom;\r\n    return {\r\n        x: { min: left, max: right },\r\n        y: { min: top, max: bottom },\r\n    };\r\n}\r\nfunction convertAxisBoxToBoundingBox(_a) {\r\n    var x = _a.x, y = _a.y;\r\n    return {\r\n        top: y.min,\r\n        bottom: y.max,\r\n        left: x.min,\r\n        right: x.max,\r\n    };\r\n}\r\n/**\r\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\r\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\r\n * when measuring DOM elements and DOM event points.\r\n */\r\nfunction transformBoundingBox(_a, transformPoint) {\r\n    var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;\r\n    if (transformPoint === void 0) { transformPoint = noop; }\r\n    var topLeft = transformPoint({ x: left, y: top });\r\n    var bottomRight = transformPoint({ x: right, y: bottom });\r\n    return {\r\n        top: topLeft.y,\r\n        left: topLeft.x,\r\n        bottom: bottomRight.y,\r\n        right: bottomRight.x,\r\n    };\r\n}\r\n/**\r\n * Create an empty axis box of zero size\r\n */\r\nfunction axisBox() {\r\n    return { x: { min: 0, max: 1 }, y: { min: 0, max: 1 } };\r\n}\r\nfunction copyAxisBox(box) {\r\n    return {\r\n        x: __assign({}, box.x),\r\n        y: __assign({}, box.y),\r\n    };\r\n}\r\n/**\r\n * Create an empty box delta\r\n */\r\nvar zeroDelta = {\r\n    translate: 0,\r\n    scale: 1,\r\n    origin: 0,\r\n    originPoint: 0,\r\n};\r\nfunction delta() {\r\n    return {\r\n        x: __assign({}, zeroDelta),\r\n        y: __assign({}, zeroDelta),\r\n    };\r\n}\r\n\r\n/**\r\n * ValueType for \"auto\"\r\n */\r\nvar auto = {\r\n    test: function (v) { return v === \"auto\"; },\r\n    parse: function (v) { return v; },\r\n};\r\n/**\r\n * ValueType for ints\r\n */\r\nvar int = __assign(__assign({}, number), { transform: Math.round });\r\n/**\r\n * A map of default value types for common values\r\n */\r\nvar defaultValueTypes = {\r\n    // Color props\r\n    color: color,\r\n    backgroundColor: color,\r\n    outlineColor: color,\r\n    fill: color,\r\n    stroke: color,\r\n    // Border props\r\n    borderColor: color,\r\n    borderTopColor: color,\r\n    borderRightColor: color,\r\n    borderBottomColor: color,\r\n    borderLeftColor: color,\r\n    borderWidth: px,\r\n    borderTopWidth: px,\r\n    borderRightWidth: px,\r\n    borderBottomWidth: px,\r\n    borderLeftWidth: px,\r\n    borderRadius: px,\r\n    radius: px,\r\n    borderTopLeftRadius: px,\r\n    borderTopRightRadius: px,\r\n    borderBottomRightRadius: px,\r\n    borderBottomLeftRadius: px,\r\n    // Positioning props\r\n    width: px,\r\n    maxWidth: px,\r\n    height: px,\r\n    maxHeight: px,\r\n    size: px,\r\n    top: px,\r\n    right: px,\r\n    bottom: px,\r\n    left: px,\r\n    // Spacing props\r\n    padding: px,\r\n    paddingTop: px,\r\n    paddingRight: px,\r\n    paddingBottom: px,\r\n    paddingLeft: px,\r\n    margin: px,\r\n    marginTop: px,\r\n    marginRight: px,\r\n    marginBottom: px,\r\n    marginLeft: px,\r\n    // Transform props\r\n    rotate: degrees,\r\n    rotateX: degrees,\r\n    rotateY: degrees,\r\n    rotateZ: degrees,\r\n    scale: scale,\r\n    scaleX: scale,\r\n    scaleY: scale,\r\n    scaleZ: scale,\r\n    skew: degrees,\r\n    skewX: degrees,\r\n    skewY: degrees,\r\n    distance: px,\r\n    translateX: px,\r\n    translateY: px,\r\n    translateZ: px,\r\n    x: px,\r\n    y: px,\r\n    z: px,\r\n    perspective: px,\r\n    opacity: alpha,\r\n    originX: progressPercentage,\r\n    originY: progressPercentage,\r\n    originZ: px,\r\n    // Misc\r\n    zIndex: int,\r\n    // SVG\r\n    fillOpacity: alpha,\r\n    strokeOpacity: alpha,\r\n    numOctaves: int,\r\n};\r\n/**\r\n * A list of value types commonly used for dimensions\r\n */\r\nvar dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\r\n/**\r\n * Tests a provided value against a ValueType\r\n */\r\nvar testValueType = function (v) { return function (type) { return type.test(v); }; };\r\n/**\r\n * Tests a dimensional value against the list of dimension ValueTypes\r\n */\r\nvar findDimensionValueType = function (v) {\r\n    return dimensionValueTypes.find(testValueType(v));\r\n};\r\n/**\r\n * A list of all ValueTypes\r\n */\r\nvar valueTypes = __spreadArrays(dimensionValueTypes, [color, complex]);\r\n/**\r\n * Tests a value against the list of ValueTypes\r\n */\r\nvar findValueType = function (v) { return valueTypes.find(testValueType(v)); };\r\n/**\r\n * Gets the default ValueType for the provided value key\r\n */\r\nvar getDefaultValueType = function (key) { return defaultValueTypes[key]; };\r\n/**\r\n * Provided a value and a ValueType, returns the value as that value type.\r\n */\r\nvar getValueAsType = function (value, type) {\r\n    return type && typeof value === \"number\"\r\n        ? type.transform(value)\r\n        : value;\r\n};\r\n\r\n/**\r\n * A list of all transformable axes. We'll use this list to generated a version\r\n * of each axes for each transform.\r\n */\r\nvar axes = [\"\", \"X\", \"Y\", \"Z\"];\r\n/**\r\n * An ordered array of each transformable value. By default, transform values\r\n * will be sorted to this order.\r\n */\r\nvar order = [\"translate\", \"scale\", \"rotate\", \"skew\", \"transformPerspective\"];\r\n/**\r\n * Generate a list of every possible transform key.\r\n */\r\nvar transformProps = [\"x\", \"y\", \"z\"];\r\norder.forEach(function (operationKey) {\r\n    axes.forEach(function (axesKey) { return transformProps.push(operationKey + axesKey); });\r\n});\r\n/**\r\n * A function to use with Array.sort to sort transform keys by their default order.\r\n */\r\nfunction sortTransformProps(a, b) {\r\n    return transformProps.indexOf(a) - transformProps.indexOf(b);\r\n}\r\n/**\r\n * A quick lookup for transform props.\r\n */\r\nvar transformPropSet = new Set(transformProps);\r\nfunction isTransformProp(key) {\r\n    return transformPropSet.has(key);\r\n}\r\n/**\r\n * A quick lookup for transform origin props\r\n */\r\nvar transformOriginProps = new Set([\"originX\", \"originY\", \"originZ\"]);\r\nfunction isTransformOriginProp(key) {\r\n    return transformOriginProps.has(key);\r\n}\r\n\r\nvar translateAlias = {\r\n    x: \"translateX\",\r\n    y: \"translateY\",\r\n    z: \"translateZ\",\r\n};\r\n/**\r\n * Build a CSS transform style from individual x/y/scale etc properties.\r\n *\r\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\r\n * providing a transformTemplate function.\r\n */\r\nfunction buildTransform(transform, transformKeys, transformTemplate, transformIsDefault, enableHardwareAcceleration, allowTransformNone) {\r\n    if (enableHardwareAcceleration === void 0) { enableHardwareAcceleration = true; }\r\n    if (allowTransformNone === void 0) { allowTransformNone = true; }\r\n    // The transform string we're going to build into\r\n    var transformString = \"\";\r\n    // Track whether the defined transform has a defined z so we don't add a\r\n    // second to enable hardware acceleration\r\n    var transformHasZ = false;\r\n    // Transform keys into their default order - this will determine the output order.\r\n    transformKeys.sort(sortTransformProps);\r\n    // Loop over each transform and build them into transformString\r\n    var numTransformKeys = transformKeys.length;\r\n    for (var i = 0; i < numTransformKeys; i++) {\r\n        var key = transformKeys[i];\r\n        transformString += (translateAlias[key] || key) + \"(\" + transform[key] + \") \";\r\n        if (key === \"z\")\r\n            transformHasZ = true;\r\n    }\r\n    if (!transformHasZ && enableHardwareAcceleration) {\r\n        transformString += \"translateZ(0)\";\r\n    }\r\n    else {\r\n        transformString = transformString.trim();\r\n    }\r\n    // If we have a custom `transform` template, pass our transform values and\r\n    // generated transformString to that before returning\r\n    if (transformTemplate) {\r\n        transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\r\n    }\r\n    else if (allowTransformNone && transformIsDefault) {\r\n        transformString = \"none\";\r\n    }\r\n    return transformString;\r\n}\r\n\r\n/**\r\n * Returns true if the provided key is a CSS variable\r\n */\r\nfunction isCSSVariable(key) {\r\n    return key.startsWith(\"--\");\r\n}\r\n\r\nfunction pixelsToPercent(pixels, axis) {\r\n    return (pixels / (axis.max - axis.min)) * 100;\r\n}\r\n/**\r\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\r\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\r\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\r\n * borderRadius in both states. If we animate between the two in pixels that will trigger\r\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\r\n */\r\nfunction correctBorderRadius(latest, viewportBox) {\r\n    /**\r\n     * If latest is a string, we either presume it's already a percentage, in which case it'll\r\n     * already be stretched appropriately, or it's another value type which we don't support.\r\n     */\r\n    if (typeof latest !== \"number\")\r\n        return latest;\r\n    /**\r\n     * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\r\n     * pixel value as a percentage of each axis\r\n     */\r\n    var x = pixelsToPercent(latest, viewportBox.x);\r\n    var y = pixelsToPercent(latest, viewportBox.y);\r\n    return x + \"% \" + y + \"%\";\r\n}\r\nfunction correctBoxShadow(latest, _viewportBox, delta, treeScale) {\r\n    // GC Warning - this creates a function and object every frame\r\n    var shadow = complex.parse(latest);\r\n    var template = complex.createTransformer(latest);\r\n    // Calculate the overall context scale\r\n    var xScale = delta.x.scale * treeScale.x;\r\n    var yScale = delta.y.scale * treeScale.y;\r\n    // Scale x/y\r\n    shadow[1] /= xScale;\r\n    shadow[2] /= yScale;\r\n    /**\r\n     * Ideally we'd correct x and y scales individually, but because blur and\r\n     * spread apply to both we have to take a scale average and apply that instead.\r\n     * We could potentially improve the outcome of this by incorporating the ratio between\r\n     * the two scales.\r\n     */\r\n    var averageScale = mix(xScale, yScale, 0.5);\r\n    // Blur\r\n    if (typeof shadow[3] === \"number\")\r\n        shadow[3] /= averageScale;\r\n    // Spread\r\n    if (typeof shadow[4] === \"number\")\r\n        shadow[4] /= averageScale;\r\n    return template(shadow);\r\n}\r\nvar borderCorrectionDefinition = {\r\n    process: correctBorderRadius,\r\n};\r\nvar valueScaleCorrection = {\r\n    borderRadius: __assign(__assign({}, borderCorrectionDefinition), { applyTo: [\r\n            \"borderTopLeftRadius\",\r\n            \"borderTopRightRadius\",\r\n            \"borderBottomLeftRadius\",\r\n            \"borderBottomRightRadius\",\r\n        ] }),\r\n    borderTopLeftRadius: borderCorrectionDefinition,\r\n    borderTopRightRadius: borderCorrectionDefinition,\r\n    borderBottomLeftRadius: borderCorrectionDefinition,\r\n    borderBottomRightRadius: borderCorrectionDefinition,\r\n    boxShadow: {\r\n        process: correctBoxShadow,\r\n    },\r\n};\r\n/**\r\n * @internal\r\n */\r\nfunction addScaleCorrection(correctors) {\r\n    for (var key in correctors) {\r\n        valueScaleCorrection[key] = correctors[key];\r\n    }\r\n}\r\n\r\n/**\r\n * Build style and CSS variables\r\n *\r\n * This function converts a Motion style prop:\r\n *\r\n * { x: 100, width: 100, originX: 0.5 }\r\n *\r\n * Into an object with default value types applied and default\r\n * transform order set:\r\n *\r\n * {\r\n *   transform: 'translateX(100px) translateZ(0)`,\r\n *   width: '100px',\r\n *   transformOrigin: '50% 50%'\r\n * }\r\n *\r\n * Styles are saved to `style` and CSS vars to `vars`.\r\n *\r\n * This function works with mutative data structures.\r\n */\r\nfunction buildHTMLStyles(latest, style, vars, transform, transformOrigin, transformKeys, _a, isLayoutProjectionEnabled, delta, deltaFinal, treeScale, targetBox) {\r\n    var enableHardwareAcceleration = _a.enableHardwareAcceleration, transformTemplate = _a.transformTemplate, allowTransformNone = _a.allowTransformNone;\r\n    // Empty the transformKeys array. As we're throwing out refs to its items\r\n    // this might not be as cheap as suspected. Maybe using the array as a buffer\r\n    // with a manual incrementation would be better.\r\n    transformKeys.length = 0;\r\n    // Track whether we encounter any transform or transformOrigin values.\r\n    var hasTransform = !!isLayoutProjectionEnabled;\r\n    var hasTransformOrigin = !!isLayoutProjectionEnabled;\r\n    // Does the calculated transform essentially equal \"none\"?\r\n    var transformIsNone = true;\r\n    /**\r\n     * Loop over all our latest animated values and decide whether to handle them\r\n     * as a style or CSS variable. Transforms and transform origins are kept seperately\r\n     * for further processing\r\n     */\r\n    for (var key in latest) {\r\n        var value = latest[key];\r\n        // Convert the value to its default value type, ie 0 -> \"0px\"\r\n        var valueType = getDefaultValueType(key);\r\n        var valueAsType = getValueAsType(value, valueType);\r\n        if (isTransformProp(key)) {\r\n            // If this is a transform, flag and enable further transform processing\r\n            hasTransform = true;\r\n            transform[key] = valueAsType;\r\n            transformKeys.push(key);\r\n            if (!transformIsNone)\r\n                continue;\r\n            // If all the transform keys we've so far encountered are their default value\r\n            // then check to see if this one isn't\r\n            var defaultValue = valueType.default !== undefined ? valueType.default : 0;\r\n            if (value !== defaultValue)\r\n                transformIsNone = false;\r\n        }\r\n        else if (isTransformOriginProp(key)) {\r\n            // If this is a transform origin, flag and enable further transform-origin processing\r\n            transformOrigin[key] = valueAsType;\r\n            hasTransformOrigin = true;\r\n        }\r\n        else if (key !== \"transform\" || typeof value !== \"function\") {\r\n            // Handle all remaining values. Decide which map to save to depending\r\n            // on whether this is a CSS variable\r\n            var bucket = isCSSVariable(key) ? vars : style;\r\n            // If we need to perform scale correction, and we have a handler for this\r\n            // value type (ie borderRadius), perform it\r\n            if (isLayoutProjectionEnabled && valueScaleCorrection[key]) {\r\n                var corrected = valueScaleCorrection[key].process(value, targetBox, delta, treeScale);\r\n                /**\r\n                 * Scale-correctable values can define a number of other values to break\r\n                 * down into. For instance borderRadius needs applying to borderBottomLeftRadius etc\r\n                 */\r\n                var applyTo = valueScaleCorrection[key].applyTo;\r\n                if (applyTo) {\r\n                    var num = applyTo.length;\r\n                    for (var i = 0; i < num; i++) {\r\n                        bucket[applyTo[i]] = corrected;\r\n                    }\r\n                }\r\n                else {\r\n                    bucket[key] = corrected;\r\n                }\r\n            }\r\n            else {\r\n                bucket[key] = valueAsType;\r\n            }\r\n        }\r\n    }\r\n    // Only process transform if values aren't defaults\r\n    if (hasTransform || transformTemplate) {\r\n        if (!isLayoutProjectionEnabled) {\r\n            style.transform = buildTransform(transform, transformKeys, transformTemplate, transformIsNone, enableHardwareAcceleration, allowTransformNone);\r\n        }\r\n        else {\r\n            style.transform = layoutReprojection(deltaFinal, treeScale);\r\n        }\r\n    }\r\n    // Only process transform origin if values aren't default\r\n    if (hasTransformOrigin) {\r\n        var originX = isLayoutProjectionEnabled\r\n            ? deltaFinal.x.origin * 100 + \"%\"\r\n            : transformOrigin.originX || \"50%\";\r\n        var originY = isLayoutProjectionEnabled\r\n            ? deltaFinal.y.origin * 100 + \"%\"\r\n            : transformOrigin.originY || \"50%\";\r\n        var originZ = transformOrigin.originZ || \"0\";\r\n        style.transformOrigin = originX + \" \" + originY + \" \" + originZ;\r\n    }\r\n}\r\nfunction layoutReprojection(delta, treeScale) {\r\n    var x = delta.x.translate / treeScale.x;\r\n    var y = delta.y.translate / treeScale.y;\r\n    var scaleX = delta.x.scale;\r\n    var scaleY = delta.y.scale;\r\n    return \"translate3d(\" + x + \"px, \" + y + \"px, 0) scale(\" + scaleX + \", \" + scaleY + \")\";\r\n}\r\n\r\n/**\r\n * Reset an axis to the provided origin box.\r\n *\r\n * This is a mutative operation.\r\n */\r\nfunction resetAxis(axis, originAxis) {\r\n    axis.min = originAxis.min;\r\n    axis.max = originAxis.max;\r\n}\r\n/**\r\n * Reset a box to the provided origin box.\r\n *\r\n * This is a mutative operation.\r\n */\r\nfunction resetBox(box, originBox) {\r\n    resetAxis(box.x, originBox.x);\r\n    resetAxis(box.y, originBox.y);\r\n}\r\n/**\r\n * Scales a point based on a factor and an originPoint\r\n */\r\nfunction scalePoint(point, scale, originPoint) {\r\n    var distanceFromOrigin = point - originPoint;\r\n    var scaled = scale * distanceFromOrigin;\r\n    return originPoint + scaled;\r\n}\r\n/**\r\n * Applies a translate/scale delta to a point\r\n */\r\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\r\n    if (boxScale !== undefined) {\r\n        point = scalePoint(point, boxScale, originPoint);\r\n    }\r\n    return scalePoint(point, scale, originPoint) + translate;\r\n}\r\n/**\r\n * Applies a translate/scale delta to an axis\r\n */\r\nfunction applyAxisDelta(axis, translate, scale, originPoint, boxScale) {\r\n    if (translate === void 0) { translate = 0; }\r\n    if (scale === void 0) { scale = 1; }\r\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\r\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\r\n}\r\n/**\r\n * Applies a translate/scale delta to a box\r\n */\r\nfunction applyBoxDelta(box, _a) {\r\n    var x = _a.x, y = _a.y;\r\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\r\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\r\n}\r\n/**\r\n * Apply a transform to an axis from the latest resolved motion values.\r\n * This function basically acts as a bridge between a flat motion value map\r\n * and applyAxisDelta\r\n */\r\nfunction applyAxisTransforms(final, axis, transforms, _a) {\r\n    var key = _a[0], scaleKey = _a[1], originKey = _a[2];\r\n    // Copy the current axis to the final axis before mutation\r\n    final.min = axis.min;\r\n    final.max = axis.max;\r\n    var originPoint = mix(axis.min, axis.max, transforms[originKey] || 0.5);\r\n    // Apply the axis delta to the final axis\r\n    applyAxisDelta(final, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\r\n}\r\n/**\r\n * The names of the motion values we want to apply as translation, scale and origin.\r\n */\r\nvar xKeys = [\"x\", \"scaleX\", \"originX\"];\r\nvar yKeys = [\"y\", \"scaleY\", \"originY\"];\r\n/**\r\n * Apply a transform to a box from the latest resolved motion values.\r\n */\r\nfunction applyBoxTransforms(finalBox, box, transforms) {\r\n    applyAxisTransforms(finalBox.x, box.x, transforms, xKeys);\r\n    applyAxisTransforms(finalBox.y, box.y, transforms, yKeys);\r\n}\r\n/**\r\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\r\n */\r\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\r\n    point -= translate;\r\n    point = scalePoint(point, 1 / scale, originPoint);\r\n    if (boxScale !== undefined) {\r\n        point = scalePoint(point, 1 / boxScale, originPoint);\r\n    }\r\n    return point;\r\n}\r\n/**\r\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\r\n */\r\nfunction removeAxisDelta(axis, translate, scale, origin, boxScale) {\r\n    if (translate === void 0) { translate = 0; }\r\n    if (scale === void 0) { scale = 1; }\r\n    if (origin === void 0) { origin = 0.5; }\r\n    var originPoint = mix(axis.min, axis.max, origin) - translate;\r\n    axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\r\n    axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\r\n}\r\n/**\r\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\r\n * and acts as a bridge between motion values and removeAxisDelta\r\n */\r\nfunction removeAxisTransforms(axis, transforms, _a) {\r\n    var key = _a[0], scaleKey = _a[1], originKey = _a[2];\r\n    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale);\r\n}\r\n/**\r\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\r\n * and acts as a bridge between motion values and removeAxisDelta\r\n */\r\nfunction removeBoxTransforms(box, transforms) {\r\n    removeAxisTransforms(box.x, transforms, xKeys);\r\n    removeAxisTransforms(box.y, transforms, yKeys);\r\n}\r\n/**\r\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\r\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\r\n */\r\nfunction applyTreeDeltas(box, treeScale, treePath) {\r\n    treeScale.x = treeScale.y = 1;\r\n    var treeLength = treePath.length;\r\n    for (var i = 0; i < treeLength; i++) {\r\n        var parent_1 = treePath[i];\r\n        var delta = parent_1.delta;\r\n        applyBoxDelta(box, delta);\r\n        treeScale.x *= delta.x.scale;\r\n        treeScale.y *= delta.y.scale;\r\n    }\r\n}\r\n\r\nvar clampProgress = clamp(0, 1);\r\n/**\r\n * Returns true if the provided value is within maxDistance of the provided target\r\n */\r\nfunction isNear(value, target, maxDistance) {\r\n    if (target === void 0) { target = 0; }\r\n    if (maxDistance === void 0) { maxDistance = 0.01; }\r\n    return distance(value, target) < maxDistance;\r\n}\r\n/**\r\n * Calculate the translate needed to be applied to source to get target\r\n */\r\nfunction calcTranslate(source, target, origin) {\r\n    var sourcePoint = mix(source.min, source.max, origin);\r\n    var targetPoint = mix(target.min, target.max, origin);\r\n    return targetPoint - sourcePoint;\r\n}\r\n/**\r\n * Calculate a transform origin relative to the source axis, between 0-1, that results\r\n * in an asthetically pleasing scale/transform needed to project from source to target.\r\n */\r\nfunction calcOrigin(source, target) {\r\n    var origin = 0.5;\r\n    var sourceLength = source.max - source.min;\r\n    var targetLength = target.max - target.min;\r\n    if (targetLength > sourceLength) {\r\n        origin = progress(target.min, target.max - sourceLength, source.min);\r\n    }\r\n    else if (sourceLength > targetLength) {\r\n        origin = progress(source.min, source.max - targetLength, target.min);\r\n    }\r\n    return clampProgress(origin);\r\n}\r\n/**\r\n * Update the AxisDelta with a transform that projects source into target.\r\n *\r\n * The transform `origin` is optional. If not provided, it'll be automatically\r\n * calculated based on the relative positions of the two bounding boxes.\r\n */\r\nfunction updateAxisDelta(delta, source, target, origin) {\r\n    var sourceLength = source.max - source.min;\r\n    var targetLength = target.max - target.min;\r\n    delta.origin = origin === undefined ? calcOrigin(source, target) : origin;\r\n    delta.originPoint = mix(source.min, source.max, delta.origin);\r\n    delta.scale = targetLength / sourceLength;\r\n    if (isNear(delta.scale, 1, 0.0001))\r\n        delta.scale = 1;\r\n    delta.translate = calcTranslate(source, target, delta.origin);\r\n    if (isNear(delta.translate))\r\n        delta.translate = 0;\r\n}\r\n/**\r\n * Update the BoxDelta with a transform that projects the source into the target.\r\n *\r\n * The transform `origin` is optional. If not provided, it'll be automatically\r\n * calculated based on the relative positions of the two bounding boxes.\r\n */\r\nfunction updateBoxDelta(delta, source, target, origin) {\r\n    updateAxisDelta(delta.x, source.x, target.x, origin);\r\n    updateAxisDelta(delta.y, source.y, target.y, origin);\r\n}\r\n\r\n// Call a handler once for each axis\r\nfunction eachAxis(handler) {\r\n    return [handler(\"x\"), handler(\"y\")];\r\n}\r\n\r\nvar isKeyframesTarget = function (v) {\r\n    return Array.isArray(v);\r\n};\r\n\r\nvar underDampedSpring = function () { return ({\r\n    type: \"spring\",\r\n    stiffness: 500,\r\n    damping: 25,\r\n    restDelta: 0.5,\r\n    restSpeed: 10,\r\n}); };\r\nvar overDampedSpring = function (to) { return ({\r\n    type: \"spring\",\r\n    stiffness: 700,\r\n    damping: to === 0 ? 100 : 35,\r\n}); };\r\nvar linearTween = function () { return ({\r\n    ease: \"linear\",\r\n    duration: 0.3,\r\n}); };\r\nvar keyframes = function (values) { return ({\r\n    type: \"keyframes\",\r\n    duration: 0.8,\r\n    values: values,\r\n}); };\r\nvar defaultTransitions = {\r\n    x: underDampedSpring,\r\n    y: underDampedSpring,\r\n    z: underDampedSpring,\r\n    rotate: underDampedSpring,\r\n    rotateX: underDampedSpring,\r\n    rotateY: underDampedSpring,\r\n    rotateZ: underDampedSpring,\r\n    scaleX: overDampedSpring,\r\n    scaleY: overDampedSpring,\r\n    scale: overDampedSpring,\r\n    opacity: linearTween,\r\n    backgroundColor: linearTween,\r\n    color: linearTween,\r\n    default: overDampedSpring,\r\n};\r\nvar getDefaultTransition = function (valueKey, to) {\r\n    var transitionFactory;\r\n    if (isKeyframesTarget(to)) {\r\n        transitionFactory = keyframes;\r\n    }\r\n    else {\r\n        transitionFactory =\r\n            defaultTransitions[valueKey] || defaultTransitions.default;\r\n    }\r\n    return __assign({ to: to }, transitionFactory(to));\r\n};\r\n\r\n/**\r\n * A Popmotion action that accepts a single `to` prop. When it starts, it immediately\r\n * updates with `to` and then completes. By using this we can compose instant transitions\r\n * in with the same logic that applies `delay` or returns a `Promise` etc.\r\n *\r\n * Accepting `duration` is a little bit of a hack that simply defers the completetion of\r\n * the animation until after the duration finishes. This is for situations when you're **only**\r\n * animating non-animatable values and then setting something on `transitionEnd`. Really\r\n * you want this to fire after the \"animation\" finishes, rather than instantly.\r\n *\r\n * ```\r\n * animate={{\r\n *   display: 'block',\r\n *   transitionEnd: { display: 'none' }\r\n * }}\r\n * ```\r\n */\r\nvar just = function (_a) {\r\n    var to = _a.to, duration = _a.duration;\r\n    return action(function (_a) {\r\n        var update = _a.update, complete = _a.complete;\r\n        update(to);\r\n        duration ? delay(duration).start({ complete: complete }) : complete();\r\n    });\r\n};\r\n\r\nvar easingDefinitionToFunction = function (definition) {\r\n    if (Array.isArray(definition)) {\r\n        // If cubic bezier definition, create bezier curve\r\n        invariant(definition.length === 4, \"Cubic bezier arrays must contain four numerical values.\");\r\n        var x1 = definition[0], y1 = definition[1], x2 = definition[2], y2 = definition[3];\r\n        return cubicBezier(x1, y1, x2, y2);\r\n    }\r\n    else if (typeof definition === \"string\") {\r\n        // Else lookup from table\r\n        invariant(easingLookup[definition] !== undefined, \"Invalid easing type '\" + definition + \"'\");\r\n        return easingLookup[definition];\r\n    }\r\n    return definition;\r\n};\r\nvar isEasingArray = function (ease) {\r\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\r\n};\r\n\r\nvar isDurationAnimation = function (v) {\r\n    return v.hasOwnProperty(\"duration\") || v.hasOwnProperty(\"repeatDelay\");\r\n};\r\n\r\n/**\r\n * Check if a value is animatable. Examples:\r\n *\r\n * ✅: 100, \"100px\", \"#fff\"\r\n * ❌: \"block\", \"url(2.jpg)\"\r\n * @param value\r\n *\r\n * @internal\r\n */\r\nvar isAnimatable = function (key, value) {\r\n    // If the list of keys tat might be non-animatable grows, replace with Set\r\n    if (key === \"zIndex\")\r\n        return false;\r\n    // If it's a number or a keyframes array, we can animate it. We might at some point\r\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\r\n    // but for now lets leave it like this for performance reasons\r\n    if (typeof value === \"number\" || Array.isArray(value))\r\n        return true;\r\n    if (typeof value === \"string\" && // It's animatable if we have a string\r\n        complex.test(value) && // And it contains numbers and/or colors\r\n        !value.startsWith(\"url(\") // Unless it starts with \"url(\"\r\n    ) {\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\n\r\n/**\r\n * Converts seconds to milliseconds\r\n *\r\n * @param seconds - Time in seconds.\r\n * @return milliseconds - Converted time in milliseconds.\r\n */\r\nvar secondsToMilliseconds = function (seconds) { return seconds * 1000; };\r\n\r\nvar transitions = { tween: tween, spring: spring, keyframes: keyframes$1, inertia: inertia, just: just };\r\nvar transitionOptionParser = {\r\n    tween: function (opts) {\r\n        if (opts.ease) {\r\n            var ease = isEasingArray(opts.ease) ? opts.ease[0] : opts.ease;\r\n            opts.ease = easingDefinitionToFunction(ease);\r\n        }\r\n        return opts;\r\n    },\r\n    keyframes: function (_a) {\r\n        var from = _a.from, to = _a.to, velocity = _a.velocity, opts = __rest(_a, [\"from\", \"to\", \"velocity\"]);\r\n        if (opts.values && opts.values[0] === null) {\r\n            var values = __spreadArrays(opts.values);\r\n            values[0] = from;\r\n            opts.values = values;\r\n        }\r\n        if (opts.ease) {\r\n            opts.easings = isEasingArray(opts.ease)\r\n                ? opts.ease.map(easingDefinitionToFunction)\r\n                : easingDefinitionToFunction(opts.ease);\r\n        }\r\n        opts.ease = linear;\r\n        return opts;\r\n    },\r\n};\r\nvar isTransitionDefined = function (_a) {\r\n    var when = _a.when, delay = _a.delay, delayChildren = _a.delayChildren, staggerChildren = _a.staggerChildren, staggerDirection = _a.staggerDirection, transition = __rest(_a, [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\"]);\r\n    return Object.keys(transition).length;\r\n};\r\nvar getTransitionDefinition = function (key, to, transitionDefinition) {\r\n    var delay = transitionDefinition ? transitionDefinition.delay : 0;\r\n    // If no object, return default transition\r\n    // A better way to handle this would be to deconstruct out all the shared Orchestration props\r\n    // and see if there's any props remaining\r\n    if (transitionDefinition === undefined ||\r\n        !isTransitionDefined(transitionDefinition)) {\r\n        return __assign({ delay: delay }, getDefaultTransition(key, to));\r\n    }\r\n    var valueTransitionDefinition = transitionDefinition[key] ||\r\n        transitionDefinition.default ||\r\n        transitionDefinition;\r\n    if (valueTransitionDefinition.type === false) {\r\n        return {\r\n            delay: valueTransitionDefinition.hasOwnProperty(\"delay\")\r\n                ? valueTransitionDefinition.delay\r\n                : delay,\r\n            to: isKeyframesTarget(to)\r\n                ? to[to.length - 1]\r\n                : to,\r\n            type: \"just\",\r\n        };\r\n    }\r\n    else if (isKeyframesTarget(to)) {\r\n        return __assign(__assign({ values: to, duration: 0.8, delay: delay, ease: \"linear\" }, valueTransitionDefinition), { \r\n            // This animation must be keyframes if we're animating through an array\r\n            type: \"keyframes\" });\r\n    }\r\n    else {\r\n        return __assign({ type: \"tween\", to: to,\r\n            delay: delay }, valueTransitionDefinition);\r\n    }\r\n};\r\nvar preprocessOptions = function (type, opts) {\r\n    return transitionOptionParser[type]\r\n        ? transitionOptionParser[type](opts)\r\n        : opts;\r\n};\r\nvar getAnimation = function (key, value, target, transition) {\r\n    var origin = value.get();\r\n    var isOriginAnimatable = isAnimatable(key, origin);\r\n    var isTargetAnimatable = isAnimatable(key, target);\r\n    // TODO we could probably improve this check to ensure both values are of the same type -\r\n    // for instance 100 to #fff. This might live better in Popmotion.\r\n    warning(isOriginAnimatable === isTargetAnimatable, \"You are trying to animate \" + key + \" from \\\"\" + origin + \"\\\" to \\\"\" + target + \"\\\". \" + origin + \" is not an animatable value - to enable this animation set \" + origin + \" to a value animatable to \" + target + \" via the `style` property.\");\r\n    // Parse the `transition` prop and return options for the Popmotion animation\r\n    var _a = getTransitionDefinition(key, target, transition), _b = _a.type, type = _b === void 0 ? \"tween\" : _b, transitionDefinition = __rest(_a, [\"type\"]);\r\n    // If this is an animatable pair of values, return an animation, otherwise use `just`\r\n    var actionFactory = isOriginAnimatable && isTargetAnimatable\r\n        ? transitions[type]\r\n        : just;\r\n    var opts = preprocessOptions(type, __assign({ from: origin, velocity: value.getVelocity() }, transitionDefinition));\r\n    // Convert duration from Framer Motion's seconds into Popmotion's milliseconds\r\n    if (isDurationAnimation(opts)) {\r\n        if (opts.duration) {\r\n            opts.duration = secondsToMilliseconds(opts.duration);\r\n        }\r\n        if (opts.repeatDelay) {\r\n            opts.repeatDelay = secondsToMilliseconds(opts.repeatDelay);\r\n        }\r\n    }\r\n    return [actionFactory, opts];\r\n};\r\n/**\r\n * Start animation on a value. This function completely encapsulates Popmotion-specific logic.\r\n *\r\n * @internal\r\n */\r\nfunction startAnimation(key, value, target, _a) {\r\n    if (_a === void 0) { _a = {}; }\r\n    var _b = _a.delay, delay$1 = _b === void 0 ? 0 : _b, transition = __rest(_a, [\"delay\"]);\r\n    return value.start(function (complete) {\r\n        var activeAnimation;\r\n        var _a = getAnimation(key, value, target, transition), animationFactory = _a[0], _b = _a[1], valueDelay = _b.delay, options = __rest(_b, [\"delay\"]);\r\n        if (valueDelay !== undefined) {\r\n            delay$1 = valueDelay;\r\n        }\r\n        var animate = function () {\r\n            var animation = animationFactory(options);\r\n            // Bind animation opts to animation\r\n            activeAnimation = animation.start({\r\n                update: function (v) { return value.set(v); },\r\n                complete: complete,\r\n            });\r\n        };\r\n        // If we're delaying this animation, only resolve it **after** the delay to\r\n        // ensure the value's resolve velocity is up-to-date.\r\n        if (delay$1) {\r\n            activeAnimation = delay(secondsToMilliseconds(delay$1)).start({\r\n                complete: animate,\r\n            });\r\n        }\r\n        else {\r\n            animate();\r\n        }\r\n        return function () {\r\n            if (activeAnimation)\r\n                activeAnimation.stop();\r\n        };\r\n    });\r\n}\r\n\r\n/**\r\n * Measure and return the element bounding box.\r\n *\r\n * We convert the box into an AxisBox2D to make it easier to work with each axis\r\n * individually and programmatically.\r\n *\r\n * This function optionally accepts a transformPagePoint function which allows us to compensate\r\n * for, for instance, measuring the element within a scaled plane like a Framer devivce preview component.\r\n */\r\nfunction getBoundingBox(element, transformPagePoint) {\r\n    var box = element.getBoundingClientRect();\r\n    return convertBoundingBoxToAxisBox(transformBoundingBox(box, transformPagePoint));\r\n}\r\n\r\n/**\r\n * A VisualElement for HTMLElements\r\n */\r\nvar HTMLVisualElement = /** @class */ (function (_super) {\r\n    __extends(HTMLVisualElement, _super);\r\n    function HTMLVisualElement() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        /**\r\n         *\r\n         */\r\n        _this.defaultConfig = {\r\n            enableHardwareAcceleration: true,\r\n            allowTransformNone: true,\r\n        };\r\n        /**\r\n         * A mutable record of styles we want to apply directly to the rendered Element\r\n         * every frame. We use a mutable data structure to reduce GC during animations.\r\n         */\r\n        _this.style = {};\r\n        /**\r\n         * A record of styles we only want to apply via React. This gets set in useMotionValues\r\n         * and applied in the render function. I'd prefer this to live somewhere else to decouple\r\n         * VisualElement from React but works for now.\r\n         */\r\n        _this.reactStyle = {};\r\n        /**\r\n         * A mutable record of CSS variables we want to apply directly to the rendered Element\r\n         * every frame. We use a mutable data structure to reduce GC during animations.\r\n         */\r\n        _this.vars = {};\r\n        /**\r\n         * A mutable record of transforms we want to apply directly to the rendered Element\r\n         * every frame. We use a mutable data structure to reduce GC during animations.\r\n         */\r\n        _this.transform = {};\r\n        /**\r\n         * A mutable record of transform origins we want to apply directly to the rendered Element\r\n         * every frame. We use a mutable data structure to reduce GC during animations.\r\n         */\r\n        _this.transformOrigin = {};\r\n        /**\r\n         * A mutable record of transform keys we want to apply to the rendered Element. We order\r\n         * this to order transforms in the desired order. We use a mutable data structure to reduce GC during animations.\r\n         */\r\n        _this.transformKeys = [];\r\n        _this.config = _this.defaultConfig;\r\n        /**\r\n         * ========================================\r\n         * Layout\r\n         * ========================================\r\n         */\r\n        _this.isLayoutProjectionEnabled = false;\r\n        /**\r\n         * A boolean that flags whether this component has children that need to be update\r\n         * when this component changes layout.\r\n         */\r\n        _this.hasLayoutChildren = false;\r\n        /**\r\n         * A set of layout update event handlers. These are only called once all layouts have been read,\r\n         * making it safe to perform DOM write operations.\r\n         */\r\n        _this.layoutUpdateListeners = new Set();\r\n        /**\r\n         * Keep track of whether the viewport box has been updated since the last render.\r\n         * If it has, we want to fire the onViewportBoxUpdate listener.\r\n         */\r\n        _this.hasViewportBoxUpdated = false;\r\n        /**\r\n         * The visual target we want to project our component into on a given frame\r\n         * before applying transforms defined in `animate` or `style`.\r\n         *\r\n         * This is considered mutable to avoid object creation on each frame.\r\n         */\r\n        _this.targetBoxFinal = axisBox();\r\n        /**\r\n         * The overall scale of the local coordinate system as transformed by all parents\r\n         * of this component. We use this for scale correction on our calculated layouts\r\n         * and scale-affected values like `boxShadow`.\r\n         *\r\n         * This is considered mutable to avoid object creation on each frame.\r\n         */\r\n        _this.treeScale = { x: 1, y: 1 };\r\n        /**\r\n         * The delta between the boxCorrected and the desired\r\n         * targetBox (before user-set transforms are applied). The calculated output will be\r\n         * handed to the renderer and used as part of the style correction calculations, for\r\n         * instance calculating how to display the desired border-radius correctly.\r\n         *\r\n         * This is considered mutable to avoid object creation on each frame.\r\n         */\r\n        _this.delta = delta();\r\n        /**\r\n         * The delta between the boxCorrected and the desired targetBoxFinal. The calculated\r\n         * output will be handed to the renderer and used to project the boxCorrected into\r\n         * the targetBoxFinal.\r\n         *\r\n         * This is considered mutable to avoid object creation on each frame.\r\n         */\r\n        _this.deltaFinal = delta();\r\n        /**\r\n         *\r\n         */\r\n        _this.stopLayoutAxisAnimation = {\r\n            x: function () { },\r\n            y: function () { },\r\n        };\r\n        _this.isTargetBoxLocked = false;\r\n        /**\r\n         *\r\n         */\r\n        _this.axisProgress = {\r\n            x: motionValue(0),\r\n            y: motionValue(0),\r\n        };\r\n        return _this;\r\n    }\r\n    /**\r\n     * When a value is removed, we want to make sure it's removed from all rendered data structures.\r\n     */\r\n    HTMLVisualElement.prototype.removeValue = function (key) {\r\n        _super.prototype.removeValue.call(this, key);\r\n        delete this.vars[key];\r\n        delete this.style[key];\r\n    };\r\n    /**\r\n     * Empty the mutable data structures by re-creating them. We can do this every React render\r\n     * as the comparative workload to the rest of the render is very low and this is also when\r\n     * we want to reflect values that might have been removed by the render.\r\n     */\r\n    HTMLVisualElement.prototype.clean = function () {\r\n        this.style = {};\r\n        this.vars = {};\r\n        this.transform = {};\r\n    };\r\n    HTMLVisualElement.prototype.updateConfig = function (config) {\r\n        if (config === void 0) { config = {}; }\r\n        this.config = __assign(__assign({}, this.defaultConfig), config);\r\n    };\r\n    /**\r\n     * Read a value directly from the HTMLElement style.\r\n     */\r\n    HTMLVisualElement.prototype.read = function (key) {\r\n        return this.getComputedStyle()[key] || 0;\r\n    };\r\n    /**\r\n     * Read a value directly from the HTMLElement in case it's not defined by a Motion\r\n     * prop. If it's a transform, we just return a pre-defined default value as reading these\r\n     * out of a matrix is either error-prone or can incur a big payload for little benefit.\r\n     */\r\n    HTMLVisualElement.prototype.readNativeValue = function (key) {\r\n        if (isTransformProp(key)) {\r\n            var defaultValueType = getDefaultValueType(key);\r\n            return defaultValueType ? defaultValueType.default || 0 : 0;\r\n        }\r\n        else {\r\n            return this.read(key);\r\n        }\r\n    };\r\n    HTMLVisualElement.prototype.enableLayoutProjection = function () {\r\n        this.isLayoutProjectionEnabled = true;\r\n        forEachParent(this, function (parent) { return (parent.hasLayoutChildren = true); });\r\n    };\r\n    HTMLVisualElement.prototype.hide = function () {\r\n        if (this.isVisible === false)\r\n            return;\r\n        this.isVisible = false;\r\n        this.scheduleRender();\r\n    };\r\n    HTMLVisualElement.prototype.show = function () {\r\n        if (this.isVisible === true)\r\n            return;\r\n        this.isVisible = true;\r\n        this.scheduleRender();\r\n    };\r\n    /**\r\n     * Register an event listener to fire when the layout is updated. We might want to expose support\r\n     * for this via a `motion` prop.\r\n     */\r\n    HTMLVisualElement.prototype.onLayoutUpdate = function (callback) {\r\n        var _this = this;\r\n        this.layoutUpdateListeners.add(callback);\r\n        return function () { return _this.layoutUpdateListeners.delete(callback); };\r\n    };\r\n    /**\r\n     * To be called when all layouts are successfully updated. In turn we can notify layoutUpdate\r\n     * subscribers.\r\n     */\r\n    HTMLVisualElement.prototype.layoutReady = function (config) {\r\n        var _this = this;\r\n        this.layoutUpdateListeners.forEach(function (listener) {\r\n            listener(_this.box, _this.prevViewportBox || _this.box, config);\r\n        });\r\n    };\r\n    /**\r\n     * Measure and return the Element's bounding box. We convert it to a AxisBox2D\r\n     * structure to make it easier to work on each individual axis generically.\r\n     */\r\n    HTMLVisualElement.prototype.getBoundingBox = function () {\r\n        var transformPagePoint = this.config.transformPagePoint;\r\n        return getBoundingBox(this.element, transformPagePoint);\r\n    };\r\n    HTMLVisualElement.prototype.getBoundingBoxWithoutTransforms = function () {\r\n        var bbox = this.getBoundingBox();\r\n        removeBoxTransforms(bbox, this.latest);\r\n        return bbox;\r\n    };\r\n    /**\r\n     * Return the computed style after a render.\r\n     */\r\n    HTMLVisualElement.prototype.getComputedStyle = function () {\r\n        return window.getComputedStyle(this.element);\r\n    };\r\n    /**\r\n     *\r\n     */\r\n    HTMLVisualElement.prototype.snapshotBoundingBox = function () {\r\n        this.prevViewportBox = this.getBoundingBoxWithoutTransforms();\r\n        /**\r\n         * Update targetBox to match the prevViewportBox. This is just to ensure\r\n         * that targetBox is affected by scroll in the same way as the measured box\r\n         */\r\n        var _a = this.axisProgress, x = _a.x, y = _a.y;\r\n        if (!this.isTargetBoxLocked && !x.isAnimating() && !y.isAnimating()) {\r\n            this.targetBox = copyAxisBox(this.prevViewportBox);\r\n        }\r\n    };\r\n    HTMLVisualElement.prototype.measureLayout = function () {\r\n        this.box = this.getBoundingBox();\r\n        this.boxCorrected = copyAxisBox(this.box);\r\n        if (!this.targetBox)\r\n            this.targetBox = copyAxisBox(this.box);\r\n    };\r\n    /**\r\n     * Ensure the targetBox reflects the latest visual box on screen\r\n     */\r\n    HTMLVisualElement.prototype.refreshTargetBox = function () {\r\n        this.targetBox = this.getBoundingBoxWithoutTransforms();\r\n    };\r\n    HTMLVisualElement.prototype.lockTargetBox = function () {\r\n        this.isTargetBoxLocked = true;\r\n    };\r\n    HTMLVisualElement.prototype.unlockTargetBox = function () {\r\n        this.stopLayoutAnimation();\r\n        this.isTargetBoxLocked = false;\r\n    };\r\n    /**\r\n     * Reset the transform on the current Element. This is called as part\r\n     * of a batched process across the entire layout tree. To remove this write\r\n     * cycle it'd be interesting to see if it's possible to \"undo\" all the current\r\n     * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\r\n     * works\r\n     */\r\n    HTMLVisualElement.prototype.resetTransform = function () {\r\n        this.element.style.transform = \"none\";\r\n        // Ensure that whatever happens next, we restore our transform\r\n        this.scheduleRender();\r\n    };\r\n    /**\r\n     * Set new min/max boundaries to project an axis into\r\n     */\r\n    HTMLVisualElement.prototype.setAxisTarget = function (axis, min, max) {\r\n        var targetAxis = this.targetBox[axis];\r\n        targetAxis.min = min;\r\n        targetAxis.max = max;\r\n        // Flag that we want to fire the onViewportBoxUpdate event handler\r\n        this.hasViewportBoxUpdated = true;\r\n        /**\r\n         * If this component re-renders we need to ensure that any children performing\r\n         * layout projection also update\r\n         *\r\n         * TODO: This recursively traverses all children for each axis and for each component. A performance\r\n         * improvement would be to:\r\n         *  1. Flag the root component as dirty and schedule it to update pre-render\r\n         *  2. Recursively traverse tree from root layout component during this update\r\n         *      scheduling renders and updating deltas\r\n         */\r\n        scheduleChildrenLayoutRender(this);\r\n    };\r\n    /**\r\n     *\r\n     */\r\n    HTMLVisualElement.prototype.startLayoutAxisAnimation = function (axis, transition) {\r\n        var _this = this;\r\n        var progress = this.axisProgress[axis];\r\n        var _a = this.targetBox[axis], min = _a.min, max = _a.max;\r\n        var length = max - min;\r\n        progress.clearListeners();\r\n        progress.set(min);\r\n        progress.set(min); // Set twice to hard-reset velocity\r\n        progress.onChange(function (v) { return _this.setAxisTarget(axis, v, v + length); });\r\n        return startAnimation(axis, progress, 0, transition);\r\n    };\r\n    HTMLVisualElement.prototype.stopLayoutAnimation = function () {\r\n        var _this = this;\r\n        eachAxis(function (axis) { return _this.axisProgress[axis].stop(); });\r\n    };\r\n    /**\r\n     * Update the layout deltas to reflect the relative positions of the layout\r\n     * and the desired target box\r\n     */\r\n    HTMLVisualElement.prototype.updateLayoutDeltas = function (isReactRender) {\r\n        var _a, _b;\r\n        /**\r\n         * Ensure that all the parent deltas are up-to-date before calculating this delta.\r\n         *\r\n         * TODO: This approach is exceptionally wasteful as every child will update\r\n         * the deltas of its parent even if it's already updated for this frame.\r\n         * We can optimise this by replacing this to a call directly to the root VisualElement\r\n         * which then runs iteration from the top-down, but only once per framestamp.\r\n         */\r\n        this.treePath.forEach(function (p) {\r\n            return p.updateLayoutDeltas(isReactRender);\r\n        });\r\n        /**\r\n         * Early return if layout reprojection isn't enabled\r\n         */\r\n        if (!this.isLayoutProjectionEnabled || !this.box)\r\n            return;\r\n        /**\r\n         * Reset the corrected box with the latest values from box, as we're then going\r\n         * to perform mutative operations on it.\r\n         */\r\n        resetBox(this.boxCorrected, this.box);\r\n        /**\r\n         * Apply all the parent deltas to this box to produce the corrected box. This\r\n         * is the layout box, as it will appear on screen as a result of the transforms of its parents.\r\n         */\r\n        applyTreeDeltas(this.boxCorrected, this.treeScale, this.treePath);\r\n        /**\r\n         * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\r\n         * This is the final box that we will then project into by calculating a transform delta and\r\n         * applying it to the corrected box.\r\n         */\r\n        applyBoxTransforms(this.targetBoxFinal, this.targetBox, this.latest);\r\n        /**\r\n         * Update the delta between the corrected box and the target box before user-set transforms were applied.\r\n         * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\r\n         * for our layout reprojection, but still allow them to be scaled correctly by the user.\r\n         * It might be that to simplify this we may want to accept that user-set scale is also corrected\r\n         * and we wouldn't have to keep and calc both deltas, OR we could support a user setting\r\n         * to allow people to choose whether these styles are corrected based on just the\r\n         * layout reprojection or the final bounding box.\r\n         */\r\n        updateBoxDelta(this.delta, this.boxCorrected, this.targetBox);\r\n        /**\r\n         * Update the delta between the corrected box and the final target box, after\r\n         * user-set transforms are applied to it. This will be used by the renderer to\r\n         * create a transform style that will reproject the element from its actual layout\r\n         * into the desired bounding box.\r\n         */\r\n        updateBoxDelta(this.deltaFinal, this.boxCorrected, this.targetBoxFinal);\r\n        /**\r\n         * If we have a listener for the viewport box, fire it.\r\n         * TODO: Instead of manually checking this, use framesync postRender\r\n         */\r\n        if (!isReactRender) {\r\n            this.hasViewportBoxUpdated && ((_b = (_a = this.config).onViewportBoxUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, this.targetBox, this.delta));\r\n            this.hasViewportBoxUpdated = false;\r\n        }\r\n    };\r\n    /**\r\n     * ========================================\r\n     * Build & render\r\n     * ========================================\r\n     */\r\n    /**\r\n     * Build a style prop using the latest resolved MotionValues\r\n     */\r\n    HTMLVisualElement.prototype.build = function (isReactRender) {\r\n        if (this.isVisible !== undefined) {\r\n            this.style.visibility = this.isVisible ? \"visible\" : \"hidden\";\r\n        }\r\n        this.isLayoutProjectionEnabled &&\r\n            this.box &&\r\n            this.updateLayoutDeltas(isReactRender);\r\n        buildHTMLStyles(this.latest, this.style, this.vars, this.transform, this.transformOrigin, this.transformKeys, this.config, this.isLayoutProjectionEnabled && !!this.box, this.delta, this.deltaFinal, this.treeScale, this.targetBoxFinal);\r\n    };\r\n    /**\r\n     * Render the Element by rebuilding and applying the latest styles and vars.\r\n     */\r\n    HTMLVisualElement.prototype.render = function () {\r\n        // Rebuild the latest animated values into style and vars caches.\r\n        this.build(false);\r\n        // Directly assign style into the Element's style prop. In tests Object.assign is the\r\n        // fastest way to assign styles.\r\n        Object.assign(this.element.style, this.style);\r\n        // Loop over any CSS variables and assign those.\r\n        for (var key in this.vars) {\r\n            this.element.style.setProperty(key, this.vars[key]);\r\n        }\r\n    };\r\n    return HTMLVisualElement;\r\n}(VisualElement));\r\nfunction scheduleChildrenLayoutRender(element) {\r\n    if (element.isLayoutProjectionEnabled) {\r\n        element.scheduleRender();\r\n    }\r\n    if (element.hasLayoutChildren) {\r\n        element.children.forEach(scheduleChildrenLayoutRender);\r\n    }\r\n}\r\nfunction forEachParent(child, callback) {\r\n    var parent = child.parent;\r\n    while (parent) {\r\n        callback(parent);\r\n        parent = parent.parent;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a constant value over the lifecycle of a component.\r\n *\r\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\r\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\r\n * you can ensure that initialisers don't execute twice or more.\r\n */\r\nfunction useConstant(init) {\r\n    var ref = useRef(null);\r\n    if (ref.current === null) {\r\n        ref.current = init();\r\n    }\r\n    return ref.current;\r\n}\r\n\r\nfunction calcOrigin$1(origin, offset, size) {\r\n    return typeof origin === \"string\"\r\n        ? origin\r\n        : px.transform(offset + size * origin);\r\n}\r\n/**\r\n * The SVG transform origin defaults are different to CSS and is less intuitive,\r\n * so we use the measured dimensions of the SVG to reconcile these.\r\n */\r\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\r\n    var pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);\r\n    var pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);\r\n    return pxOriginX + \" \" + pxOriginY;\r\n}\r\n\r\n// Convert a progress 0-1 to a pixels value based on the provided length\r\nvar progressToPixels = function (progress, length) {\r\n    return px.transform(progress * length);\r\n};\r\nvar dashKeys = {\r\n    offset: \"stroke-dashoffset\",\r\n    array: \"stroke-dasharray\",\r\n};\r\nvar camelKeys = {\r\n    offset: \"strokeDashoffset\",\r\n    array: \"strokeDasharray\",\r\n};\r\n/**\r\n * Build SVG path properties. Uses the path's measured length to convert\r\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\r\n * and stroke-dasharray attributes.\r\n *\r\n * This function is mutative to reduce per-frame GC.\r\n */\r\nfunction buildSVGPath(attrs, totalLength, length, spacing, offset, useDashCase) {\r\n    if (spacing === void 0) { spacing = 1; }\r\n    if (offset === void 0) { offset = 0; }\r\n    if (useDashCase === void 0) { useDashCase = true; }\r\n    // We use dash case when setting attributes directly to the DOM node and camel case\r\n    // when defining props on a React component.\r\n    var keys = useDashCase ? dashKeys : camelKeys;\r\n    // Build the dash offset\r\n    attrs[keys.offset] = progressToPixels(-offset, totalLength);\r\n    // Build the dash array\r\n    var pathLength = progressToPixels(length, totalLength);\r\n    var pathSpacing = progressToPixels(spacing, totalLength);\r\n    attrs[keys.array] = pathLength + \" \" + pathSpacing;\r\n}\r\n\r\nvar unmeasured = { x: 0, y: 0, width: 0, height: 0 };\r\n/**\r\n * Build SVG visual attrbutes, like cx and style.transform\r\n */\r\nfunction buildSVGAttrs(_a, style, vars, attrs, transform, transformOrigin, transformKeys, config, dimensions, totalPathLength) {\r\n    var attrX = _a.attrX, attrY = _a.attrY, originX = _a.originX, originY = _a.originY, pathLength = _a.pathLength, _b = _a.pathSpacing, pathSpacing = _b === void 0 ? 1 : _b, _c = _a.pathOffset, pathOffset = _c === void 0 ? 0 : _c, \r\n    // This is object creation, which we try to avoid per-frame.\r\n    latest = __rest(_a, [\"attrX\", \"attrY\", \"originX\", \"originY\", \"pathLength\", \"pathSpacing\", \"pathOffset\"]);\r\n    /**\r\n     * With SVG we treat all animated values as attributes rather than CSS, so we build into attrs\r\n     */\r\n    buildHTMLStyles(latest, attrs, vars, transform, transformOrigin, transformKeys, config);\r\n    /**\r\n     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\r\n     * and copy it into style.\r\n     */\r\n    if (attrs.transform) {\r\n        style.transform = attrs.transform;\r\n        delete attrs.transform;\r\n    }\r\n    // Parse transformOrigin\r\n    if (originX !== undefined || originY !== undefined || style.transform) {\r\n        style.transformOrigin = calcSVGTransformOrigin(dimensions || unmeasured, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\r\n    }\r\n    // Treat x/y not as shortcuts but as actual attributes\r\n    if (attrX !== undefined)\r\n        attrs.x = attrX;\r\n    if (attrY !== undefined)\r\n        attrs.y = attrY;\r\n    // Build SVG path if one has been measured\r\n    if (totalPathLength !== undefined && pathLength !== undefined) {\r\n        buildSVGPath(attrs, totalPathLength, pathLength, pathSpacing, pathOffset, false);\r\n    }\r\n    return attrs;\r\n}\r\n\r\n/**\r\n * A set of attribute names that are always read/written as camel case.\r\n */\r\nvar camelCaseAttributes = new Set([\r\n    \"baseFrequency\",\r\n    \"diffuseConstant\",\r\n    \"kernelMatrix\",\r\n    \"kernelUnitLength\",\r\n    \"keySplines\",\r\n    \"keyTimes\",\r\n    \"limitingConeAngle\",\r\n    \"markerHeight\",\r\n    \"markerWidth\",\r\n    \"numOctaves\",\r\n    \"targetX\",\r\n    \"targetY\",\r\n    \"surfaceScale\",\r\n    \"specularConstant\",\r\n    \"specularExponent\",\r\n    \"stdDeviation\",\r\n    \"tableValues\",\r\n]);\r\n\r\nvar CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;\r\nvar REPLACE_TEMPLATE = \"$1-$2\";\r\n/**\r\n * Convert camelCase to dash-case properties.\r\n */\r\nvar camelToDash = function (str) {\r\n    return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();\r\n};\r\n\r\n/**\r\n * A VisualElement for SVGElements. Inherits from and extends HTMLVisualElement as the two\r\n * share data structures.\r\n */\r\nvar SVGVisualElement = /** @class */ (function (_super) {\r\n    __extends(SVGVisualElement, _super);\r\n    function SVGVisualElement() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        /**\r\n         * A mutable record of attributes we want to apply directly to the rendered Element\r\n         * every frame. We use a mutable data structure to reduce GC during animations.\r\n         */\r\n        _this.attrs = {};\r\n        /**\r\n         * We disable hardware acceleration for SVG transforms as they're not currently able to be accelerated.\r\n         */\r\n        _this.defaultConfig = {\r\n            enableHardwareAcceleration: false,\r\n        };\r\n        /**\r\n         * Without duplicating this call from HTMLVisualElement we end up with HTMLVisualElement.defaultConfig\r\n         * being assigned to config\r\n         */\r\n        _this.config = _this.defaultConfig;\r\n        return _this;\r\n    }\r\n    /**\r\n     * Measure the SVG element on mount. This can affect page rendering so there might be a\r\n     * better time to perform this - for instance dynamically only if there's a transform-origin dependent\r\n     * transform being set (like rotate)\r\n     */\r\n    SVGVisualElement.prototype.mount = function (element) {\r\n        _super.prototype.mount.call(this, element);\r\n        this.measure();\r\n    };\r\n    /**\r\n     * Update the SVG dimensions and path length\r\n     */\r\n    SVGVisualElement.prototype.measure = function () {\r\n        try {\r\n            this.dimensions =\r\n                typeof this.element.getBBox ===\r\n                    \"function\"\r\n                    ? this.element.getBBox()\r\n                    : this.element.getBoundingClientRect();\r\n        }\r\n        catch (e) {\r\n            // Most likely trying to measure an unrendered element under Firefox\r\n            this.dimensions = { x: 0, y: 0, width: 0, height: 0 };\r\n        }\r\n        if (isPath(this.element)) {\r\n            this.totalPathLength = this.element.getTotalLength();\r\n        }\r\n    };\r\n    /**\r\n     * Empty the mutable data structures in case attrs have been removed between renders.\r\n     */\r\n    SVGVisualElement.prototype.clean = function () {\r\n        _super.prototype.clean.call(this);\r\n        this.attrs = {};\r\n    };\r\n    /**\r\n     * Read an attribute directly from the SVGElement\r\n     */\r\n    SVGVisualElement.prototype.read = function (key) {\r\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\r\n        return this.element.getAttribute(key);\r\n    };\r\n    SVGVisualElement.prototype.build = function () {\r\n        buildSVGAttrs(this.latest, this.style, this.vars, this.attrs, this.transform, this.transformOrigin, this.transformKeys, this.config, this.dimensions, this.totalPathLength);\r\n    };\r\n    SVGVisualElement.prototype.render = function () {\r\n        // Update HTML styles and CSS variables\r\n        _super.prototype.render.call(this);\r\n        // Loop through attributes and apply them to the SVGElement\r\n        for (var key in this.attrs) {\r\n            this.element.setAttribute(camelToDash(key), this.attrs[key]);\r\n        }\r\n    };\r\n    return SVGVisualElement;\r\n}(HTMLVisualElement));\r\nfunction isPath(element) {\r\n    return element.tagName === \"path\";\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\n/**\r\n * @internal\r\n */\r\nvar svgElements = [\r\n    \"animate\",\r\n    \"circle\",\r\n    \"clipPath\",\r\n    \"defs\",\r\n    \"desc\",\r\n    \"ellipse\",\r\n    \"feBlend\",\r\n    \"feColorMatrix\",\r\n    \"feComponentTransfer\",\r\n    \"feComposite\",\r\n    \"feConvolveMatrix\",\r\n    \"feDiffuseLighting\",\r\n    \"feDisplacementMap\",\r\n    \"feDistantLight\",\r\n    \"feDropShadow\",\r\n    \"feFlood\",\r\n    \"feFuncA\",\r\n    \"feFuncB\",\r\n    \"feFuncG\",\r\n    \"feFuncR\",\r\n    \"feGaussianBlur\",\r\n    \"feImage\",\r\n    \"feMerge\",\r\n    \"feMergeNode\",\r\n    \"feMorphology\",\r\n    \"feOffset\",\r\n    \"fePointLight\",\r\n    \"feSpecularLighting\",\r\n    \"feSpotLight\",\r\n    \"feTile\",\r\n    \"feTurbulence\",\r\n    \"filter\",\r\n    \"foreignObject\",\r\n    \"g\",\r\n    \"image\",\r\n    \"line\",\r\n    \"linearGradient\",\r\n    \"marker\",\r\n    \"mask\",\r\n    \"metadata\",\r\n    \"path\",\r\n    \"pattern\",\r\n    \"polygon\",\r\n    \"polyline\",\r\n    \"radialGradient\",\r\n    \"rect\",\r\n    \"stop\",\r\n    \"svg\",\r\n    \"switch\",\r\n    \"symbol\",\r\n    \"text\",\r\n    \"textPath\",\r\n    \"tspan\",\r\n    \"use\",\r\n    \"view\",\r\n];\r\n\r\nvar svgTagNames = new Set(svgElements);\r\n/**\r\n * Determine whether this is a HTML or SVG component based on if the provided\r\n * Component is a string and a recognised SVG tag. A potentially better way to\r\n * do this would be to offer a `motion.customSVG` function and determine this\r\n * when we generate the `motion.circle` etc components.\r\n */\r\nfunction isSVGComponent(Component) {\r\n    return typeof Component === \"string\" && svgTagNames.has(Component);\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nvar PresenceContext = createContext(null);\r\n\r\n/**\r\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\r\n * to access information about whether it's still present in the React tree.\r\n *\r\n * ```jsx\r\n * import { usePresence } from \"framer-motion\"\r\n *\r\n * export const Component = () => {\r\n *   const [isPresent, safeToRemove] = usePresence()\r\n *\r\n *   useEffect(() => {\r\n *     !isPresent setTimeout(safeToRemove, 1000)\r\n *   }, [isPresent])\r\n *\r\n *   return <div />\r\n * }\r\n * ```\r\n *\r\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\r\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\r\n *\r\n * @public\r\n */\r\nfunction usePresence() {\r\n    var context = useContext(PresenceContext);\r\n    if (context === null)\r\n        return [true, null];\r\n    var isPresent = context.isPresent, onExitComplete = context.onExitComplete, register = context.register;\r\n    // It's safe to call the following hooks conditionally (after an early return) because the context will always\r\n    // either be null or non-null for the lifespan of the component.\r\n    // Replace with useOpaqueId when released in React\r\n    var id = useUniqueId();\r\n    useEffect(function () { return register(id); }, []);\r\n    var safeToRemove = function () { return onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete(id); };\r\n    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\r\n}\r\n/**\r\n * @public\r\n */\r\nfunction useIsPresent() {\r\n    var context = useContext(PresenceContext);\r\n    return context === null ? true : context.isPresent;\r\n}\r\nvar counter = 0;\r\nvar incrementId = function () { return counter++; };\r\nvar useUniqueId = function () { return useConstant(incrementId); };\r\n\r\n/**\r\n * DOM-flavoured variation of the useVisualElement hook. Used to create either a HTMLVisualElement\r\n * or SVGVisualElement for the component.\r\n */\r\nvar useDomVisualElement = function (Component, props, parent, isStatic, ref) {\r\n    var visualElement = useConstant(function () {\r\n        var DOMVisualElement = isSVGComponent(Component)\r\n            ? SVGVisualElement\r\n            : HTMLVisualElement;\r\n        return new DOMVisualElement(parent, ref);\r\n    });\r\n    visualElement.updateConfig(__assign({ enableHardwareAcceleration: !isStatic }, props));\r\n    visualElement.layoutId = props.layoutId;\r\n    var isPresent = useIsPresent();\r\n    visualElement.isPresent =\r\n        props.isPresent !== undefined ? props.isPresent : isPresent;\r\n    return visualElement;\r\n};\r\n\r\n/**\r\n * A list of all valid MotionProps.\r\n *\r\n * @internalremarks\r\n * This doesn't throw if a `MotionProp` name is missing - it should.\r\n */\r\nvar validMotionProps = new Set([\r\n    \"initial\",\r\n    \"animate\",\r\n    \"exit\",\r\n    \"style\",\r\n    \"variants\",\r\n    \"transition\",\r\n    \"transformTemplate\",\r\n    \"transformValues\",\r\n    \"custom\",\r\n    \"inherit\",\r\n    \"static\",\r\n    \"layout\",\r\n    \"layoutId\",\r\n    \"onLayoutAnimationComplete\",\r\n    \"onViewportBoxUpdate\",\r\n    \"onAnimationStart\",\r\n    \"onAnimationComplete\",\r\n    \"onUpdate\",\r\n    \"onDragStart\",\r\n    \"onDrag\",\r\n    \"onDragEnd\",\r\n    \"onMeasureDragConstraints\",\r\n    \"onDirectionLock\",\r\n    \"onDragTransitionEnd\",\r\n    \"drag\",\r\n    \"dragControls\",\r\n    \"dragListener\",\r\n    \"dragConstraints\",\r\n    \"dragDirectionLock\",\r\n    \"dragElastic\",\r\n    \"dragMomentum\",\r\n    \"dragPropagation\",\r\n    \"dragTransition\",\r\n    \"onPan\",\r\n    \"onPanStart\",\r\n    \"onPanEnd\",\r\n    \"onPanSessionStart\",\r\n    \"onTap\",\r\n    \"onTapStart\",\r\n    \"onTapCancel\",\r\n    \"whileHover\",\r\n    \"whileTap\",\r\n    \"onHoverEnd\",\r\n    \"onHoverStart\",\r\n]);\r\n/**\r\n * Check whether a prop name is a valid `MotionProp` key.\r\n *\r\n * @param key - Name of the property to check\r\n * @returns `true` is key is a valid `MotionProp`.\r\n *\r\n * @public\r\n */\r\nfunction isValidMotionProp(key) {\r\n    return validMotionProps.has(key);\r\n}\r\n\r\nvar isPropValid = function (key) { return !isValidMotionProp(key); };\r\n/**\r\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\r\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\r\n * of these should be passed to the underlying DOM node.\r\n *\r\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\r\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\r\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\r\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\r\n *\r\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\r\n * actually required.\r\n */\r\ntry {\r\n    var emotionIsPropValid_1 = require(\"@emotion/is-prop-valid\").default;\r\n    isPropValid = function (key) {\r\n        // Handle events explicitly as Emotion validates them all as true\r\n        if (key.startsWith(\"on\")) {\r\n            return !isValidMotionProp(key);\r\n        }\r\n        else {\r\n            return emotionIsPropValid_1(key);\r\n        }\r\n    };\r\n}\r\ncatch (_a) {\r\n    // We don't need to actually do anything here - the fallback is the existing `isPropValid`.\r\n}\r\nfunction filterProps(props) {\r\n    var domProps = {};\r\n    for (var key in props) {\r\n        if (isPropValid(key))\r\n            domProps[key] = props[key];\r\n    }\r\n    return domProps;\r\n}\r\n\r\nfunction buildHTMLProps(visualElement, _a) {\r\n    var drag = _a.drag;\r\n    // The `any` isn't ideal but it is the type of createElement props argument\r\n    var htmlProps = {\r\n        style: __assign(__assign(__assign({}, visualElement.reactStyle), visualElement.style), visualElement.vars),\r\n    };\r\n    if (!!drag) {\r\n        // Disable text selection\r\n        htmlProps.style.userSelect = \"none\";\r\n        // Disable the ghost element when a user drags\r\n        htmlProps.draggable = false;\r\n    }\r\n    return htmlProps;\r\n}\r\n\r\n/**\r\n * Build React props for SVG elements\r\n */\r\nfunction buildSVGProps(visualElement) {\r\n    return __assign(__assign({}, visualElement.attrs), { style: __assign({}, visualElement.reactStyle) });\r\n}\r\n\r\nfunction render(Component, props, visualElement) {\r\n    // Only filter props from components we control, ie `motion.div`. If this\r\n    // is a custom component pass along everything provided to it.\r\n    var forwardedProps = typeof Component === \"string\" ? filterProps(props) : props;\r\n    /**\r\n     * Every render, empty and rebuild the animated values to be applied to our Element.\r\n     * During animation these data structures are used in a mutable fashion to reduce\r\n     * garbage collection, but between renders we can flush them to remove values\r\n     * that might have been taken out of the provided props.\r\n     */\r\n    visualElement.clean();\r\n    visualElement.build(true);\r\n    // Generate props to visually render this component\r\n    var visualProps = isSVGComponent(Component)\r\n        ? buildSVGProps(visualElement)\r\n        : buildHTMLProps(visualElement, props);\r\n    return createElement(Component, __assign(__assign(__assign({}, forwardedProps), { ref: visualElement.ref }), visualProps));\r\n}\r\n\r\nfunction isCSSVariable$1(value) {\r\n    return typeof value === \"string\" && value.startsWith(\"var(--\");\r\n}\r\n/**\r\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\r\n *\r\n * ```\r\n * `var(--foo, #fff)` => [`--foo`, '#fff']\r\n * ```\r\n *\r\n * @param current\r\n */\r\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\r\nfunction parseCSSVariable(current) {\r\n    var match = cssVariableRegex.exec(current);\r\n    if (!match)\r\n        return [,];\r\n    var token = match[1], fallback = match[2];\r\n    return [token, fallback];\r\n}\r\nvar maxDepth = 4;\r\nfunction getVariableValue(current, element, depth) {\r\n    if (depth === void 0) { depth = 1; }\r\n    invariant(depth <= maxDepth, \"Max CSS variable fallback depth detected in property \\\"\" + current + \"\\\". This may indicate a circular fallback dependency.\");\r\n    var _a = parseCSSVariable(current), token = _a[0], fallback = _a[1];\r\n    // No CSS variable detected\r\n    if (!token)\r\n        return;\r\n    // Attempt to read this CSS variable off the element\r\n    var resolved = window.getComputedStyle(element).getPropertyValue(token);\r\n    if (resolved) {\r\n        return resolved;\r\n    }\r\n    else if (isCSSVariable$1(fallback)) {\r\n        // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\r\n        return getVariableValue(fallback, element, depth + 1);\r\n    }\r\n    else {\r\n        return fallback;\r\n    }\r\n}\r\n/**\r\n * Resolve CSS variables from\r\n *\r\n * @internal\r\n */\r\nfunction resolveCSSVariables(visualElement, _a, transitionEnd) {\r\n    var target = __rest(_a, []);\r\n    var element = visualElement.getInstance();\r\n    if (!(element instanceof HTMLElement))\r\n        return { target: target, transitionEnd: transitionEnd };\r\n    // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\r\n    // only if they change but I think this reads clearer and this isn't a performance-critical path.\r\n    if (transitionEnd) {\r\n        transitionEnd = __assign({}, transitionEnd);\r\n    }\r\n    // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\r\n    visualElement.forEachValue(function (value) {\r\n        var current = value.get();\r\n        if (!isCSSVariable$1(current))\r\n            return;\r\n        var resolved = getVariableValue(current, element);\r\n        if (resolved)\r\n            value.set(resolved);\r\n    });\r\n    // Cycle through every target property and resolve CSS variables. Currently\r\n    // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\r\n    for (var key in target) {\r\n        var current = target[key];\r\n        if (!isCSSVariable$1(current))\r\n            continue;\r\n        var resolved = getVariableValue(current, element);\r\n        if (!resolved)\r\n            continue;\r\n        // Clone target if it hasn't already been\r\n        target[key] = resolved;\r\n        // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\r\n        // CSS variable. This will ensure that after the animation the component will reflect\r\n        // changes in the value of the CSS variable.\r\n        if (transitionEnd && transitionEnd[key] === undefined) {\r\n            transitionEnd[key] = current;\r\n        }\r\n    }\r\n    return { target: target, transitionEnd: transitionEnd };\r\n}\r\n\r\nvar positionalKeys = new Set([\r\n    \"width\",\r\n    \"height\",\r\n    \"top\",\r\n    \"left\",\r\n    \"right\",\r\n    \"bottom\",\r\n    \"x\",\r\n    \"y\",\r\n]);\r\nvar isPositionalKey = function (key) { return positionalKeys.has(key); };\r\nvar hasPositionalKey = function (target) {\r\n    return Object.keys(target).some(isPositionalKey);\r\n};\r\nvar setAndResetVelocity = function (value, to) {\r\n    // Looks odd but setting it twice doesn't render, it'll just\r\n    // set both prev and current to the latest value\r\n    value.set(to, false);\r\n    value.set(to);\r\n};\r\nvar isNumOrPxType = function (v) {\r\n    return v === number || v === px;\r\n};\r\nvar BoundingBoxDimension;\r\n(function (BoundingBoxDimension) {\r\n    BoundingBoxDimension[\"width\"] = \"width\";\r\n    BoundingBoxDimension[\"height\"] = \"height\";\r\n    BoundingBoxDimension[\"left\"] = \"left\";\r\n    BoundingBoxDimension[\"right\"] = \"right\";\r\n    BoundingBoxDimension[\"top\"] = \"top\";\r\n    BoundingBoxDimension[\"bottom\"] = \"bottom\";\r\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\r\nvar getPosFromMatrix = function (matrix, pos) {\r\n    return parseFloat(matrix.split(\", \")[pos]);\r\n};\r\nvar getTranslateFromMatrix = function (pos2, pos3) { return function (_bbox, _a) {\r\n    var transform = _a.transform;\r\n    if (transform === \"none\" || !transform)\r\n        return 0;\r\n    var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\r\n    if (matrix3d) {\r\n        return getPosFromMatrix(matrix3d[1], pos3);\r\n    }\r\n    else {\r\n        var matrix = transform.match(/^matrix\\((.+)\\)$/);\r\n        if (matrix) {\r\n            return getPosFromMatrix(matrix[1], pos2);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n}; };\r\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\r\nvar nonTranslationalTransformKeys = transformProps.filter(function (key) { return !transformKeys.has(key); });\r\nfunction removeNonTranslationalTransform(visualElement) {\r\n    var removedTransforms = [];\r\n    nonTranslationalTransformKeys.forEach(function (key) {\r\n        var value = visualElement.getValue(key);\r\n        if (value !== undefined) {\r\n            removedTransforms.push([key, value.get()]);\r\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\r\n        }\r\n    });\r\n    // Apply changes to element before measurement\r\n    if (removedTransforms.length)\r\n        visualElement.render();\r\n    return removedTransforms;\r\n}\r\nvar positionalValues = {\r\n    // Dimensions\r\n    width: function (_a) {\r\n        var x = _a.x;\r\n        return x.max - x.min;\r\n    },\r\n    height: function (_a) {\r\n        var y = _a.y;\r\n        return y.max - y.min;\r\n    },\r\n    top: function (_bbox, _a) {\r\n        var top = _a.top;\r\n        return parseFloat(top);\r\n    },\r\n    left: function (_bbox, _a) {\r\n        var left = _a.left;\r\n        return parseFloat(left);\r\n    },\r\n    bottom: function (_a, _b) {\r\n        var y = _a.y;\r\n        var top = _b.top;\r\n        return parseFloat(top) + (y.max - y.min);\r\n    },\r\n    right: function (_a, _b) {\r\n        var x = _a.x;\r\n        var left = _b.left;\r\n        return parseFloat(left) + (x.max - x.min);\r\n    },\r\n    // Transform\r\n    x: getTranslateFromMatrix(4, 13),\r\n    y: getTranslateFromMatrix(5, 14),\r\n};\r\nvar convertChangedValueTypes = function (target, visualElement, changedKeys) {\r\n    var originBbox = visualElement.getBoundingBox();\r\n    var elementComputedStyle = visualElement.getComputedStyle();\r\n    var display = elementComputedStyle.display, top = elementComputedStyle.top, left = elementComputedStyle.left, bottom = elementComputedStyle.bottom, right = elementComputedStyle.right, transform = elementComputedStyle.transform;\r\n    var originComputedStyle = { top: top, left: left, bottom: bottom, right: right, transform: transform };\r\n    // If the element is currently set to display: \"none\", make it visible before\r\n    // measuring the target bounding box\r\n    if (display === \"none\") {\r\n        visualElement.setStaticValues(\"display\", target.display || \"block\");\r\n    }\r\n    // Apply the latest values (as set in checkAndConvertChangedValueTypes)\r\n    visualElement.render();\r\n    var targetBbox = visualElement.getBoundingBox();\r\n    changedKeys.forEach(function (key) {\r\n        // Restore styles to their **calculated computed style**, not their actual\r\n        // originally set style. This allows us to animate between equivalent pixel units.\r\n        var value = visualElement.getValue(key);\r\n        setAndResetVelocity(value, positionalValues[key](originBbox, originComputedStyle));\r\n        target[key] = positionalValues[key](targetBbox, elementComputedStyle);\r\n    });\r\n    return target;\r\n};\r\nvar checkAndConvertChangedValueTypes = function (visualElement, target, origin, transitionEnd) {\r\n    if (origin === void 0) { origin = {}; }\r\n    if (transitionEnd === void 0) { transitionEnd = {}; }\r\n    target = __assign({}, target);\r\n    transitionEnd = __assign({}, transitionEnd);\r\n    var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\r\n    // We want to remove any transform values that could affect the element's bounding box before\r\n    // it's measured. We'll reapply these later.\r\n    var removedTransformValues = [];\r\n    var hasAttemptedToRemoveTransformValues = false;\r\n    var changedValueTypeKeys = [];\r\n    targetPositionalKeys.forEach(function (key) {\r\n        var value = visualElement.getValue(key);\r\n        if (!visualElement.hasValue(key))\r\n            return;\r\n        var from = origin[key];\r\n        var to = target[key];\r\n        var fromType = findDimensionValueType(from);\r\n        var toType;\r\n        // TODO: The current implementation of this basically throws an error\r\n        // if you try and do value conversion via keyframes. There's probably\r\n        // a way of doing this but the performance implications would need greater scrutiny,\r\n        // as it'd be doing multiple resize-remeasure operations.\r\n        if (isKeyframesTarget(to)) {\r\n            var numKeyframes = to.length;\r\n            for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {\r\n                if (!toType) {\r\n                    toType = findDimensionValueType(to[i]);\r\n                    invariant(toType === fromType ||\r\n                        (isNumOrPxType(fromType) && isNumOrPxType(toType)), \"Keyframes must be of the same dimension as the current value\");\r\n                }\r\n                else {\r\n                    invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            toType = findDimensionValueType(to);\r\n        }\r\n        if (fromType !== toType) {\r\n            // If they're both just number or px, convert them both to numbers rather than\r\n            // relying on resize/remeasure to convert (which is wasteful in this situation)\r\n            if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\r\n                var current = value.get();\r\n                if (typeof current === \"string\") {\r\n                    value.set(parseFloat(current));\r\n                }\r\n                if (typeof to === \"string\") {\r\n                    target[key] = parseFloat(to);\r\n                }\r\n                else if (Array.isArray(to) && toType === px) {\r\n                    target[key] = to.map(parseFloat);\r\n                }\r\n            }\r\n            else {\r\n                // If we're going to do value conversion via DOM measurements, we first\r\n                // need to remove non-positional transform values that could affect the bbox measurements.\r\n                if (!hasAttemptedToRemoveTransformValues) {\r\n                    removedTransformValues = removeNonTranslationalTransform(visualElement);\r\n                    hasAttemptedToRemoveTransformValues = true;\r\n                }\r\n                changedValueTypeKeys.push(key);\r\n                transitionEnd[key] =\r\n                    transitionEnd[key] !== undefined\r\n                        ? transitionEnd[key]\r\n                        : target[key];\r\n                setAndResetVelocity(value, to);\r\n            }\r\n        }\r\n    });\r\n    if (changedValueTypeKeys.length) {\r\n        var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\r\n        // If we removed transform values, reapply them before the next render\r\n        if (removedTransformValues.length) {\r\n            removedTransformValues.forEach(function (_a) {\r\n                var key = _a[0], value = _a[1];\r\n                visualElement.getValue(key).set(value);\r\n            });\r\n        }\r\n        // Reapply original values\r\n        visualElement.render();\r\n        return { target: convertedTarget, transitionEnd: transitionEnd };\r\n    }\r\n    else {\r\n        return { target: target, transitionEnd: transitionEnd };\r\n    }\r\n};\r\n/**\r\n * Convert value types for x/y/width/height/top/left/bottom/right\r\n *\r\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\r\n *\r\n * @internal\r\n */\r\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\r\n    return hasPositionalKey(target)\r\n        ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd)\r\n        : { target: target, transitionEnd: transitionEnd };\r\n}\r\n\r\n/**\r\n * Parse a DOM variant to make it animatable. This involves resolving CSS variables\r\n * and ensuring animations like \"20%\" => \"calc(50vw)\" are performed in pixels.\r\n */\r\nvar parseDomVariant = function (visualElement, target, origin, transitionEnd) {\r\n    var resolved = resolveCSSVariables(visualElement, target, transitionEnd);\r\n    target = resolved.target;\r\n    transitionEnd = resolved.transitionEnd;\r\n    return unitConversion(visualElement, target, origin, transitionEnd);\r\n};\r\n\r\n/**\r\n * Use callback either only on the initial render or on all renders. In concurrent mode\r\n * the \"initial\" render might run multiple times\r\n *\r\n * @param callback - Callback to run\r\n * @param isInitialOnly - Set to `true` to only run on initial render, or `false` for all renders. Defaults to `false`.\r\n *\r\n * @public\r\n */\r\nfunction useInitialOrEveryRender(callback, isInitialOnly) {\r\n    if (isInitialOnly === void 0) { isInitialOnly = false; }\r\n    var isInitialRender = useRef(true);\r\n    if (!isInitialOnly || (isInitialOnly && isInitialRender.current)) {\r\n        callback();\r\n    }\r\n    isInitialRender.current = false;\r\n}\r\n\r\n/**\r\n * Control animations on one or more components.\r\n *\r\n * @public\r\n */\r\nvar AnimationControls = /** @class */ (function () {\r\n    function AnimationControls() {\r\n        /**\r\n         * Track whether the host component has mounted.\r\n         *\r\n         * @internal\r\n         */\r\n        this.hasMounted = false;\r\n        /**\r\n         * Pending animations that are started before a component is mounted.\r\n         *\r\n         * @internal\r\n         */\r\n        this.pendingAnimations = [];\r\n        /**\r\n         * A collection of linked component animation controls.\r\n         *\r\n         * @internal\r\n         */\r\n        this.componentControls = new Set();\r\n    }\r\n    /**\r\n     * Set variants on this and all child components.\r\n     *\r\n     * @param variants - The variants to set\r\n     *\r\n     * @internal\r\n     */\r\n    AnimationControls.prototype.setVariants = function (variants) {\r\n        this.variants = variants;\r\n        this.componentControls.forEach(function (controls) {\r\n            return controls.setVariants(variants);\r\n        });\r\n    };\r\n    /**\r\n     * Set a default transition on this and all child components\r\n     *\r\n     * @param transition - The default transition to set\r\n     *\r\n     * @internal\r\n     */\r\n    AnimationControls.prototype.setDefaultTransition = function (transition) {\r\n        this.defaultTransition = transition;\r\n        this.componentControls.forEach(function (controls) {\r\n            return controls.setDefaultTransition(transition);\r\n        });\r\n    };\r\n    /**\r\n     * Subscribes a component's animation controls to this.\r\n     *\r\n     * @param controls - The controls to subscribe\r\n     * @returns An unsubscribe function.\r\n     *\r\n     * @internal\r\n     */\r\n    AnimationControls.prototype.subscribe = function (controls) {\r\n        var _this = this;\r\n        this.componentControls.add(controls);\r\n        if (this.variants)\r\n            controls.setVariants(this.variants);\r\n        if (this.defaultTransition)\r\n            controls.setDefaultTransition(this.defaultTransition);\r\n        return function () { return _this.componentControls.delete(controls); };\r\n    };\r\n    /**\r\n     * Starts an animation on all linked components.\r\n     *\r\n     * @remarks\r\n     *\r\n     * ```jsx\r\n     * controls.start(\"variantLabel\")\r\n     * controls.start({\r\n     *   x: 0,\r\n     *   transition: { duration: 1 }\r\n     * })\r\n     * ```\r\n     *\r\n     * @param definition - Properties or variant label to animate to\r\n     * @param transition - Optional `transtion` to apply to a variant\r\n     * @returns - A `Promise` that resolves when all animations have completed.\r\n     *\r\n     * @public\r\n     */\r\n    AnimationControls.prototype.start = function (definition, transitionOverride) {\r\n        var _this = this;\r\n        if (this.hasMounted) {\r\n            var animations_1 = [];\r\n            this.componentControls.forEach(function (controls) {\r\n                var animation = controls.start(definition, {\r\n                    transitionOverride: transitionOverride,\r\n                });\r\n                animations_1.push(animation);\r\n            });\r\n            return Promise.all(animations_1);\r\n        }\r\n        else {\r\n            return new Promise(function (resolve) {\r\n                _this.pendingAnimations.push({\r\n                    animation: [definition, transitionOverride],\r\n                    resolve: resolve,\r\n                });\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Instantly set to a set of properties or a variant.\r\n     *\r\n     * ```jsx\r\n     * // With properties\r\n     * controls.set({ opacity: 0 })\r\n     *\r\n     * // With variants\r\n     * controls.set(\"hidden\")\r\n     * ```\r\n     *\r\n     * @internalremarks\r\n     * We could perform a similar trick to `.start` where this can be called before mount\r\n     * and we maintain a list of of pending actions that get applied on mount. But the\r\n     * expectation of `set` is that it happens synchronously and this would be difficult\r\n     * to do before any children have even attached themselves. It's also poor practise\r\n     * and we should discourage render-synchronous `.start` calls rather than lean into this.\r\n     *\r\n     * @public\r\n     */\r\n    AnimationControls.prototype.set = function (definition) {\r\n        invariant(this.hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\r\n        return this.componentControls.forEach(function (controls) {\r\n            return controls.apply(definition);\r\n        });\r\n    };\r\n    /**\r\n     * Stops animations on all linked components.\r\n     *\r\n     * ```jsx\r\n     * controls.stop()\r\n     * ```\r\n     *\r\n     * @public\r\n     */\r\n    AnimationControls.prototype.stop = function () {\r\n        this.componentControls.forEach(function (controls) { return controls.stop(); });\r\n    };\r\n    /**\r\n     * Initialises the animation controls.\r\n     *\r\n     * @internal\r\n     */\r\n    AnimationControls.prototype.mount = function () {\r\n        var _this = this;\r\n        this.hasMounted = true;\r\n        this.pendingAnimations.forEach(function (_a) {\r\n            var animation = _a.animation, resolve = _a.resolve;\r\n            return _this.start.apply(_this, animation).then(resolve);\r\n        });\r\n    };\r\n    /**\r\n     * Stops all child animations when the host component unmounts.\r\n     *\r\n     * @internal\r\n     */\r\n    AnimationControls.prototype.unmount = function () {\r\n        this.hasMounted = false;\r\n        this.stop();\r\n    };\r\n    return AnimationControls;\r\n}());\r\n/**\r\n * @internal\r\n */\r\nvar animationControls = function () { return new AnimationControls(); };\r\n\r\n/**\r\n * @internal\r\n */\r\nvar MotionContext = createContext({\r\n    static: false,\r\n});\r\nvar isVariantLabel = function (v) {\r\n    return typeof v === \"string\" || Array.isArray(v);\r\n};\r\nvar isAnimationControls = function (v) {\r\n    return v instanceof AnimationControls;\r\n};\r\n/**\r\n * Set up the context for children motion components.\r\n *\r\n * We also use this opportunity to apply `initial` values\r\n */\r\nvar useMotionContext = function (parentContext, controls, visualElement, isStatic, _a) {\r\n    if (isStatic === void 0) { isStatic = false; }\r\n    var initial = _a.initial, animate = _a.animate, variants = _a.variants, whileTap = _a.whileTap, whileHover = _a.whileHover, layoutId = _a.layoutId;\r\n    // Determine whether this is a root element of an AnimatePresence component\r\n    var presenceContext = useContext(PresenceContext);\r\n    var presenceId = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id;\r\n    visualElement.isPresenceRoot = parentContext.presenceId !== presenceId;\r\n    // Override initial with that from a parent context, if defined\r\n    if ((presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) !== undefined) {\r\n        initial = presenceContext.initial;\r\n    }\r\n    var initialState;\r\n    if (initial === false && !isAnimationControls(animate)) {\r\n        initialState = animate;\r\n    }\r\n    else if (typeof initial !== \"boolean\") {\r\n        initialState = initial;\r\n    }\r\n    // Track mounted status so children can detect whether they were present during their\r\n    // parent's first render\r\n    var hasMounted = useRef(false);\r\n    // We propagate this component's VisualElementAnimationControls *if* we're being provided variants,\r\n    // if we're being used to control variants, or if we're being passed animation controls.\r\n    // Otherwise this component should be \"invisible\" to variant propagation. This is a slight concession\r\n    // to Framer X where every `Frame` is a `motion` component and it might be if we change that in the future\r\n    // that this restriction is removed.\r\n    var shouldPropagateControls = variants ||\r\n        isVariantLabel(animate) ||\r\n        isVariantLabel(whileTap) ||\r\n        isVariantLabel(whileHover) ||\r\n        isAnimationControls(animate);\r\n    // If this component's `initial` prop is a variant label, propagate it. Otherwise pass the parent's.\r\n    var targetInitial = isVariantLabel(initialState)\r\n        ? initialState\r\n        : parentContext.initial;\r\n    // If this is a variant tree we need to propagate the `animate` prop in case new children are added after\r\n    // the tree initially animates.\r\n    var targetAnimate = isVariantLabel(animate)\r\n        ? animate\r\n        : parentContext.animate;\r\n    // Only allow `initial` to trigger context re-renders if this is a `static` component (ie we're on the Framer canvas)\r\n    // or in another non-animation/interaction environment.\r\n    var initialDependency = isStatic ? targetInitial : null;\r\n    // Only allow `animate` to trigger context re-renders if it's a variant label. If this is an array of\r\n    // variant labels there's probably an optimisation to deep-compare but it might be an over-optimisation.\r\n    // We want to do this as we rely on React's component rendering order each render cycle to determine\r\n    // the new order of any child components for the `staggerChildren` functionality.\r\n    var animateDependency = shouldPropagateControls && isVariantLabel(targetAnimate)\r\n        ? targetAnimate\r\n        : null;\r\n    // The context to provide to the child. We `useMemo` because although `controls` and `initial` are\r\n    // unlikely to change, by making the context an object it'll be considered a new value every render.\r\n    // So all child motion components will re-render as a result.\r\n    var context = useMemo(function () { return ({\r\n        controls: shouldPropagateControls\r\n            ? controls\r\n            : parentContext.controls,\r\n        initial: targetInitial,\r\n        animate: targetAnimate,\r\n        visualElement: visualElement,\r\n        hasMounted: hasMounted,\r\n        isReducedMotion: parentContext.isReducedMotion,\r\n        presenceId: presenceId,\r\n    }); }, [\r\n        initialDependency,\r\n        animateDependency,\r\n        parentContext.isReducedMotion,\r\n        animate,\r\n        layoutId,\r\n        presenceId,\r\n    ]);\r\n    // Update the `static` property every render. This is unlikely to change but also essentially free.\r\n    context.static = isStatic;\r\n    // Set initial state. If this is a static component (ie in Framer canvas), respond to updates\r\n    // in `initial`.\r\n    useInitialOrEveryRender(function () {\r\n        var initialToApply = initialState || parentContext.initial;\r\n        initialToApply && controls.apply(initialToApply);\r\n    }, !isStatic);\r\n    useEffect(function () {\r\n        hasMounted.current = true;\r\n    }, []);\r\n    return context;\r\n};\r\n\r\nvar checkShouldInheritVariant = function (_a) {\r\n    var animate = _a.animate, variants = _a.variants, _b = _a.inherit, inherit = _b === void 0 ? true : _b;\r\n    return (inherit &&\r\n        !!variants &&\r\n        (!animate || animate instanceof AnimationControls));\r\n};\r\n\r\nvar isMotionValue = function (value) {\r\n    return value instanceof MotionValue;\r\n};\r\n\r\n/**\r\n * Scrape props for MotionValues and add/remove them to this component's\r\n * VisualElement\r\n */\r\nfunction useMotionValues(visualElement, props) {\r\n    var prev = useConstant(empty);\r\n    /**\r\n     * Remove MotionValues that are no longer present\r\n     */\r\n    for (var key in prev) {\r\n        var isTransform = isTransformProp(key) || isTransformOriginProp(key);\r\n        var existsAsProp = props[key];\r\n        var existsAsStyle = props.style && props.style[key];\r\n        var propIsMotionValue = existsAsProp && isMotionValue(props[key]);\r\n        var styleIsMotionValue = existsAsStyle && isMotionValue(props.style[key]);\r\n        var transformRemoved = isTransform && !existsAsProp && !existsAsStyle;\r\n        var motionValueRemoved = !isTransform && !propIsMotionValue && !styleIsMotionValue;\r\n        if (transformRemoved || motionValueRemoved) {\r\n            visualElement.removeValue(key);\r\n            delete prev[key];\r\n        }\r\n    }\r\n    /**\r\n     * Add incoming MotionValues\r\n     */\r\n    addMotionValues(visualElement, prev, props);\r\n    if (props.style)\r\n        addMotionValues(visualElement, prev, props.style, true);\r\n    /**\r\n     * Transform custom values if provided a handler, ie size -> width/height\r\n     * Ideally we'd ditch this by removing support for size and other custom values from Framer.\r\n     */\r\n    if (props.transformValues) {\r\n        visualElement.reactStyle = props.transformValues(visualElement.reactStyle);\r\n    }\r\n}\r\n/**\r\n * Add incoming MotionValues\r\n *\r\n * TODO: Type the VisualElements properly\r\n */\r\nfunction addMotionValues(visualElement, prev, source, isStyle) {\r\n    if (isStyle === void 0) { isStyle = false; }\r\n    if (isStyle)\r\n        visualElement.reactStyle = {};\r\n    for (var key in source) {\r\n        var value = source[key];\r\n        var foundMotionValue = false;\r\n        if (isMotionValue(value)) {\r\n            // If this is a MotionValue, add it if it isn't a reserved key\r\n            if (!reservedNames.has(key)) {\r\n                visualElement.addValue(key, value);\r\n                foundMotionValue = true;\r\n            }\r\n        }\r\n        else if (isTransformProp(key) || isTransformOriginProp(key)) {\r\n            // If this is a transform prop, always create a MotionValue\r\n            // to ensure we can reconcile them all together.\r\n            if (!visualElement.hasValue(key)) {\r\n                visualElement.addValue(key, motionValue(value));\r\n            }\r\n            else if (value !== prev[key]) {\r\n                // If the MotionValue already exists, update it with the\r\n                // latest incoming value\r\n                var motion = visualElement.getValue(key);\r\n                motion.set(value);\r\n            }\r\n            foundMotionValue = true;\r\n        }\r\n        else if (isStyle) {\r\n            visualElement.reactStyle[key] = value;\r\n        }\r\n        if (foundMotionValue)\r\n            prev[key] = value;\r\n    }\r\n}\r\n/**\r\n * These are props we accept as MotionValues but don't want to add\r\n * to the VisualElement\r\n */\r\nvar reservedNames = new Set([]);\r\nvar empty = function () { return ({}); };\r\n\r\nvar isCustomValue = function (v) {\r\n    return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\r\n};\r\nvar resolveFinalValueInKeyframes = function (v) {\r\n    // TODO maybe throw if v.length - 1 is placeholder token?\r\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\r\n};\r\n\r\n/**\r\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\r\n */\r\nvar isNumericalString = function (v) { return /^\\-?\\d*\\.?\\d+$/.test(v); };\r\n\r\n/**\r\n * Get the current value of every `MotionValue` in a `VisualElement`\r\n */\r\nvar getCurrent = function (visualElement) {\r\n    var current = {};\r\n    visualElement.forEachValue(function (value, key) { return (current[key] = value.get()); });\r\n    return current;\r\n};\r\n/**\r\n * Get the current velocity of every `MotionValue` in a `VisualElement`\r\n */\r\nvar getVelocity = function (visualElement) {\r\n    var velocity = {};\r\n    visualElement.forEachValue(function (value, key) { return (velocity[key] = value.getVelocity()); });\r\n    return velocity;\r\n};\r\n/**\r\n * Check if value is a function that returns a `Target`. A generic typeof === 'function'\r\n * check, just helps with typing.\r\n */\r\nvar isTargetResolver = function (p) {\r\n    return typeof p === \"function\";\r\n};\r\n/**\r\n * Check if value is a list of variant labels\r\n */\r\nvar isVariantLabels = function (v) { return Array.isArray(v); };\r\n/**\r\n * Control animations for a single component\r\n *\r\n * @internal\r\n */\r\nvar VisualElementAnimationControls = /** @class */ (function () {\r\n    function VisualElementAnimationControls(visualElement, _a) {\r\n        var _this = this;\r\n        var makeTargetAnimatable = _a.makeTargetAnimatable;\r\n        /**\r\n         * A reference to the component's latest props. We could probably ditch this in\r\n         * favour to a reference to the `custom` prop now we don't send all props through\r\n         * to target resolvers.\r\n         */\r\n        this.props = {};\r\n        /**\r\n         * The component's variants, as provided by `variants`\r\n         */\r\n        this.variants = {};\r\n        /**\r\n         * A set of values that we animate back to when a value is cleared of all overrides.\r\n         */\r\n        this.baseTarget = {};\r\n        /**\r\n         * A series of target overrides that we can animate to/from when overrides are set/cleared.\r\n         */\r\n        this.overrides = [];\r\n        /**\r\n         * A series of target overrides as they were originally resolved.\r\n         */\r\n        this.resolvedOverrides = [];\r\n        /**\r\n         * A Set of currently active override indexes\r\n         */\r\n        this.activeOverrides = new Set();\r\n        /**\r\n         * A Set of value keys that are currently animating.\r\n         */\r\n        this.isAnimating = new Set();\r\n        /**\r\n         * Check if the associated `VisualElement` has a key with the provided string.\r\n         * Pre-bound to the class so we can provide directly to the `filter` in `checkForNewValues`.\r\n         */\r\n        this.hasValue = function (key) { return !_this.visualElement.hasValue(key); };\r\n        this.visualElement = visualElement;\r\n        this.makeTargetAnimatable = makeTargetAnimatable;\r\n        this.visualElement.forEachValue(function (value, key) { return (_this.baseTarget[key] = value.get()); });\r\n    }\r\n    /**\r\n     * Set the reference to the component's props.\r\n     * @param props -\r\n     */\r\n    VisualElementAnimationControls.prototype.setProps = function (props) {\r\n        this.props = props;\r\n    };\r\n    /**\r\n     * Set the reference to the component's variants\r\n     * @param variants -\r\n     */\r\n    VisualElementAnimationControls.prototype.setVariants = function (variants) {\r\n        if (variants)\r\n            this.variants = variants;\r\n    };\r\n    /**\r\n     * Set the component's default transition\r\n     * @param transition -\r\n     */\r\n    VisualElementAnimationControls.prototype.setDefaultTransition = function (transition) {\r\n        if (transition)\r\n            this.defaultTransition = transition;\r\n    };\r\n    /**\r\n     * Set motion values without animation.\r\n     *\r\n     * @param definition -\r\n     * @param isActive -\r\n     */\r\n    VisualElementAnimationControls.prototype.setValues = function (definition, _a) {\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.isActive, isActive = _c === void 0 ? new Set() : _c, priority = _b.priority;\r\n        var _d = this.resolveVariant(definition), target = _d.target, transitionEnd = _d.transitionEnd;\r\n        target = this.transformValues(__assign(__assign({}, target), transitionEnd));\r\n        for (var key in target) {\r\n            if (isActive.has(key))\r\n                return;\r\n            isActive.add(key);\r\n            if (target) {\r\n                var targetValue = resolveFinalValueInKeyframes(target[key]);\r\n                if (this.visualElement.hasValue(key)) {\r\n                    var value = this.visualElement.getValue(key);\r\n                    value && value.set(targetValue);\r\n                }\r\n                else {\r\n                    this.visualElement.addValue(key, motionValue(targetValue));\r\n                }\r\n                if (!priority)\r\n                    this.baseTarget[key] = targetValue;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Allows `transformValues` to be set by a component that allows us to\r\n     * transform the values in a given `Target`. This allows Framer Library\r\n     * to extend Framer Motion to animate `Color` variables etc. Currently we have\r\n     * to manually support these extended types here in Framer Motion.\r\n     *\r\n     * @param values -\r\n     */\r\n    VisualElementAnimationControls.prototype.transformValues = function (values) {\r\n        var transformValues = this.props.transformValues;\r\n        return transformValues ? transformValues(values) : values;\r\n    };\r\n    /**\r\n     * Check a `Target` for new values we haven't animated yet, and add them\r\n     * to the `MotionValueMap`.\r\n     *\r\n     * Currently there's functionality here that is DOM-specific, we should allow\r\n     * this functionality to be injected by the factory that creates DOM-specific\r\n     * components.\r\n     *\r\n     * @param target -\r\n     */\r\n    VisualElementAnimationControls.prototype.checkForNewValues = function (target) {\r\n        var newValueKeys = Object.keys(target).filter(this.hasValue);\r\n        var numNewValues = newValueKeys.length;\r\n        if (!numNewValues)\r\n            return;\r\n        for (var i = 0; i < numNewValues; i++) {\r\n            var key = newValueKeys[i];\r\n            var targetValue = target[key];\r\n            var value = null;\r\n            // If this is a keyframes value, we can attempt to use the first value in the\r\n            // array as that's going to be the first value of the animation anyway\r\n            if (Array.isArray(targetValue)) {\r\n                value = targetValue[0];\r\n            }\r\n            // If it isn't a keyframes or the first keyframes value was set as `null`, read the\r\n            // value from the DOM. It might be worth investigating whether to check props (for SVG)\r\n            // or props.style (for HTML) if the value exists there before attempting to read.\r\n            if (value === null) {\r\n                var readValue = this.visualElement.readNativeValue(key);\r\n                value = readValue !== undefined ? readValue : target[key];\r\n                invariant(value !== null, \"No initial value for \\\"\" + key + \"\\\" can be inferred. Ensure an initial value for \\\"\" + key + \"\\\" is defined on the component.\");\r\n            }\r\n            if (typeof value === \"string\" && isNumericalString(value)) {\r\n                // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\r\n                value = parseFloat(value);\r\n            }\r\n            else if (!findValueType(value) && complex.test(targetValue)) {\r\n                // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\r\n                value = complex.getAnimatableNone(targetValue);\r\n            }\r\n            this.visualElement.addValue(key, motionValue(value));\r\n            this.baseTarget[key] = value;\r\n        }\r\n    };\r\n    /**\r\n     * Resolve a variant from its label or resolver into an actual `Target` we can animate to.\r\n     * @param variant -\r\n     */\r\n    VisualElementAnimationControls.prototype.resolveVariant = function (variant) {\r\n        if (!variant) {\r\n            return {\r\n                target: undefined,\r\n                transition: undefined,\r\n                transitionEnd: undefined,\r\n            };\r\n        }\r\n        if (isTargetResolver(variant)) {\r\n            // resolve current and velocity\r\n            variant = variant(this.props.custom, getCurrent(this.visualElement), getVelocity(this.visualElement));\r\n        }\r\n        var _a = variant.transition, transition = _a === void 0 ? this.defaultTransition : _a, transitionEnd = variant.transitionEnd, target = __rest(variant, [\"transition\", \"transitionEnd\"]);\r\n        return { transition: transition, transitionEnd: transitionEnd, target: target };\r\n    };\r\n    /**\r\n     * Get the highest active override priority index\r\n     */\r\n    VisualElementAnimationControls.prototype.getHighestPriority = function () {\r\n        if (!this.activeOverrides.size)\r\n            return 0;\r\n        return Math.max.apply(Math, Array.from(this.activeOverrides));\r\n    };\r\n    /**\r\n     * Set an override. We add this layer of indirection so if, for instance, a tap gesture\r\n     * starts and overrides a hover gesture, when we clear the tap gesture and fallback to the\r\n     * hover gesture, if that hover gesture has changed in the meantime we can go to that rather\r\n     * than the one that was resolved when the hover gesture animation started.\r\n     *\r\n     * @param definition -\r\n     * @param overrideIndex -\r\n     */\r\n    VisualElementAnimationControls.prototype.setOverride = function (definition, overrideIndex) {\r\n        this.overrides[overrideIndex] = definition;\r\n        if (this.children) {\r\n            this.children.forEach(function (child) {\r\n                return child.setOverride(definition, overrideIndex);\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Start an override animation.\r\n     * @param overrideIndex -\r\n     */\r\n    VisualElementAnimationControls.prototype.startOverride = function (overrideIndex) {\r\n        var override = this.overrides[overrideIndex];\r\n        if (override) {\r\n            return this.start(override, { priority: overrideIndex });\r\n        }\r\n    };\r\n    /**\r\n     * Clear an override. We check every value we animated to in this override to see if\r\n     * its present on any lower-priority overrides. If not, we animate it back to its base target.\r\n     * @param overrideIndex -\r\n     */\r\n    VisualElementAnimationControls.prototype.clearOverride = function (overrideIndex) {\r\n        var _this = this;\r\n        if (this.children) {\r\n            this.children.forEach(function (child) { return child.clearOverride(overrideIndex); });\r\n        }\r\n        var override = this.overrides[overrideIndex];\r\n        if (!override)\r\n            return;\r\n        this.activeOverrides.delete(overrideIndex);\r\n        var highest = this.getHighestPriority();\r\n        this.resetIsAnimating();\r\n        if (highest) {\r\n            var highestOverride = this.overrides[highest];\r\n            highestOverride && this.startOverride(highest);\r\n        }\r\n        // Figure out which remaining values were affected by the override and animate those\r\n        var overrideTarget = this.resolvedOverrides[overrideIndex];\r\n        if (!overrideTarget)\r\n            return;\r\n        var remainingValues = {};\r\n        for (var key in this.baseTarget) {\r\n            if (overrideTarget[key] !== undefined) {\r\n                remainingValues[key] = this.baseTarget[key];\r\n            }\r\n        }\r\n        this.onStart();\r\n        this.animate(remainingValues).then(function () { return _this.onComplete(); });\r\n    };\r\n    /**\r\n     * Apply a target/variant without any animation\r\n     */\r\n    VisualElementAnimationControls.prototype.apply = function (definition) {\r\n        if (Array.isArray(definition)) {\r\n            return this.applyVariantLabels(definition);\r\n        }\r\n        else if (typeof definition === \"string\") {\r\n            return this.applyVariantLabels([definition]);\r\n        }\r\n        else {\r\n            this.setValues(definition);\r\n        }\r\n    };\r\n    /**\r\n     * Apply variant labels without animation\r\n     */\r\n    VisualElementAnimationControls.prototype.applyVariantLabels = function (variantLabelList) {\r\n        var _this = this;\r\n        var isActive = new Set();\r\n        var reversedList = __spreadArrays(variantLabelList).reverse();\r\n        reversedList.forEach(function (key) {\r\n            var _a = _this.resolveVariant(_this.variants[key]), target = _a.target, transitionEnd = _a.transitionEnd;\r\n            if (transitionEnd) {\r\n                _this.setValues(transitionEnd, { isActive: isActive });\r\n            }\r\n            if (target) {\r\n                _this.setValues(target, { isActive: isActive });\r\n            }\r\n            if (_this.children && _this.children.size) {\r\n                _this.children.forEach(function (child) {\r\n                    return child.applyVariantLabels(variantLabelList);\r\n                });\r\n            }\r\n        });\r\n    };\r\n    VisualElementAnimationControls.prototype.start = function (definition, opts) {\r\n        var _this = this;\r\n        if (opts === void 0) { opts = {}; }\r\n        if (opts.priority) {\r\n            this.activeOverrides.add(opts.priority);\r\n        }\r\n        this.resetIsAnimating(opts.priority);\r\n        var animation;\r\n        if (isVariantLabels(definition)) {\r\n            animation = this.animateVariantLabels(definition, opts);\r\n        }\r\n        else if (typeof definition === \"string\") {\r\n            animation = this.animateVariant(definition, opts);\r\n        }\r\n        else {\r\n            animation = this.animate(definition, opts);\r\n        }\r\n        this.onStart();\r\n        return animation.then(function () { return _this.onComplete(); });\r\n    };\r\n    VisualElementAnimationControls.prototype.animate = function (animationDefinition, _a) {\r\n        var _this = this;\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.delay, delay = _c === void 0 ? 0 : _c, _d = _b.priority, priority = _d === void 0 ? 0 : _d, transitionOverride = _b.transitionOverride;\r\n        var _e = this.resolveVariant(animationDefinition), target = _e.target, transition = _e.transition, transitionEnd = _e.transitionEnd;\r\n        if (transitionOverride) {\r\n            transition = transitionOverride;\r\n        }\r\n        if (!target)\r\n            return Promise.resolve();\r\n        target = this.transformValues(target);\r\n        if (transitionEnd) {\r\n            transitionEnd = this.transformValues(transitionEnd);\r\n        }\r\n        this.checkForNewValues(target);\r\n        var origin = this.transformValues(getOrigin(target, transition, this.visualElement));\r\n        if (this.makeTargetAnimatable) {\r\n            var animatable = this.makeTargetAnimatable(this.visualElement, target, origin, transitionEnd);\r\n            target = animatable.target;\r\n            transitionEnd = animatable.transitionEnd;\r\n        }\r\n        if (priority) {\r\n            this.resolvedOverrides[priority] = target;\r\n        }\r\n        this.checkForNewValues(target);\r\n        var animations = [];\r\n        for (var key in target) {\r\n            var value = this.visualElement.getValue(key);\r\n            if (!value || !target || target[key] === undefined)\r\n                continue;\r\n            var valueTarget = target[key];\r\n            if (!priority) {\r\n                this.baseTarget[key] = resolveFinalValueInKeyframes(valueTarget);\r\n            }\r\n            if (this.isAnimating.has(key))\r\n                continue;\r\n            this.isAnimating.add(key);\r\n            animations.push(startAnimation(key, value, valueTarget, __assign({ delay: delay }, transition)));\r\n        }\r\n        var allAnimations = Promise.all(animations);\r\n        return transitionEnd\r\n            ? allAnimations.then(function () {\r\n                _this.setValues(transitionEnd, { priority: priority });\r\n            })\r\n            : allAnimations;\r\n    };\r\n    VisualElementAnimationControls.prototype.animateVariantLabels = function (variantLabels, opts) {\r\n        var _this = this;\r\n        var animations = __spreadArrays(variantLabels).reverse()\r\n            .map(function (label) { return _this.animateVariant(label, opts); });\r\n        return Promise.all(animations);\r\n    };\r\n    VisualElementAnimationControls.prototype.animateVariant = function (variantLabel, opts) {\r\n        var _this = this;\r\n        var when = false;\r\n        var delayChildren = 0;\r\n        var staggerChildren = 0;\r\n        var staggerDirection = 1;\r\n        var priority = (opts && opts.priority) || 0;\r\n        var variant = this.variants[variantLabel];\r\n        var getAnimations = variant\r\n            ? function () { return _this.animate(variant, opts); }\r\n            : function () { return Promise.resolve(); };\r\n        var getChildrenAnimations = this.children\r\n            ? function () {\r\n                return _this.animateChildren(variantLabel, delayChildren, staggerChildren, staggerDirection, priority);\r\n            }\r\n            : function () { return Promise.resolve(); };\r\n        if (variant && this.children) {\r\n            var transition = this.resolveVariant(variant).transition;\r\n            if (transition) {\r\n                when = transition.when || when;\r\n                delayChildren = transition.delayChildren || delayChildren;\r\n                staggerChildren = transition.staggerChildren || staggerChildren;\r\n                staggerDirection =\r\n                    transition.staggerDirection || staggerDirection;\r\n            }\r\n        }\r\n        if (when) {\r\n            var _a = when === \"beforeChildren\"\r\n                ? [getAnimations, getChildrenAnimations]\r\n                : [getChildrenAnimations, getAnimations], first = _a[0], last = _a[1];\r\n            return first().then(last);\r\n        }\r\n        else {\r\n            return Promise.all([getAnimations(), getChildrenAnimations()]);\r\n        }\r\n    };\r\n    VisualElementAnimationControls.prototype.animateChildren = function (variantLabel, delayChildren, staggerChildren, staggerDirection, priority) {\r\n        if (delayChildren === void 0) { delayChildren = 0; }\r\n        if (staggerChildren === void 0) { staggerChildren = 0; }\r\n        if (staggerDirection === void 0) { staggerDirection = 1; }\r\n        if (priority === void 0) { priority = 0; }\r\n        if (!this.children) {\r\n            return Promise.resolve();\r\n        }\r\n        var animations = [];\r\n        var maxStaggerDuration = (this.children.size - 1) * staggerChildren;\r\n        var generateStaggerDuration = staggerDirection === 1\r\n            ? function (i) { return i * staggerChildren; }\r\n            : function (i) { return maxStaggerDuration - i * staggerChildren; };\r\n        Array.from(this.children).forEach(function (childControls, i) {\r\n            var animation = childControls.animateVariant(variantLabel, {\r\n                priority: priority,\r\n                delay: delayChildren + generateStaggerDuration(i),\r\n            });\r\n            animations.push(animation);\r\n        });\r\n        return Promise.all(animations);\r\n    };\r\n    VisualElementAnimationControls.prototype.onStart = function () {\r\n        var onAnimationStart = this.props.onAnimationStart;\r\n        onAnimationStart && onAnimationStart();\r\n    };\r\n    VisualElementAnimationControls.prototype.onComplete = function () {\r\n        var onAnimationComplete = this.props.onAnimationComplete;\r\n        onAnimationComplete && onAnimationComplete();\r\n    };\r\n    VisualElementAnimationControls.prototype.checkOverrideIsAnimating = function (priority) {\r\n        var numOverrides = this.overrides.length;\r\n        for (var i = priority + 1; i < numOverrides; i++) {\r\n            var resolvedOverride = this.resolvedOverrides[i];\r\n            if (resolvedOverride) {\r\n                for (var key in resolvedOverride) {\r\n                    this.isAnimating.add(key);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    VisualElementAnimationControls.prototype.resetIsAnimating = function (priority) {\r\n        if (priority === void 0) { priority = 0; }\r\n        this.isAnimating.clear();\r\n        // If this isn't the highest priority gesture, block the animation\r\n        // of anything that's currently being animated\r\n        if (priority < this.getHighestPriority()) {\r\n            this.checkOverrideIsAnimating(priority);\r\n        }\r\n        if (this.children) {\r\n            this.children.forEach(function (child) { return child.resetIsAnimating(priority); });\r\n        }\r\n    };\r\n    VisualElementAnimationControls.prototype.stop = function () {\r\n        this.visualElement.forEachValue(function (value) { return value.stop(); });\r\n    };\r\n    /**\r\n     * Add the controls of a child component.\r\n     * @param controls -\r\n     */\r\n    VisualElementAnimationControls.prototype.addChild = function (controls) {\r\n        if (!this.children) {\r\n            this.children = new Set();\r\n        }\r\n        this.children.add(controls);\r\n        // We set child overrides when `setOverride` is called, but also have to do it here\r\n        // as the first time `setOverride` is called all the children might not have been added yet.\r\n        this.overrides.forEach(function (override, i) {\r\n            override && controls.setOverride(override, i);\r\n        });\r\n    };\r\n    VisualElementAnimationControls.prototype.removeChild = function (controls) {\r\n        if (!this.children) {\r\n            return;\r\n        }\r\n        this.children.delete(controls);\r\n    };\r\n    VisualElementAnimationControls.prototype.resetChildren = function () {\r\n        if (this.children)\r\n            this.children.clear();\r\n    };\r\n    return VisualElementAnimationControls;\r\n}());\r\nfunction getOriginFromTransition(key, transition) {\r\n    if (!transition)\r\n        return;\r\n    var valueTransition = transition[key] || transition[\"default\"] || transition;\r\n    return valueTransition.from;\r\n}\r\nfunction getOrigin(target, transition, visualElement) {\r\n    var _a, _b;\r\n    var origin = {};\r\n    for (var key in target) {\r\n        origin[key] = (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();\r\n    }\r\n    return origin;\r\n}\r\n\r\n/**\r\n * Creates an imperative set of controls to trigger animations.\r\n *\r\n * This allows a consolidated, uniform API for animations, to be triggered by other APIs like the `animate` prop, or the gesture handlers.\r\n *\r\n * @internal\r\n */\r\nfunction useVisualElementAnimation(visualElement, props, config) {\r\n    var subscribeToParentControls = checkShouldInheritVariant(props);\r\n    var variants = props.variants, transition = props.transition;\r\n    var parentControls = useContext(MotionContext).controls;\r\n    var presenceContext = useContext(PresenceContext);\r\n    var controls = useConstant(function () { return new VisualElementAnimationControls(visualElement, config); });\r\n    // Reset and resubscribe children every render to ensure stagger order is correct\r\n    if (!presenceContext || presenceContext.isPresent) {\r\n        controls.resetChildren();\r\n        controls.setProps(props);\r\n        controls.setVariants(variants);\r\n        controls.setDefaultTransition(transition);\r\n    }\r\n    // We have to subscribe to the parent controls within a useEffect rather than during render,\r\n    // as\r\n    useEffect(function () {\r\n        if (subscribeToParentControls && parentControls) {\r\n            parentControls.addChild(controls);\r\n        }\r\n    });\r\n    useEffect(function () {\r\n        return function () {\r\n            // Remove reference to onAnimationComplete from controls. All the MotionValues\r\n            // are unsubscribed from this component separately. We let animations run out\r\n            // as they might be animating other components.\r\n            var onAnimationComplete = props.onAnimationComplete, unmountProps = __rest(props, [\"onAnimationComplete\"]);\r\n            controls.setProps(unmountProps);\r\n            parentControls && parentControls.removeChild(controls);\r\n        };\r\n    }, []);\r\n    return controls;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nvar MotionPluginContext = createContext({\r\n    transformPagePoint: function (p) { return p; },\r\n    features: [],\r\n});\r\n/**\r\n * @remarks For now I think this should remain a private API for our own use\r\n * until we can figure out a nicer way of allowing people to add these\r\n *\r\n * @internal\r\n */\r\nfunction MotionPlugins(_a) {\r\n    var children = _a.children, props = __rest(_a, [\"children\"]);\r\n    var pluginContext = useContext(MotionPluginContext);\r\n    var value = useRef(__assign({}, pluginContext)).current;\r\n    // Mutative to prevent triggering rerenders in all listening\r\n    // components every time this component renders\r\n    for (var key in props) {\r\n        value[key] = props[key];\r\n    }\r\n    return (createElement(MotionPluginContext.Provider, { value: value }, children));\r\n}\r\n\r\nfunction createLock(name) {\r\n    var lock = null;\r\n    return function () {\r\n        var openLock = function () {\r\n            lock = null;\r\n        };\r\n        if (lock === null) {\r\n            lock = name;\r\n            return openLock;\r\n        }\r\n        return false;\r\n    };\r\n}\r\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\r\nvar globalVerticalLock = createLock(\"dragVertical\");\r\nfunction getGlobalLock(drag) {\r\n    var lock = false;\r\n    if (drag === \"y\") {\r\n        lock = globalVerticalLock();\r\n    }\r\n    else if (drag === \"x\") {\r\n        lock = globalHorizontalLock();\r\n    }\r\n    else {\r\n        var openHorizontal_1 = globalHorizontalLock();\r\n        var openVertical_1 = globalVerticalLock();\r\n        if (openHorizontal_1 && openVertical_1) {\r\n            lock = function () {\r\n                openHorizontal_1();\r\n                openVertical_1();\r\n            };\r\n        }\r\n        else {\r\n            // Release the locks because we don't use them\r\n            if (openHorizontal_1)\r\n                openHorizontal_1();\r\n            if (openVertical_1)\r\n                openVertical_1();\r\n        }\r\n    }\r\n    return lock;\r\n}\r\n\r\nvar isViewportScrollBlocked = false;\r\nvar isBrowser = typeof window !== \"undefined\";\r\nif (isBrowser) {\r\n    document.addEventListener(\"touchmove\", function (event) {\r\n        if (isViewportScrollBlocked) {\r\n            event.preventDefault();\r\n        }\r\n    }, { passive: false });\r\n}\r\nvar blockViewportScroll = function () { return (isViewportScrollBlocked = true); };\r\nvar unblockViewportScroll = function () { return (isViewportScrollBlocked = false); };\r\n\r\nfunction addDomEvent(target, eventName, handler, options) {\r\n    if (!handler)\r\n        return;\r\n    target.addEventListener(eventName, handler, options);\r\n    return function () { return target.removeEventListener(eventName, handler, options); };\r\n}\r\n/**\r\n * Attaches an event listener directly to the provided DOM element.\r\n *\r\n * Bypassing React's event system can be desirable, for instance when attaching non-passive\r\n * event handlers.\r\n *\r\n * ```jsx\r\n * const ref = useRef(null)\r\n *\r\n * useDomEvent(ref, 'wheel', onWheel, { passive: false })\r\n *\r\n * return <div ref={ref} />\r\n * ```\r\n *\r\n * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.\r\n * @param eventName - Name of the event you want listen for.\r\n * @param handler - Function to fire when receiving the event.\r\n * @param options - Options to pass to `Event.addEventListener`.\r\n *\r\n * @public\r\n */\r\nfunction useDomEvent(ref, eventName, handler, options) {\r\n    useEffect(function () {\r\n        var element = ref.current;\r\n        if (handler && element) {\r\n            return addDomEvent(element, eventName, handler, options);\r\n        }\r\n    }, [ref, eventName, handler, options]);\r\n}\r\n\r\nfunction isMouseEvent(event) {\r\n    // PointerEvent inherits from MouseEvent so we can't use a straight instanceof check.\r\n    if (typeof PointerEvent !== \"undefined\" && event instanceof PointerEvent) {\r\n        return !!(event.pointerType === \"mouse\");\r\n    }\r\n    return event instanceof MouseEvent;\r\n}\r\nfunction isTouchEvent(event) {\r\n    var hasTouches = !!event.touches;\r\n    return hasTouches;\r\n}\r\n\r\n/**\r\n * Filters out events not attached to the primary pointer (currently left mouse button)\r\n * @param eventHandler\r\n */\r\nfunction filterPrimaryPointer(eventHandler) {\r\n    if (!eventHandler)\r\n        return undefined;\r\n    return function (event) {\r\n        var isMouseEvent = event instanceof MouseEvent;\r\n        var isPrimaryPointer = !isMouseEvent ||\r\n            (isMouseEvent && event.button === 0);\r\n        if (isPrimaryPointer) {\r\n            eventHandler(event);\r\n        }\r\n    };\r\n}\r\nvar defaultPagePoint = { pageX: 0, pageY: 0 };\r\nfunction pointFromTouch(e, pointType) {\r\n    if (pointType === void 0) { pointType = \"page\"; }\r\n    var primaryTouch = e.touches[0] || e.changedTouches[0];\r\n    var point = primaryTouch || defaultPagePoint;\r\n    return {\r\n        x: point[pointType + \"X\"],\r\n        y: point[pointType + \"Y\"],\r\n    };\r\n}\r\nfunction pointFromMouse(point, pointType) {\r\n    if (pointType === void 0) { pointType = \"page\"; }\r\n    return {\r\n        x: point[pointType + \"X\"],\r\n        y: point[pointType + \"Y\"],\r\n    };\r\n}\r\nfunction extractEventInfo(event, pointType) {\r\n    if (pointType === void 0) { pointType = \"page\"; }\r\n    return {\r\n        point: isTouchEvent(event)\r\n            ? pointFromTouch(event, pointType)\r\n            : pointFromMouse(event, pointType),\r\n    };\r\n}\r\nfunction getViewportPointFromEvent(event) {\r\n    return extractEventInfo(event, \"client\");\r\n}\r\nvar wrapHandler = function (handler, shouldFilterPrimaryPointer) {\r\n    if (shouldFilterPrimaryPointer === void 0) { shouldFilterPrimaryPointer = false; }\r\n    if (!handler)\r\n        return;\r\n    var listener = function (event) { return handler(event, extractEventInfo(event)); };\r\n    return shouldFilterPrimaryPointer\r\n        ? filterPrimaryPointer(listener)\r\n        : listener;\r\n};\r\n\r\nvar isBrowser$1 = typeof window !== \"undefined\";\r\n// We check for event support via functions in case they've been mocked by a testing suite.\r\nvar supportsPointerEvents = function () {\r\n    return isBrowser$1 && window.onpointerdown === null;\r\n};\r\nvar supportsTouchEvents = function () {\r\n    return isBrowser$1 && window.ontouchstart === null;\r\n};\r\nvar supportsMouseEvents = function () {\r\n    return isBrowser$1 && window.onmousedown === null;\r\n};\r\n\r\nvar mouseEventNames = {\r\n    pointerdown: \"mousedown\",\r\n    pointermove: \"mousemove\",\r\n    pointerup: \"mouseup\",\r\n    pointercancel: \"mousecancel\",\r\n    pointerover: \"mouseover\",\r\n    pointerout: \"mouseout\",\r\n    pointerenter: \"mouseenter\",\r\n    pointerleave: \"mouseleave\",\r\n};\r\nvar touchEventNames = {\r\n    pointerdown: \"touchstart\",\r\n    pointermove: \"touchmove\",\r\n    pointerup: \"touchend\",\r\n    pointercancel: \"touchcancel\",\r\n};\r\nfunction getPointerEventName(name) {\r\n    if (supportsPointerEvents()) {\r\n        return name;\r\n    }\r\n    else if (supportsTouchEvents()) {\r\n        return touchEventNames[name];\r\n    }\r\n    else if (supportsMouseEvents()) {\r\n        return mouseEventNames[name];\r\n    }\r\n    return name;\r\n}\r\nfunction addPointerEvent(target, eventName, handler, options) {\r\n    return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\r\n}\r\nfunction usePointerEvent(ref, eventName, handler, options) {\r\n    return useDomEvent(ref, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\r\n}\r\n\r\n/** @public */\r\nvar Point;\r\n(function (Point) {\r\n    /** @beta */\r\n    Point.subtract = function (a, b) {\r\n        return { x: a.x - b.x, y: a.y - b.y };\r\n    };\r\n    /** @beta */\r\n    Point.relativeTo = function (idOrElem) {\r\n        var elem;\r\n        var getElem = function () {\r\n            // Caching element here could be leaky because of React lifecycle\r\n            if (elem !== undefined)\r\n                return elem;\r\n            if (typeof idOrElem === \"string\") {\r\n                elem = document.getElementById(idOrElem);\r\n            }\r\n            else {\r\n                elem = idOrElem;\r\n            }\r\n            return elem;\r\n        };\r\n        return function (_a) {\r\n            var x = _a.x, y = _a.y;\r\n            var localElem = getElem();\r\n            if (!localElem)\r\n                return undefined;\r\n            var rect = localElem.getBoundingClientRect();\r\n            return {\r\n                x: x - rect.left - window.scrollX,\r\n                y: y - rect.top - window.scrollY,\r\n            };\r\n        };\r\n    };\r\n})(Point || (Point = {}));\r\n\r\n/**\r\n * @internal\r\n */\r\nvar PanSession = /** @class */ (function () {\r\n    function PanSession(event, handlers, _a) {\r\n        var _this = this;\r\n        var transformPagePoint = (_a === void 0 ? {} : _a).transformPagePoint;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.startEvent = null;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.lastMoveEvent = null;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.lastMoveEventInfo = null;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.handlers = {};\r\n        this.updatePoint = function () {\r\n            if (!(_this.lastMoveEvent && _this.lastMoveEventInfo))\r\n                return;\r\n            var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\r\n            var isPanStarted = _this.startEvent !== null;\r\n            // Only start panning if the offset is larger than 3 pixels. If we make it\r\n            // any larger than this we'll want to reset the pointer history\r\n            // on the first update to avoid visual snapping to the cursoe.\r\n            var isDistancePastThreshold = distance(info.offset, { x: 0, y: 0 }) >= 3;\r\n            if (!isPanStarted && !isDistancePastThreshold)\r\n                return;\r\n            var point = info.point;\r\n            var timestamp = getFrameData().timestamp;\r\n            _this.history.push(__assign(__assign({}, point), { timestamp: timestamp }));\r\n            var _a = _this.handlers, onStart = _a.onStart, onMove = _a.onMove;\r\n            if (!isPanStarted) {\r\n                onStart && onStart(_this.lastMoveEvent, info);\r\n                _this.startEvent = _this.lastMoveEvent;\r\n            }\r\n            onMove && onMove(_this.lastMoveEvent, info);\r\n        };\r\n        // If we have more than one touch, don't start detecting this gesture\r\n        if (isTouchEvent(event) && event.touches.length > 1)\r\n            return;\r\n        this.handlers = handlers;\r\n        this.transformPagePoint = transformPagePoint;\r\n        var info = extractEventInfo(event);\r\n        var initialInfo = transformPoint(info, this.transformPagePoint);\r\n        var point = initialInfo.point;\r\n        var timestamp = getFrameData().timestamp;\r\n        this.history = [__assign(__assign({}, point), { timestamp: timestamp })];\r\n        var onSessionStart = handlers.onSessionStart;\r\n        onSessionStart &&\r\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\r\n        var removeOnPointerMove = addPointerEvent(window, \"pointermove\", function (event, info) { return _this.handlePointerMove(event, info); });\r\n        var removeOnPointerUp = addPointerEvent(window, \"pointerup\", function (event, info) { return _this.handlePointerUp(event, info); });\r\n        this.removeListeners = function () {\r\n            removeOnPointerMove && removeOnPointerMove();\r\n            removeOnPointerUp && removeOnPointerUp();\r\n        };\r\n    }\r\n    PanSession.prototype.handlePointerMove = function (event, info) {\r\n        this.lastMoveEvent = event;\r\n        this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\r\n        // Because Safari doesn't trigger mouseup events when it's above a `<select>`\r\n        if (isMouseEvent(event) && event.buttons === 0) {\r\n            this.handlePointerUp(event, info);\r\n            return;\r\n        }\r\n        // Throttle mouse move event to once per frame\r\n        sync.update(this.updatePoint, true);\r\n    };\r\n    PanSession.prototype.handlePointerUp = function (event, info) {\r\n        this.end();\r\n        var onEnd = this.handlers.onEnd;\r\n        if (!onEnd)\r\n            return;\r\n        var panInfo = getPanInfo(transformPoint(info, this.transformPagePoint), this.history);\r\n        onEnd && onEnd(event, panInfo);\r\n    };\r\n    PanSession.prototype.updateHandlers = function (handlers) {\r\n        this.handlers = handlers;\r\n    };\r\n    PanSession.prototype.end = function () {\r\n        this.removeListeners && this.removeListeners();\r\n        cancelSync.update(this.updatePoint);\r\n        unblockViewportScroll();\r\n    };\r\n    return PanSession;\r\n}());\r\nfunction transformPoint(info, transformPagePoint) {\r\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\r\n}\r\nfunction getPanInfo(_a, history) {\r\n    var point = _a.point;\r\n    return {\r\n        point: point,\r\n        delta: Point.subtract(point, lastDevicePoint(history)),\r\n        offset: Point.subtract(point, startDevicePoint(history)),\r\n        velocity: getVelocity$1(history, 0.1),\r\n    };\r\n}\r\nfunction startDevicePoint(history) {\r\n    return history[0];\r\n}\r\nfunction lastDevicePoint(history) {\r\n    return history[history.length - 1];\r\n}\r\nfunction getVelocity$1(history, timeDelta) {\r\n    if (history.length < 2) {\r\n        return { x: 0, y: 0 };\r\n    }\r\n    var i = history.length - 1;\r\n    var timestampedPoint = null;\r\n    var lastPoint = lastDevicePoint(history);\r\n    while (i >= 0) {\r\n        timestampedPoint = history[i];\r\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\r\n            secondsToMilliseconds(timeDelta)) {\r\n            break;\r\n        }\r\n        i--;\r\n    }\r\n    if (!timestampedPoint) {\r\n        return { x: 0, y: 0 };\r\n    }\r\n    var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\r\n    if (time === 0) {\r\n        return { x: 0, y: 0 };\r\n    }\r\n    var currentVelocity = {\r\n        x: (lastPoint.x - timestampedPoint.x) / time,\r\n        y: (lastPoint.y - timestampedPoint.y) / time,\r\n    };\r\n    if (currentVelocity.x === Infinity) {\r\n        currentVelocity.x = 0;\r\n    }\r\n    if (currentVelocity.y === Infinity) {\r\n        currentVelocity.y = 0;\r\n    }\r\n    return currentVelocity;\r\n}\r\n\r\n/**\r\n * Apply constraints to a point. These constraints are both physical along an\r\n * axis, and an elastic factor that determines how much to constrain the point\r\n * by if it does lie outside the defined parameters.\r\n */\r\nfunction applyConstraints(point, _a, elastic) {\r\n    var min = _a.min, max = _a.max;\r\n    if (min !== undefined && point < min) {\r\n        // If we have a min point defined, and this is outside of that, constrain\r\n        point = elastic ? mix(min, point, elastic) : Math.max(point, min);\r\n    }\r\n    else if (max !== undefined && point > max) {\r\n        // If we have a max point defined, and this is outside of that, constrain\r\n        point = elastic ? mix(max, point, elastic) : Math.min(point, max);\r\n    }\r\n    return point;\r\n}\r\n/**\r\n * Calculates a min projection point based on a pointer, pointer progress\r\n * within the drag target, and constraints.\r\n *\r\n * For instance if an element was 100px width, we were dragging from 0.25\r\n * along this axis, the pointer is at 200px, and there were no constraints,\r\n * we would calculate a min projection point of 175px.\r\n */\r\nfunction calcConstrainedMinPoint(point, length, progress, constraints, elastic) {\r\n    // Calculate a min point for this axis and apply it to the current pointer\r\n    var min = point - length * progress;\r\n    return constraints ? applyConstraints(min, constraints, elastic) : min;\r\n}\r\n/**\r\n * Calculate constraints in terms of the viewport when\r\n * defined relatively to the measured axis.\r\n */\r\nfunction calcRelativeAxisConstraints(axis, min, max) {\r\n    var constraints = {};\r\n    var length = axis.max - axis.min;\r\n    if (min !== undefined) {\r\n        constraints.min = axis.min + min;\r\n    }\r\n    if (max !== undefined) {\r\n        constraints.max = Math.max(axis.min + max - length, axis.min + max);\r\n    }\r\n    return constraints;\r\n}\r\n/**\r\n * Calculate constraints in terms of the viewport when\r\n * defined relatively to the measured bounding box.\r\n */\r\nfunction calcRelativeConstraints(layoutBox, _a) {\r\n    var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;\r\n    return {\r\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\r\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),\r\n    };\r\n}\r\n/**\r\n * Calculate viewport constraints when defined as another viewport-relative axis\r\n */\r\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\r\n    var _a;\r\n    var min = constraintsAxis.min - layoutAxis.min;\r\n    var max = constraintsAxis.max - layoutAxis.max;\r\n    // If the constraints axis is actually smaller than the layout axis then we can\r\n    // flip the constraints\r\n    if (constraintsAxis.max - constraintsAxis.min <\r\n        layoutAxis.max - layoutAxis.min) {\r\n        _a = [max, min], min = _a[0], max = _a[1];\r\n    }\r\n    return {\r\n        min: layoutAxis.min + min,\r\n        max: layoutAxis.min + max,\r\n    };\r\n}\r\n/**\r\n * Calculate viewport constraints when defined as another viewport-relative box\r\n */\r\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\r\n    return {\r\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\r\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),\r\n    };\r\n}\r\n/**\r\n * Calculate the an axis position based on two axes and a progress value.\r\n */\r\nfunction calcPositionFromProgress(axis, constraints, progress) {\r\n    var axisLength = axis.max - axis.min;\r\n    var min = mix(constraints.min, constraints.max - axisLength, progress);\r\n    return { min: min, max: min + axisLength };\r\n}\r\n\r\nvar elementDragControls = new WeakMap();\r\n/**\r\n *\r\n */\r\nvar lastPointerEvent;\r\nvar VisualElementDragControls = /** @class */ (function () {\r\n    function VisualElementDragControls(_a) {\r\n        var visualElement = _a.visualElement;\r\n        /**\r\n         * Track whether we're currently dragging.\r\n         *\r\n         * @internal\r\n         */\r\n        this.isDragging = false;\r\n        /**\r\n         * The current direction of drag, or `null` if both.\r\n         *\r\n         * @internal\r\n         */\r\n        this.currentDirection = null;\r\n        /**\r\n         * The permitted boundaries of travel, in pixels.\r\n         *\r\n         * @internal\r\n         */\r\n        this.constraints = false;\r\n        /**\r\n         * A reference to the host component's latest props.\r\n         *\r\n         * @internal\r\n         */\r\n        this.props = {};\r\n        /**\r\n         * Track the initial position of the cursor relative to the dragging element\r\n         * when dragging starts as a value of 0-1 on each axis. We then use this to calculate\r\n         * an ideal bounding box for the VisualElement renderer to project into every frame.\r\n         *\r\n         * @internal\r\n         */\r\n        this.cursorProgress = {\r\n            x: 0.5,\r\n            y: 0.5,\r\n        };\r\n        // This is a reference to the global drag gesture lock, ensuring only one component\r\n        // can \"capture\" the drag of one or both axes.\r\n        // TODO: Look into moving this into pansession?\r\n        this.openGlobalLock = null;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.panSession = null;\r\n        this.visualElement = visualElement;\r\n        this.visualElement.enableLayoutProjection();\r\n        elementDragControls.set(visualElement, this);\r\n    }\r\n    /**\r\n     * Instantiate a PanSession for the drag gesture\r\n     *\r\n     * @public\r\n     */\r\n    VisualElementDragControls.prototype.start = function (originEvent, _a) {\r\n        var _this = this;\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.snapToCursor, snapToCursor = _c === void 0 ? false : _c, cursorProgress = _b.cursorProgress;\r\n        /**\r\n         * If this drag session has been manually triggered by the user, it might be from an event\r\n         * outside the draggable element. If snapToCursor is set to true, we need to measure the position\r\n         * of the element and snap it to the cursor.\r\n         */\r\n        snapToCursor && this.snapToCursor(originEvent);\r\n        var onSessionStart = function () {\r\n            // Initiate viewport scroll blocking on touch start. This is a very aggressive approach\r\n            // which has come out of the difficulty in us being able to do this once a scroll gesture\r\n            // has initiated in mobile browsers. This means if there's a horizontally-scrolling carousel\r\n            // on a page we can't let a user scroll the page itself from it. Ideally what we'd do is\r\n            // trigger this once we've got a scroll direction determined. This approach sort-of worked\r\n            // but if the component was dragged too far in a single frame page scrolling would initiate.\r\n            blockViewportScroll();\r\n            // Stop any animations on both axis values immediately. This allows the user to throw and catch\r\n            // the component.\r\n            _this.stopMotion();\r\n        };\r\n        var onStart = function (event, info) {\r\n            var _a, _b;\r\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\r\n            var _c = _this.props, drag = _c.drag, dragPropagation = _c.dragPropagation;\r\n            if (drag && !dragPropagation) {\r\n                if (_this.openGlobalLock)\r\n                    _this.openGlobalLock();\r\n                _this.openGlobalLock = getGlobalLock(drag);\r\n                // If we don 't have the lock, don't start dragging\r\n                if (!_this.openGlobalLock)\r\n                    return;\r\n            }\r\n            /**\r\n             * Record the progress of the mouse within the draggable element on each axis.\r\n             * onPan, we're going to use this to calculate a new bounding box for the element to\r\n             * project into. This will ensure that even if the DOM element moves via a relayout, it'll\r\n             * stick to the correct place under the pointer.\r\n             */\r\n            _this.prepareBoundingBox();\r\n            _this.visualElement.lockTargetBox();\r\n            /**\r\n             * Resolve the drag constraints. These are either set as top/right/bottom/left constraints\r\n             * relative to the element's layout, or a ref to another element. Both need converting to\r\n             * viewport coordinates.\r\n             */\r\n            _this.resolveDragConstraints();\r\n            /**\r\n             * When dragging starts, we want to find where the cursor is relative to the bounding box\r\n             * of the element. Every frame, we calculate a new bounding box using this relative position\r\n             * and let the visualElement renderer figure out how to reproject the element into this bounding\r\n             * box.\r\n             *\r\n             * By doing it this way, rather than applying an x/y transform directly to the element,\r\n             * we can ensure the component always visually sticks to the cursor as we'd expect, even\r\n             * if the DOM element itself changes layout as a result of React updates the user might\r\n             * make based on the drag position.\r\n             */\r\n            var point = getViewportPointFromEvent(event).point;\r\n            eachAxis(function (axis) {\r\n                var _a = _this.visualElement.targetBox[axis], min = _a.min, max = _a.max;\r\n                _this.cursorProgress[axis] = cursorProgress\r\n                    ? cursorProgress[axis]\r\n                    : progress(min, max, point[axis]);\r\n            });\r\n            // Set current drag status\r\n            _this.isDragging = true;\r\n            _this.currentDirection = null;\r\n            // Fire onDragStart event\r\n            (_b = (_a = _this.props).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a, event, info);\r\n        };\r\n        var onMove = function (event, info) {\r\n            var _a, _b, _c, _d;\r\n            var _e = _this.props, dragPropagation = _e.dragPropagation, dragDirectionLock = _e.dragDirectionLock;\r\n            // If we didn't successfully receive the gesture lock, early return.\r\n            if (!dragPropagation && !_this.openGlobalLock)\r\n                return;\r\n            var offset = info.offset;\r\n            // Attempt to detect drag direction if directionLock is true\r\n            if (dragDirectionLock && _this.currentDirection === null) {\r\n                _this.currentDirection = getCurrentDirection(offset);\r\n                // If we've successfully set a direction, notify listener\r\n                if (_this.currentDirection !== null) {\r\n                    (_b = (_a = _this.props).onDirectionLock) === null || _b === void 0 ? void 0 : _b.call(_a, _this.currentDirection);\r\n                }\r\n                return;\r\n            }\r\n            // Update each point with the latest position\r\n            _this.updateAxis(\"x\", event);\r\n            _this.updateAxis(\"y\", event);\r\n            // Fire onDrag event\r\n            (_d = (_c = _this.props).onDrag) === null || _d === void 0 ? void 0 : _d.call(_c, event, info);\r\n            // Update the last pointer event\r\n            lastPointerEvent = event;\r\n        };\r\n        var onEnd = function (event, info) { return _this.stop(event, info); };\r\n        var transformPagePoint = this.props.transformPagePoint;\r\n        this.panSession = new PanSession(originEvent, {\r\n            onSessionStart: onSessionStart,\r\n            onStart: onStart,\r\n            onMove: onMove,\r\n            onEnd: onEnd,\r\n        }, { transformPagePoint: transformPagePoint });\r\n    };\r\n    /**\r\n     * Ensure the component's layout and target bounding boxes are up-to-date.\r\n     */\r\n    VisualElementDragControls.prototype.prepareBoundingBox = function () {\r\n        var element = this.visualElement.getInstance();\r\n        var transform = element.style.transform;\r\n        this.visualElement.resetTransform();\r\n        this.visualElement.measureLayout();\r\n        element.style.transform = transform;\r\n        this.visualElement.refreshTargetBox();\r\n    };\r\n    VisualElementDragControls.prototype.resolveDragConstraints = function () {\r\n        var dragConstraints = this.props.dragConstraints;\r\n        if (dragConstraints) {\r\n            this.constraints = isRefObject(dragConstraints)\r\n                ? this.resolveRefConstraints(this.visualElement.box, dragConstraints)\r\n                : calcRelativeConstraints(this.visualElement.box, dragConstraints);\r\n        }\r\n        else {\r\n            this.constraints = false;\r\n        }\r\n    };\r\n    VisualElementDragControls.prototype.resolveRefConstraints = function (layoutBox, constraints) {\r\n        var _a = this.props, onMeasureDragConstraints = _a.onMeasureDragConstraints, transformPagePoint = _a.transformPagePoint;\r\n        var constraintsElement = constraints.current;\r\n        invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\r\n        this.constraintsBox = getBoundingBox(constraintsElement, transformPagePoint);\r\n        var measuredConstraints = calcViewportConstraints(layoutBox, this.constraintsBox);\r\n        /**\r\n         * If there's an onMeasureDragConstraints listener we call it and\r\n         * if different constraints are returned, set constraints to that\r\n         */\r\n        if (onMeasureDragConstraints) {\r\n            var userConstraints = onMeasureDragConstraints(convertAxisBoxToBoundingBox(measuredConstraints));\r\n            if (userConstraints) {\r\n                measuredConstraints = convertBoundingBoxToAxisBox(userConstraints);\r\n            }\r\n        }\r\n        return measuredConstraints;\r\n    };\r\n    VisualElementDragControls.prototype.cancelDrag = function () {\r\n        unblockViewportScroll();\r\n        this.isDragging = false;\r\n        this.panSession && this.panSession.end();\r\n        this.panSession = null;\r\n        if (!this.props.dragPropagation && this.openGlobalLock) {\r\n            this.openGlobalLock();\r\n            this.openGlobalLock = null;\r\n        }\r\n    };\r\n    VisualElementDragControls.prototype.stop = function (event, info) {\r\n        var _a;\r\n        this.visualElement.unlockTargetBox();\r\n        (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\r\n        this.panSession = null;\r\n        var isDragging = this.isDragging;\r\n        this.cancelDrag();\r\n        if (!isDragging)\r\n            return;\r\n        var _b = this.props, dragMomentum = _b.dragMomentum, dragElastic = _b.dragElastic, onDragEnd = _b.onDragEnd;\r\n        if (dragMomentum || dragElastic) {\r\n            var velocity = info.velocity;\r\n            this.animateDragEnd(velocity);\r\n        }\r\n        onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event, info);\r\n    };\r\n    VisualElementDragControls.prototype.snapToCursor = function (event) {\r\n        this.prepareBoundingBox();\r\n        this.cursorProgress.x = 0.5;\r\n        this.cursorProgress.y = 0.5;\r\n        this.updateAxis(\"x\", event);\r\n        this.updateAxis(\"y\", event);\r\n    };\r\n    /**\r\n     * Update the specified axis with the latest pointer information.\r\n     */\r\n    VisualElementDragControls.prototype.updateAxis = function (axis, event) {\r\n        var _a;\r\n        var _b = this.props, drag = _b.drag, dragElastic = _b.dragElastic;\r\n        // If we're not dragging this axis, do an early return.\r\n        if (!shouldDrag(axis, drag, this.currentDirection))\r\n            return;\r\n        // Get the actual layout bounding box of the element\r\n        var axisLayout = this.visualElement.box[axis];\r\n        // Calculate its current length. In the future we might want to lerp this to animate\r\n        // between lengths if the layout changes as we change the DOM\r\n        var axisLength = axisLayout.max - axisLayout.min;\r\n        // Get the initial progress that the pointer sat on this axis on gesture start.\r\n        var axisProgress = this.cursorProgress[axis];\r\n        var point = getViewportPointFromEvent(event).point;\r\n        // Calculate a new min point based on the latest pointer position, constraints and elastic\r\n        var min = calcConstrainedMinPoint(point[axis], axisLength, axisProgress, (_a = this.constraints) === null || _a === void 0 ? void 0 : _a[axis], dragElastic);\r\n        // Update the axis viewport target with this new min and the length\r\n        this.visualElement.setAxisTarget(axis, min, min + axisLength);\r\n    };\r\n    VisualElementDragControls.prototype.updateProps = function (_a) {\r\n        var _b = _a.drag, drag = _b === void 0 ? false : _b, _c = _a.dragDirectionLock, dragDirectionLock = _c === void 0 ? false : _c, _d = _a.dragPropagation, dragPropagation = _d === void 0 ? false : _d, _e = _a.dragConstraints, dragConstraints = _e === void 0 ? false : _e, _f = _a.dragElastic, dragElastic = _f === void 0 ? 0.35 : _f, _g = _a.dragMomentum, dragMomentum = _g === void 0 ? true : _g, remainingProps = __rest(_a, [\"drag\", \"dragDirectionLock\", \"dragPropagation\", \"dragConstraints\", \"dragElastic\", \"dragMomentum\"]);\r\n        this.props = __assign({ drag: drag,\r\n            dragDirectionLock: dragDirectionLock,\r\n            dragPropagation: dragPropagation,\r\n            dragConstraints: dragConstraints,\r\n            dragElastic: dragElastic,\r\n            dragMomentum: dragMomentum }, remainingProps);\r\n    };\r\n    VisualElementDragControls.prototype.animateDragEnd = function (velocity) {\r\n        var _this = this;\r\n        var _a = this.props, drag = _a.drag, dragMomentum = _a.dragMomentum, dragElastic = _a.dragElastic, dragTransition = _a.dragTransition;\r\n        var momentumAnimations = eachAxis(function (axis) {\r\n            if (!shouldDrag(axis, drag, _this.currentDirection)) {\r\n                return;\r\n            }\r\n            var transition = _this.constraints ? _this.constraints[axis] : {};\r\n            /**\r\n             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\r\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\r\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\r\n             * using the value of `dragElastic`.\r\n             */\r\n            var bounceStiffness = dragElastic ? 200 : 1000000;\r\n            var bounceDamping = dragElastic ? 40 : 10000000;\r\n            var inertia = __assign(__assign({ type: \"inertia\", velocity: dragMomentum ? velocity[axis] : 0, bounceStiffness: bounceStiffness,\r\n                bounceDamping: bounceDamping, timeConstant: 750, restDelta: 1, restSpeed: 10 }, dragTransition), transition);\r\n            // If we're not animating on an externally-provided `MotionValue` we can use the\r\n            // component's animation controls which will handle interactions with whileHover (etc),\r\n            // otherwise we just have to animate the `MotionValue` itself.\r\n            return _this.visualElement.startLayoutAxisAnimation(axis, inertia);\r\n        });\r\n        // Run all animations and then resolve the new drag constraints.\r\n        return Promise.all(momentumAnimations).then(function () {\r\n            var _a, _b;\r\n            (_b = (_a = _this.props).onDragTransitionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n        });\r\n    };\r\n    VisualElementDragControls.prototype.stopMotion = function () {\r\n        this.visualElement.stopLayoutAnimation();\r\n    };\r\n    VisualElementDragControls.prototype.scalePoint = function () {\r\n        var _this = this;\r\n        var _a = this.props, drag = _a.drag, dragConstraints = _a.dragConstraints;\r\n        if (!isRefObject(dragConstraints) || !this.constraintsBox)\r\n            return;\r\n        // Stop any current animations as there can be some visual glitching if we resize mid animation\r\n        this.stopMotion();\r\n        // Record the relative progress of the targetBox relative to the constraintsBox\r\n        var boxProgress = { x: 0, y: 0 };\r\n        eachAxis(function (axis) {\r\n            boxProgress[axis] = calcOrigin(_this.visualElement.targetBox[axis], _this.constraintsBox[axis]);\r\n        });\r\n        /**\r\n         * For each axis, calculate the current progress of the layout axis within the constraints.\r\n         * Then, using the latest layout and constraints measurements, reposition the new layout axis\r\n         * proportionally within the constraints.\r\n         */\r\n        this.prepareBoundingBox();\r\n        this.resolveDragConstraints();\r\n        eachAxis(function (axis) {\r\n            if (!shouldDrag(axis, drag, null))\r\n                return;\r\n            // Calculate the position of the targetBox relative to the constraintsBox using the\r\n            // previously calculated progress\r\n            var _a = calcPositionFromProgress(_this.visualElement.targetBox[axis], _this.constraintsBox[axis], boxProgress[axis]), min = _a.min, max = _a.max;\r\n            _this.visualElement.setAxisTarget(axis, min, max);\r\n        });\r\n    };\r\n    VisualElementDragControls.prototype.mount = function (visualElement) {\r\n        var _this = this;\r\n        var element = visualElement.getInstance();\r\n        /**\r\n         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\r\n         */\r\n        var stopPointerListener = addPointerEvent(element, \"pointerdown\", function (event) {\r\n            var _a = _this.props, drag = _a.drag, _b = _a.dragListener, dragListener = _b === void 0 ? true : _b;\r\n            drag && dragListener && _this.start(event);\r\n        });\r\n        /**\r\n         * Attach a window resize listener to scale the draggable target within its defined\r\n         * constraints as the window resizes.\r\n         */\r\n        var stopResizeListener = addDomEvent(window, \"resize\", function () {\r\n            _this.scalePoint();\r\n        });\r\n        /**\r\n         * Ensure drag constraints are resolved correctly relative to the dragging element\r\n         * whenever its layout changes.\r\n         */\r\n        var stopLayoutUpdateListener = visualElement.onLayoutUpdate(function () {\r\n            if (_this.isDragging)\r\n                _this.resolveDragConstraints();\r\n        });\r\n        /**\r\n         * If the previous component with this same layoutId was dragging at the time\r\n         * it was unmounted, we want to continue the same gesture on this component.\r\n         */\r\n        var prevSnapshot = visualElement.prevSnapshot;\r\n        (prevSnapshot === null || prevSnapshot === void 0 ? void 0 : prevSnapshot.isDragging) &&\r\n            this.start(lastPointerEvent, {\r\n                cursorProgress: prevSnapshot.cursorProgress,\r\n            });\r\n        /**\r\n         * Return a function that will teardown the drag gesture\r\n         */\r\n        return function () {\r\n            stopPointerListener === null || stopPointerListener === void 0 ? void 0 : stopPointerListener();\r\n            stopResizeListener === null || stopResizeListener === void 0 ? void 0 : stopResizeListener();\r\n            stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();\r\n            _this.cancelDrag();\r\n        };\r\n    };\r\n    return VisualElementDragControls;\r\n}());\r\nfunction shouldDrag(direction, drag, currentDirection) {\r\n    return ((drag === true || drag === direction) &&\r\n        (currentDirection === null || currentDirection === direction));\r\n}\r\n/**\r\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\r\n * than the provided threshold, return `null`.\r\n *\r\n * @param offset - The x/y offset from origin.\r\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\r\n */\r\nfunction getCurrentDirection(offset, lockThreshold) {\r\n    if (lockThreshold === void 0) { lockThreshold = 10; }\r\n    var direction = null;\r\n    if (Math.abs(offset.y) > lockThreshold) {\r\n        direction = \"y\";\r\n    }\r\n    else if (Math.abs(offset.x) > lockThreshold) {\r\n        direction = \"x\";\r\n    }\r\n    return direction;\r\n}\r\n\r\n/**\r\n * A hook that allows an element to be dragged.\r\n *\r\n * @internal\r\n */\r\nfunction useDrag(props, visualElement) {\r\n    var groupDragControls = props.dragControls;\r\n    var transformPagePoint = useContext(MotionPluginContext).transformPagePoint;\r\n    var dragControls = useConstant(function () {\r\n        return new VisualElementDragControls({\r\n            visualElement: visualElement,\r\n        });\r\n    });\r\n    dragControls.updateProps(__assign(__assign({}, props), { transformPagePoint: transformPagePoint }));\r\n    // If we've been provided a DragControls for manual control over the drag gesture,\r\n    // subscribe this component to it on mount.\r\n    useEffect(function () { return groupDragControls && groupDragControls.subscribe(dragControls); }, [dragControls]);\r\n    // Mount the drag controls with the visualElement\r\n    useEffect(function () { return dragControls.mount(visualElement); }, []);\r\n}\r\n\r\nvar makeRenderlessComponent = function (hook) { return function (props) {\r\n    hook(props);\r\n    return null;\r\n}; };\r\n\r\nvar Drag = {\r\n    key: \"drag\",\r\n    shouldRender: function (props) { return !!props.drag; },\r\n    Component: makeRenderlessComponent(function (_a) {\r\n        var visualElement = _a.visualElement, props = __rest(_a, [\"visualElement\"]);\r\n        return useDrag(props, visualElement);\r\n    }),\r\n};\r\n\r\nfunction useUnmountEffect(callback) {\r\n    return useEffect(function () { return function () { return callback(); }; }, []);\r\n}\r\n\r\n/**\r\n *\r\n * @param handlers -\r\n * @param ref -\r\n *\r\n * @internalremarks\r\n * Currently this sets new pan gesture functions every render. The memo route has been explored\r\n * in the past but ultimately we're still creating new functions every render. An optimisation\r\n * to explore is creating the pan gestures and loading them into a `ref`.\r\n *\r\n * @internal\r\n */\r\nfunction usePanGesture(_a, ref) {\r\n    var onPan = _a.onPan, onPanStart = _a.onPanStart, onPanEnd = _a.onPanEnd, onPanSessionStart = _a.onPanSessionStart;\r\n    var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\r\n    var panSession = useRef(null);\r\n    var transformPagePoint = useContext(MotionPluginContext).transformPagePoint;\r\n    var handlers = {\r\n        onSessionStart: onPanSessionStart,\r\n        onStart: onPanStart,\r\n        onMove: onPan,\r\n        onEnd: function (event, info) {\r\n            panSession.current = null;\r\n            onPanEnd && onPanEnd(event, info);\r\n        },\r\n    };\r\n    useEffect(function () {\r\n        if (panSession.current !== null) {\r\n            panSession.current.updateHandlers(handlers);\r\n        }\r\n    });\r\n    function onPointerDown(event) {\r\n        panSession.current = new PanSession(event, handlers, {\r\n            transformPagePoint: transformPagePoint,\r\n        });\r\n    }\r\n    usePointerEvent(ref, \"pointerdown\", hasPanEvents && onPointerDown);\r\n    useUnmountEffect(function () { return panSession.current && panSession.current.end(); });\r\n}\r\n\r\n/**\r\n * Recursively traverse up the tree to check whether the provided child node\r\n * is the parent or a descendant of it.\r\n *\r\n * @param parent - Element to find\r\n * @param child - Element to test against parent\r\n */\r\nvar isNodeOrChild = function (parent, child) {\r\n    if (!child) {\r\n        return false;\r\n    }\r\n    else if (parent === child) {\r\n        return true;\r\n    }\r\n    else {\r\n        return isNodeOrChild(parent, child.parentElement);\r\n    }\r\n};\r\n\r\nvar order$1 = [\"whileHover\", \"whileTap\", \"whileDrag\"];\r\nvar getGesturePriority = function (gesture) {\r\n    return order$1.indexOf(gesture) + 1;\r\n};\r\n\r\nvar tapGesturePriority = getGesturePriority(\"whileTap\");\r\n/**\r\n * @param handlers -\r\n * @internal\r\n */\r\nfunction useTapGesture(_a, ref) {\r\n    var onTap = _a.onTap, onTapStart = _a.onTapStart, onTapCancel = _a.onTapCancel, whileTap = _a.whileTap, controls = _a.controls;\r\n    var hasTapListeners = onTap || onTapStart || onTapCancel || whileTap;\r\n    var isTapping = useRef(false);\r\n    var cancelPointerEventListener = useRef(null);\r\n    function removePointerUp() {\r\n        cancelPointerEventListener.current &&\r\n            cancelPointerEventListener.current();\r\n        cancelPointerEventListener.current = null;\r\n    }\r\n    if (whileTap && controls) {\r\n        controls.setOverride(whileTap, tapGesturePriority);\r\n    }\r\n    // We load this event handler into a ref so we can later refer to\r\n    // onPointerUp.current which will always have reference to the latest props\r\n    var onPointerUp = useRef(null);\r\n    onPointerUp.current = function (event, info) {\r\n        var element = ref.current;\r\n        removePointerUp();\r\n        if (!isTapping.current || !element)\r\n            return;\r\n        isTapping.current = false;\r\n        if (controls && whileTap) {\r\n            controls.clearOverride(tapGesturePriority);\r\n        }\r\n        // Check the gesture lock - if we get it, it means no drag gesture is active\r\n        // and we can safely fire the tap gesture.\r\n        var openGestureLock = getGlobalLock(true);\r\n        if (!openGestureLock)\r\n            return;\r\n        openGestureLock();\r\n        if (!isNodeOrChild(element, event.target)) {\r\n            onTapCancel && onTapCancel(event, info);\r\n        }\r\n        else {\r\n            onTap && onTap(event, info);\r\n        }\r\n    };\r\n    function onPointerDown(event, info) {\r\n        removePointerUp();\r\n        cancelPointerEventListener.current = addPointerEvent(window, \"pointerup\", function (event, info) { return onPointerUp.current(event, info); });\r\n        var element = ref.current;\r\n        if (!element || isTapping.current)\r\n            return;\r\n        isTapping.current = true;\r\n        onTapStart && onTapStart(event, info);\r\n        if (controls && whileTap) {\r\n            controls.startOverride(tapGesturePriority);\r\n        }\r\n    }\r\n    usePointerEvent(ref, \"pointerdown\", hasTapListeners ? onPointerDown : undefined);\r\n    useUnmountEffect(removePointerUp);\r\n}\r\n\r\nvar hoverPriority = getGesturePriority(\"whileHover\");\r\nvar filterTouch = function (listener) { return function (event, info) {\r\n    if (isMouseEvent(event))\r\n        listener(event, info);\r\n}; };\r\n/**\r\n *\r\n * @param props\r\n * @param ref\r\n * @internal\r\n */\r\nfunction useHoverGesture(_a, ref) {\r\n    var whileHover = _a.whileHover, onHoverStart = _a.onHoverStart, onHoverEnd = _a.onHoverEnd, controls = _a.controls;\r\n    if (whileHover && controls) {\r\n        controls.setOverride(whileHover, hoverPriority);\r\n    }\r\n    usePointerEvent(ref, \"pointerenter\", filterTouch(function (event, info) {\r\n        if (onHoverStart)\r\n            onHoverStart(event, info);\r\n        if (whileHover && controls) {\r\n            controls.startOverride(hoverPriority);\r\n        }\r\n    }));\r\n    usePointerEvent(ref, \"pointerleave\", filterTouch(function (event, info) {\r\n        if (onHoverEnd)\r\n            onHoverEnd(event, info);\r\n        if (whileHover && controls) {\r\n            controls.clearOverride(hoverPriority);\r\n        }\r\n    }));\r\n}\r\n\r\n/**\r\n * Add pan and tap gesture recognition to an element.\r\n *\r\n * @param props - Gesture event handlers\r\n * @param ref - React `ref` containing a DOM `Element`\r\n * @public\r\n */\r\nfunction useGestures(props, ref) {\r\n    usePanGesture(props, ref);\r\n    useTapGesture(props, ref);\r\n    useHoverGesture(props, ref);\r\n}\r\n\r\nvar gestureProps = [\r\n    \"onPan\",\r\n    \"onPanStart\",\r\n    \"onPanEnd\",\r\n    \"onPanSessionStart\",\r\n    \"onTap\",\r\n    \"onTapStart\",\r\n    \"onTapCancel\",\r\n    \"whileTap\",\r\n    \"whileHover\",\r\n    \"onHoverStart\",\r\n    \"onHoverEnd\",\r\n];\r\nvar Gestures = {\r\n    key: \"gestures\",\r\n    shouldRender: function (props) {\r\n        return gestureProps.some(function (key) { return props.hasOwnProperty(key); });\r\n    },\r\n    Component: makeRenderlessComponent(function (_a) {\r\n        var visualElement = _a.visualElement, props = __rest(_a, [\"visualElement\"]);\r\n        useGestures(props, visualElement);\r\n    }),\r\n};\r\n\r\nvar Exit = {\r\n    key: \"exit\",\r\n    shouldRender: function (props) { return !!props.exit && !checkShouldInheritVariant(props); },\r\n    Component: makeRenderlessComponent(function (props) {\r\n        var animate = props.animate, controls = props.controls, exit = props.exit;\r\n        var _a = usePresence(), isPresent = _a[0], onExitComplete = _a[1];\r\n        var presenceContext = useContext(PresenceContext);\r\n        var isPlayingExitAnimation = useRef(false);\r\n        var custom = (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== undefined\r\n            ? presenceContext.custom\r\n            : props.custom;\r\n        useEffect(function () {\r\n            if (!isPresent) {\r\n                if (!isPlayingExitAnimation.current && exit) {\r\n                    controls.setProps(__assign(__assign({}, props), { custom: custom }));\r\n                    controls.start(exit).then(onExitComplete);\r\n                }\r\n                isPlayingExitAnimation.current = true;\r\n            }\r\n            else if (isPlayingExitAnimation.current &&\r\n                animate &&\r\n                typeof animate !== \"boolean\" &&\r\n                !(animate instanceof AnimationControls)) {\r\n                controls.start(animate);\r\n            }\r\n            if (isPresent) {\r\n                isPlayingExitAnimation.current = false;\r\n            }\r\n        }, [animate, controls, custom, exit, isPresent, onExitComplete, props]);\r\n    }),\r\n};\r\n\r\nvar AnimatePropType;\r\n(function (AnimatePropType) {\r\n    AnimatePropType[\"Target\"] = \"Target\";\r\n    AnimatePropType[\"VariantLabel\"] = \"VariantLabel\";\r\n    AnimatePropType[\"AnimationSubscription\"] = \"AnimationSubscription\";\r\n})(AnimatePropType || (AnimatePropType = {}));\r\n\r\nfunction shallowCompare(next, prev) {\r\n    if (prev === null)\r\n        return false;\r\n    var prevLength = prev.length;\r\n    if (prevLength !== next.length)\r\n        return false;\r\n    for (var i = 0; i < prevLength; i++) {\r\n        if (prev[i] !== next[i])\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nvar hasUpdated = function (prev, next) {\r\n    return (next !== undefined &&\r\n        (Array.isArray(prev) && Array.isArray(next)\r\n            ? !shallowCompare(next, prev)\r\n            : prev !== next));\r\n};\r\nfunction targetWithoutTransition(_a, mergeTransitionEnd) {\r\n    if (mergeTransitionEnd === void 0) { mergeTransitionEnd = false; }\r\n    var transition = _a.transition, transitionEnd = _a.transitionEnd, target = __rest(_a, [\"transition\", \"transitionEnd\"]);\r\n    return mergeTransitionEnd\r\n        ? __assign(__assign({}, target), transitionEnd)\r\n        : target;\r\n}\r\n/**\r\n * Handle the `animate` prop when its an object of values, ie:\r\n *\r\n * ```jsx\r\n * <motion.div animate={{ opacity: 1 }} />\r\n * ```\r\n *\r\n * @internalremarks\r\n * It might be worth consolidating this with `use-variants`\r\n *\r\n * ```jsx\r\n * <motion.div animate=\"visible\" />\r\n * ```\r\n *\r\n * @param target\r\n * @param controls\r\n * @param values\r\n * @param transition\r\n *\r\n * @internal\r\n */\r\nfunction useAnimateProp(targetAndTransition, controls, visualElement, defaultTransition) {\r\n    var isInitialRender = useRef(true);\r\n    var prevValues = useRef(null);\r\n    if (!prevValues.current) {\r\n        prevValues.current = targetWithoutTransition(targetAndTransition, true);\r\n    }\r\n    useEffect(function () {\r\n        var targetToAnimate = {};\r\n        // These are the values we're actually animating\r\n        var animatingTarget = targetWithoutTransition(targetAndTransition);\r\n        // This is the target as it'll be once transitionEnd values are applied\r\n        var finalTarget = targetWithoutTransition(targetAndTransition, true);\r\n        // Detect which values have changed between renders\r\n        for (var key in animatingTarget) {\r\n            // This value should animate on mount if this value doesn't already exist (wasn't\r\n            // defined in `style` or `initial`) or if it does exist and it's already changed.\r\n            var shouldAnimateOnMount = isInitialRender.current &&\r\n                (!visualElement.hasValue(key) ||\r\n                    visualElement.getValue(key).get() !== finalTarget[key]);\r\n            // If this value has updated between renders or it's we're animating this value on mount,\r\n            // add it to the animate target.\r\n            var isValidValue = finalTarget[key] !== null;\r\n            var valueHasUpdated = hasUpdated(prevValues.current[key], finalTarget[key]);\r\n            if (isValidValue && (valueHasUpdated || shouldAnimateOnMount)) {\r\n                targetToAnimate[key] = animatingTarget[key];\r\n            }\r\n        }\r\n        isInitialRender.current = false;\r\n        prevValues.current = __assign(__assign({}, prevValues.current), finalTarget);\r\n        if (Object.keys(targetToAnimate).length) {\r\n            controls.start(__assign(__assign({}, targetToAnimate), { transition: targetAndTransition.transition || defaultTransition, transitionEnd: targetAndTransition.transitionEnd }));\r\n        }\r\n    }, [targetAndTransition]);\r\n}\r\n\r\nvar labelsToArray = function (label) {\r\n    if (!label) {\r\n        return [];\r\n    }\r\n    if (Array.isArray(label)) {\r\n        return label;\r\n    }\r\n    return [label];\r\n};\r\nvar resolveVariantLabels = function (variant) {\r\n    var unresolvedVariant = variant instanceof MotionValue ? variant.get() : variant;\r\n    return Array.from(new Set(labelsToArray(unresolvedVariant)));\r\n};\r\n/**\r\n * Hooks in React sometimes accept a dependency array as their final argument. (ie useEffect/useMemo)\r\n * When values in this array change, React re-runs the dependency. However if the array\r\n * contains a variable number of items, React throws an error.\r\n */\r\nvar asDependencyList = function (list) { return [\r\n    list.join(\",\"),\r\n]; };\r\n\r\nvar hasVariantChanged = function (oldVariant, newVariant) {\r\n    return oldVariant.join(\",\") !== newVariant.join(\",\");\r\n};\r\n/**\r\n * Handle variants and the `animate` prop when its set as variant labels.\r\n *\r\n * @param initial - Initial variant(s)\r\n * @param animate - Variant(s) to animate to\r\n * @param inherit - `true` is inheriting animations from parent\r\n * @param controls - Animation controls\r\n *\r\n * @internal\r\n */\r\nfunction useVariants(initial, animate, inherit, controls) {\r\n    var targetVariants = resolveVariantLabels(animate);\r\n    var context = useContext(MotionContext);\r\n    var parentAlreadyMounted = context.hasMounted && context.hasMounted.current;\r\n    var hasMounted = useRef(false);\r\n    useEffect(function () {\r\n        var shouldAnimate = false;\r\n        if (inherit) {\r\n            // If we're inheriting variant changes and the parent has already\r\n            // mounted when this component loads, we need to manually trigger\r\n            // this animation.\r\n            shouldAnimate = !!parentAlreadyMounted;\r\n            targetVariants = resolveVariantLabels(context.animate);\r\n        }\r\n        else {\r\n            shouldAnimate =\r\n                hasMounted.current ||\r\n                    hasVariantChanged(resolveVariantLabels(initial), targetVariants);\r\n        }\r\n        shouldAnimate && controls.start(targetVariants);\r\n        hasMounted.current = true;\r\n    }, asDependencyList(targetVariants));\r\n}\r\n\r\n/**\r\n * `useAnimationGroupSubscription` allows a component to subscribe to an\r\n * externally-created `AnimationControls`, created by the `useAnimation` hook.\r\n *\r\n * @param animation\r\n * @param controls\r\n *\r\n * @internal\r\n */\r\nfunction useAnimationGroupSubscription(animation, controls) {\r\n    var unsubscribe = useMemo(function () { return animation.subscribe(controls); }, [\r\n        animation,\r\n    ]);\r\n    useEffect(function () { return function () {\r\n        unsubscribe && unsubscribe();\r\n    }; }, [unsubscribe]);\r\n}\r\n\r\nvar _a, _b;\r\nvar AnimatePropComponents = (_a = {},\r\n    _a[AnimatePropType.Target] = makeRenderlessComponent(function (_a) {\r\n        var animate = _a.animate, controls = _a.controls, visualElement = _a.visualElement, transition = _a.transition;\r\n        return useAnimateProp(animate, controls, visualElement, transition);\r\n    }),\r\n    _a[AnimatePropType.VariantLabel] = makeRenderlessComponent(function (_a) {\r\n        var animate = _a.animate, _b = _a.inherit, inherit = _b === void 0 ? true : _b, controls = _a.controls, initial = _a.initial;\r\n        return useVariants(initial, animate, inherit, controls);\r\n    }),\r\n    _a[AnimatePropType.AnimationSubscription] = makeRenderlessComponent(function (_a) {\r\n        var animate = _a.animate, controls = _a.controls;\r\n        return useAnimationGroupSubscription(animate, controls);\r\n    }),\r\n    _a);\r\nvar isVariantLabel$1 = function (prop) {\r\n    return Array.isArray(prop) || typeof prop === \"string\";\r\n};\r\nvar isAnimationSubscription = function (_a) {\r\n    var animate = _a.animate;\r\n    return animate instanceof AnimationControls;\r\n};\r\nvar animationProps = [\"initial\", \"animate\", \"whileTap\", \"whileHover\"];\r\nvar animatePropTypeTests = (_b = {},\r\n    _b[AnimatePropType.Target] = function (props) {\r\n        return (props.animate !== undefined &&\r\n            !isVariantLabel$1(props.animate) &&\r\n            !isAnimationSubscription(props));\r\n    },\r\n    _b[AnimatePropType.VariantLabel] = function (props) {\r\n        return (props.variants !== undefined ||\r\n            animationProps.some(function (key) { return typeof props[key] === \"string\"; }));\r\n    },\r\n    _b[AnimatePropType.AnimationSubscription] = isAnimationSubscription,\r\n    _b);\r\nvar getAnimationComponent = function (props) {\r\n    var animatePropType = undefined;\r\n    for (var key in AnimatePropType) {\r\n        if (animatePropTypeTests[key](props)) {\r\n            animatePropType = key;\r\n        }\r\n    }\r\n    return animatePropType ? AnimatePropComponents[animatePropType] : undefined;\r\n};\r\n\r\nfunction tweenAxis(target, prev, next, p) {\r\n    target.min = mix(prev.min, next.min, p);\r\n    target.max = mix(prev.max, next.max, p);\r\n}\r\n\r\nvar Presence;\r\n(function (Presence) {\r\n    Presence[Presence[\"Entering\"] = 0] = \"Entering\";\r\n    Presence[Presence[\"Present\"] = 1] = \"Present\";\r\n    Presence[Presence[\"Exiting\"] = 2] = \"Exiting\";\r\n})(Presence || (Presence = {}));\r\nvar VisibilityAction;\r\n(function (VisibilityAction) {\r\n    VisibilityAction[VisibilityAction[\"Hide\"] = 0] = \"Hide\";\r\n    VisibilityAction[VisibilityAction[\"Show\"] = 1] = \"Show\";\r\n})(VisibilityAction || (VisibilityAction = {}));\r\n\r\nvar progressTarget = 1000;\r\nvar Animate = /** @class */ (function (_super) {\r\n    __extends(Animate, _super);\r\n    function Animate() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.frameTarget = {\r\n            x: { min: 0, max: 0 },\r\n            y: { min: 0, max: 0 },\r\n        };\r\n        _this.stopAxisAnimation = {\r\n            x: undefined,\r\n            y: undefined,\r\n        };\r\n        _this.animate = function (target, origin, _a) {\r\n            if (_a === void 0) { _a = {}; }\r\n            var originBox = _a.originBox, targetBox = _a.targetBox, visibilityAction = _a.visibilityAction, config = __rest(_a, [\"originBox\", \"targetBox\", \"visibilityAction\"]);\r\n            var _b = _this.props, visualElement = _b.visualElement, layout = _b.layout;\r\n            /**\r\n             * Allow the measured origin (prev bounding box) and target (actual layout) to be\r\n             * overridden by the provided config.\r\n             */\r\n            origin = originBox || origin;\r\n            target = targetBox || target;\r\n            var boxHasMoved = hasMoved(origin, target);\r\n            var animations = eachAxis(function (axis) {\r\n                /**\r\n                 * If layout is set to \"position\", we can resize the origin box based on the target\r\n                 * box and only animate its position.\r\n                 */\r\n                if (layout === \"position\") {\r\n                    var targetLength = target[axis].max - target[axis].min;\r\n                    origin[axis].max = origin[axis].min + targetLength;\r\n                }\r\n                if (visualElement.isTargetBoxLocked) {\r\n                    return;\r\n                }\r\n                else if (visibilityAction !== undefined) {\r\n                    // If we're meant to show/hide the visualElement, do so\r\n                    visibilityAction === VisibilityAction.Hide\r\n                        ? visualElement.hide()\r\n                        : visualElement.show();\r\n                }\r\n                else if (boxHasMoved) {\r\n                    // If the box has moved, animate between it's current visual state and its\r\n                    // final state\r\n                    return _this.animateAxis(axis, target[axis], origin[axis], config);\r\n                }\r\n                else {\r\n                    // If the box has remained in the same place, immediately set the axis target\r\n                    // to the final desired state\r\n                    return visualElement.setAxisTarget(axis, target[axis].min, target[axis].max);\r\n                }\r\n            });\r\n            // Force a render to ensure there's no flash of uncorrected bounding box.\r\n            visualElement.render();\r\n            /**\r\n             * If this visualElement isn't present (ie it's been removed from the tree by the user but\r\n             * kept in by the tree by AnimatePresence) then call safeToRemove when all axis animations\r\n             * have successfully finished.\r\n             */\r\n            return Promise.all(animations).then(function () {\r\n                var _a, _b;\r\n                (_a = config.onLayoutAnimationComplete) === null || _a === void 0 ? void 0 : _a.call(config);\r\n                if (visualElement.isPresent) {\r\n                    visualElement.presence = Presence.Present;\r\n                }\r\n                else {\r\n                    (_b = config.onLayoutAnimationComplete) === null || _b === void 0 ? void 0 : _b.call(config);\r\n                    _this.safeToRemove();\r\n                }\r\n            });\r\n        };\r\n        return _this;\r\n    }\r\n    Animate.prototype.componentDidMount = function () {\r\n        var visualElement = this.props.visualElement;\r\n        visualElement.enableLayoutProjection();\r\n        this.unsubLayoutReady = visualElement.onLayoutUpdate(this.animate);\r\n    };\r\n    Animate.prototype.componentWillUnmount = function () {\r\n        var _this = this;\r\n        this.unsubLayoutReady();\r\n        eachAxis(function (axis) { var _a, _b; return (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a); });\r\n    };\r\n    /**\r\n     * TODO: This manually performs animations on the visualElement's layout progress\r\n     * values. It'd be preferable to amend the HTMLVisualElement.startLayoutAxisAnimation\r\n     * API to accept more custom animations like this.\r\n     */\r\n    Animate.prototype.animateAxis = function (axis, target, origin, _a) {\r\n        var _b, _c;\r\n        var _d = _a === void 0 ? {} : _a, transition = _d.transition, crossfadeOpacity = _d.crossfadeOpacity;\r\n        (_c = (_b = this.stopAxisAnimation)[axis]) === null || _c === void 0 ? void 0 : _c.call(_b);\r\n        var visualElement = this.props.visualElement;\r\n        var frameTarget = this.frameTarget[axis];\r\n        var layoutProgress = visualElement.axisProgress[axis];\r\n        /**\r\n         * Set layout progress back to 0. We set it twice to hard-reset any velocity that might\r\n         * be re-incoporated into a subsequent spring animation.\r\n         */\r\n        layoutProgress.clearListeners();\r\n        layoutProgress.set(0);\r\n        layoutProgress.set(0);\r\n        /**\r\n         * If this is a crossfade animation, create a function that updates both the opacity of this component\r\n         * and the one being crossfaded out.\r\n         */\r\n        var crossfade = crossfadeOpacity && this.createCrossfadeAnimation(crossfadeOpacity);\r\n        /**\r\n         * Create an animation function to run once per frame. This will tween the visual bounding box from\r\n         * origin to target using the latest progress value.\r\n         */\r\n        var frame = function () {\r\n            // Convert the latest layoutProgress, which is a value from 0-1000, into a 0-1 progress\r\n            var p = layoutProgress.get() / progressTarget;\r\n            // Tween the axis and update the visualElement with the latest values\r\n            tweenAxis(frameTarget, origin, target, p);\r\n            visualElement.setAxisTarget(axis, frameTarget.min, frameTarget.max);\r\n            // If this is a crossfade animation, update both elements.\r\n            crossfade === null || crossfade === void 0 ? void 0 : crossfade(p);\r\n        };\r\n        // Synchronously run a frame to ensure there's no flash of the uncorrected bounding box.\r\n        frame();\r\n        // Start the animation on this axis\r\n        var animation = startAnimation(axis === \"x\" ? \"layoutX\" : \"layoutY\", layoutProgress, progressTarget, transition || this.props.transition || defaultTransition);\r\n        // Create a function to stop animation on this specific axis\r\n        var unsubscribeProgress = layoutProgress.onChange(frame);\r\n        this.stopAxisAnimation[axis] = function () {\r\n            layoutProgress.stop();\r\n            unsubscribeProgress();\r\n        };\r\n        return animation;\r\n    };\r\n    Animate.prototype.createCrossfadeAnimation = function (crossfadeOpacity) {\r\n        var visualElement = this.props.visualElement;\r\n        var opacity = visualElement.getValue(\"opacity\", 0);\r\n        return function (p) {\r\n            opacity.set(easeCrossfadeIn(mix(0, 1, p)));\r\n            crossfadeOpacity.set(easeCrossfadeOut(mix(1, 0, p)));\r\n        };\r\n    };\r\n    Animate.prototype.safeToRemove = function () {\r\n        var _a, _b;\r\n        (_b = (_a = this.props).safeToRemove) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n    };\r\n    Animate.prototype.render = function () {\r\n        return null;\r\n    };\r\n    return Animate;\r\n}(Component));\r\nvar AnimateLayout = {\r\n    key: \"animate-layout\",\r\n    shouldRender: function (props) { return !!props.layout || !!props.layoutId; },\r\n    Component: function (props) {\r\n        var _a = usePresence(), safeToRemove = _a[1];\r\n        return createElement(Animate, __assign({}, props, { safeToRemove: safeToRemove }));\r\n    },\r\n};\r\nfunction hasMoved(a, b) {\r\n    return hasAxisMoved(a.x, b.x) || hasAxisMoved(a.y, b.y);\r\n}\r\nfunction hasAxisMoved(a, b) {\r\n    return a.min !== b.min || a.max !== b.max;\r\n}\r\nvar defaultTransition = {\r\n    duration: 0.45,\r\n    ease: [0.4, 0, 0.1, 1],\r\n};\r\nfunction compress(min, max, easing) {\r\n    return function (p) {\r\n        // Could replace ifs with clamp\r\n        if (p < min)\r\n            return 0;\r\n        if (p > max)\r\n            return 1;\r\n        return easing(progress(min, max, p));\r\n    };\r\n}\r\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\r\nvar easeCrossfadeOut = compress(0.5, 0.95, linear$1);\r\n\r\n/**\r\n * Default handlers for batching VisualElements\r\n */\r\nvar defaultHandler = {\r\n    measureLayout: function (child) { return child.measureLayout(); },\r\n    layoutReady: function (child) { return child.layoutReady(); },\r\n};\r\n/**\r\n * Sort VisualElements by tree depth, so we process the highest elements first.\r\n */\r\nvar sortByDepth = function (a, b) {\r\n    return a.depth - b.depth;\r\n};\r\n/**\r\n * Create a batcher to process VisualElements\r\n */\r\nfunction createBatcher() {\r\n    var queue = new Set();\r\n    var add = function (child) { return queue.add(child); };\r\n    var flush = function (_a) {\r\n        var _b = _a === void 0 ? defaultHandler : _a, measureLayout = _b.measureLayout, layoutReady = _b.layoutReady;\r\n        var order = Array.from(queue).sort(sortByDepth);\r\n        /**\r\n         * Write: Reset any transforms on children elements so we can read their actual layout\r\n         */\r\n        order.forEach(function (child) { return child.resetTransform(); });\r\n        /**\r\n         * Read: Measure the actual layout\r\n         */\r\n        order.forEach(measureLayout);\r\n        /**\r\n         * Write: Notify the VisualElements they're ready for further write operations.\r\n         */\r\n        order.forEach(layoutReady);\r\n        /**\r\n         * After all children have started animating, ensure any Entering components are set to Present.\r\n         * If we add deferred animations (set up all animations and then start them in two loops) this\r\n         * could be moved to the start loop. But it needs to happen after all the animations configs\r\n         * are generated in AnimateSharedLayout as this relies on presence data\r\n         */\r\n        order.forEach(function (child) {\r\n            if (child.isPresent)\r\n                child.presence = Presence.Present;\r\n        });\r\n        queue.clear();\r\n    };\r\n    return { add: add, flush: flush };\r\n}\r\nfunction isSharedLayout(context) {\r\n    return !!context.forceUpdate;\r\n}\r\nvar SharedLayoutContext = createContext(createBatcher());\r\n\r\n/**\r\n * This component is responsible for scheduling the measuring of the motion component\r\n */\r\nvar Measure = /** @class */ (function (_super) {\r\n    __extends(Measure, _super);\r\n    function Measure(props) {\r\n        var _this = _super.call(this, props) || this;\r\n        /**\r\n         * If this component isn't the child of a SyncContext, make it responsible for flushing\r\n         * the layout batcher\r\n         */\r\n        var syncLayout = props.syncLayout;\r\n        if (!isSharedLayout(syncLayout)) {\r\n            _this.componentDidUpdate = function () { return syncLayout.flush(); };\r\n        }\r\n        return _this;\r\n    }\r\n    /**\r\n     * If this is a child of a SyncContext, register the VisualElement with it on mount.\r\n     */\r\n    Measure.prototype.componentDidMount = function () {\r\n        var _a = this.props, syncLayout = _a.syncLayout, visualElement = _a.visualElement;\r\n        isSharedLayout(syncLayout) && syncLayout.register(visualElement);\r\n    };\r\n    /**\r\n     * If this is a child of a SyncContext, notify it that it needs to re-render. It will then\r\n     * handle the snapshotting.\r\n     *\r\n     * If it is stand-alone component, add it to the batcher.\r\n     */\r\n    Measure.prototype.getSnapshotBeforeUpdate = function () {\r\n        var _a = this.props, syncLayout = _a.syncLayout, visualElement = _a.visualElement;\r\n        if (isSharedLayout(syncLayout)) {\r\n            syncLayout.syncUpdate();\r\n        }\r\n        else {\r\n            visualElement.snapshotBoundingBox();\r\n            syncLayout.add(visualElement);\r\n        }\r\n        return null;\r\n    };\r\n    Measure.prototype.componentDidUpdate = function () { };\r\n    Measure.prototype.render = function () {\r\n        return null;\r\n    };\r\n    return Measure;\r\n}(React__default.Component));\r\nvar MeasureLayout = {\r\n    key: \"measure-layout\",\r\n    shouldRender: function (props) {\r\n        return !!props.drag || !!props.layout || !!props.layoutId;\r\n    },\r\n    Component: function (props) {\r\n        var syncLayout = useContext(SharedLayoutContext);\r\n        return React__default.createElement(Measure, __assign({}, props, { syncLayout: syncLayout }));\r\n    },\r\n};\r\n\r\n/**\r\n * Currently we load all features synchronously, but it would be better to offer multiple entry points\r\n * that allow these to be loaded in asynchronously.\r\n */\r\nvar defaultFeatures = [MeasureLayout, Drag, Gestures, Exit, AnimateLayout];\r\n/**\r\n * Load features via renderless components based on the provided MotionProps\r\n */\r\nfunction useFeatures(isStatic, visualElement, controls, props, context, parentContext, shouldInheritVariant) {\r\n    var plugins = useContext(MotionPluginContext);\r\n    // If this is a static component, or we're rendering on the server, we don't load\r\n    // any feature components\r\n    if (isStatic || typeof window === \"undefined\")\r\n        return null;\r\n    var allFeatures = __spreadArrays(defaultFeatures, plugins.features);\r\n    var numFeatures = allFeatures.length;\r\n    var features = [];\r\n    // TODO: Consolidate Animation feature loading strategy with other functionality components\r\n    var Animation = getAnimationComponent(props);\r\n    if (Animation) {\r\n        features.push(createElement(Animation, { key: \"animation\", initial: props.initial, animate: props.animate, variants: props.variants, transition: props.transition, controls: controls, inherit: shouldInheritVariant, visualElement: visualElement }));\r\n    }\r\n    // Decide which features we should render and add them to the returned array\r\n    for (var i = 0; i < numFeatures; i++) {\r\n        var _a = allFeatures[i], shouldRender = _a.shouldRender, key = _a.key, Component = _a.Component;\r\n        if (shouldRender(props, parentContext)) {\r\n            features.push(createElement(Component, __assign({ key: key }, props, { localContext: context, parentContext: parentContext, visualElement: visualElement, controls: controls })));\r\n        }\r\n    }\r\n    return features;\r\n}\r\n\r\nfunction useSnapshotOnUnmount(visualElement) {\r\n    var syncLayout = useContext(SharedLayoutContext);\r\n    useUnmountEffect(function () {\r\n        if (isSharedLayout(syncLayout))\r\n            syncLayout.remove(visualElement);\r\n    });\r\n}\r\n\r\n/**\r\n * Create a `motion` component.\r\n *\r\n * This function accepts a Component argument, which can be either a string (ie \"div\"\r\n * for `motion.div`), or an actual React component.\r\n *\r\n * Alongside this is a config option which provides a way of rendering the provided\r\n * component \"offline\", or outside the React render cycle.\r\n *\r\n * @internal\r\n */\r\nfunction createMotionComponent(Component, _a) {\r\n    var useVisualElement = _a.useVisualElement, render = _a.render, animationControlsConfig = _a.animationControlsConfig;\r\n    function MotionComponent(props, externalRef) {\r\n        var parentContext = useContext(MotionContext);\r\n        var shouldInheritVariant = checkShouldInheritVariant(props);\r\n        /**\r\n         * If a component isStatic, we only visually update it as a\r\n         * result of a React re-render, rather than any interactions or animations.\r\n         * If this component or any ancestor isStatic, we disable hardware acceleration\r\n         * and don't load any additional functionality.\r\n         */\r\n        var isStatic = parentContext.static || props.static || false;\r\n        /**\r\n         * Create a VisualElement for this component. A VisualElement provides a common\r\n         * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\r\n         * providing a way of rendering to these APIs outside of the React render loop\r\n         * for more performant animations and interactions\r\n         */\r\n        var visualElement = useVisualElement(Component, props, parentContext.visualElement, isStatic, externalRef);\r\n        /**\r\n         * Scrape MotionValues from props and add/remove them to/from\r\n         * the VisualElement as necessary.\r\n         */\r\n        useMotionValues(visualElement, props);\r\n        /**\r\n         * Create animation controls for the VisualElement. It might be\r\n         * interesting to try and combine this with VisualElement itself in a further refactor.\r\n         */\r\n        var controls = useVisualElementAnimation(visualElement, props, animationControlsConfig);\r\n        /**\r\n         * Build the MotionContext to pass on to the next `motion` component.\r\n         */\r\n        var context = useMotionContext(parentContext, controls, visualElement, isStatic, props);\r\n        /**\r\n         * Load features as renderless components unless the component isStatic\r\n         */\r\n        var features = useFeatures(isStatic, visualElement, controls, props, context, parentContext, shouldInheritVariant);\r\n        var component = render(Component, props, visualElement);\r\n        /**\r\n         *\r\n         */\r\n        useSnapshotOnUnmount(visualElement);\r\n        // The mount order and hierarchy is specific to ensure our element ref is hydrated by the time\r\n        // all plugins and features has to execute.\r\n        return (createElement(Fragment, null,\r\n            createElement(MotionContext.Provider, { value: context }, component),\r\n            features));\r\n    }\r\n    return forwardRef(MotionComponent);\r\n}\r\n\r\n/**\r\n * DOM-specific config for `motion` components\r\n */\r\nvar config = {\r\n    useVisualElement: useDomVisualElement,\r\n    render: render,\r\n    animationControlsConfig: {\r\n        makeTargetAnimatable: parseDomVariant,\r\n    },\r\n};\r\n/**\r\n * Convert any React component into a `motion` component. The provided component\r\n * **must** use `React.forwardRef` to the underlying DOM component you want to animate.\r\n *\r\n * ```jsx\r\n * const Component = React.forwardRef((props, ref) => {\r\n *   return <div ref={ref} />\r\n * })\r\n *\r\n * const MotionComponent = motion.custom(Component)\r\n * ```\r\n *\r\n * @public\r\n */\r\nfunction custom(Component) {\r\n    return createMotionComponent(Component, config);\r\n}\r\nvar componentCache = new Map();\r\nfunction get(target, key) {\r\n    if (key === \"custom\")\r\n        return target.custom;\r\n    if (!componentCache.has(key)) {\r\n        componentCache.set(key, createMotionComponent(key, config));\r\n    }\r\n    return componentCache.get(key);\r\n}\r\n/**\r\n * HTML & SVG components, optimised for use with gestures and animation. These can be used as\r\n * drop-in replacements for any HTML & SVG component, all CSS & SVG properties are supported.\r\n *\r\n * @public\r\n */\r\nvar motion = new Proxy({ custom: custom }, { get: get });\r\n\r\nfunction useForceUpdate() {\r\n    var _a = useState(0), forcedRenderCount = _a[0], setForcedRenderCount = _a[1];\r\n    return useCallback(function () { return setForcedRenderCount(forcedRenderCount + 1); }, [\r\n        forcedRenderCount,\r\n    ]);\r\n}\r\n\r\nvar presenceId = 0;\r\nfunction getPresenceId() {\r\n    var id = presenceId;\r\n    presenceId++;\r\n    return id;\r\n}\r\nvar PresenceChild = function (_a) {\r\n    var children = _a.children, initial = _a.initial, isPresent = _a.isPresent, onExitComplete = _a.onExitComplete, custom = _a.custom;\r\n    var presenceChildren = useConstant(newChildrenMap);\r\n    var context = {\r\n        id: useConstant(getPresenceId),\r\n        initial: initial,\r\n        isPresent: isPresent,\r\n        custom: custom,\r\n        onExitComplete: function (childId) {\r\n            presenceChildren.set(childId, true);\r\n            var allComplete = true;\r\n            presenceChildren.forEach(function (isComplete) {\r\n                if (!isComplete)\r\n                    allComplete = false;\r\n            });\r\n            allComplete && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\r\n        },\r\n        register: function (childId) {\r\n            presenceChildren.set(childId, false);\r\n            return function () { return presenceChildren.delete(childId); };\r\n        },\r\n    };\r\n    useMemo(function () {\r\n        presenceChildren.forEach(function (_, key) { return presenceChildren.set(key, false); });\r\n    }, [isPresent]);\r\n    return (createElement(PresenceContext.Provider, { value: context }, children));\r\n};\r\nfunction newChildrenMap() {\r\n    return new Map();\r\n}\r\n\r\nfunction getChildKey(child) {\r\n    return child.key || \"\";\r\n}\r\nfunction updateChildLookup(children, allChildren) {\r\n    var seenChildren = process.env.NODE_ENV !== \"production\" ? new Set() : null;\r\n    children.forEach(function (child) {\r\n        var key = getChildKey(child);\r\n        if (process.env.NODE_ENV !== \"production\" && seenChildren) {\r\n            if (seenChildren.has(key)) {\r\n                console.warn(\"Children of AnimatePresence require unique keys. \\\"\" + key + \"\\\" is a duplicate.\");\r\n            }\r\n            seenChildren.add(key);\r\n        }\r\n        allChildren.set(key, child);\r\n    });\r\n}\r\nfunction onlyElements(children) {\r\n    var filtered = [];\r\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\r\n    Children.forEach(children, function (child) {\r\n        if (isValidElement(child))\r\n            filtered.push(child);\r\n    });\r\n    return filtered;\r\n}\r\n/**\r\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\r\n *\r\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\r\n *\r\n * @library\r\n *\r\n * Any `Frame` components that have an `exit` property defined will animate out when removed from\r\n * the tree.\r\n *\r\n * ```jsx\r\n * import { Frame, AnimatePresence } from 'framer'\r\n *\r\n * // As items are added and removed from `items`\r\n * export function Items({ items }) {\r\n *   return (\r\n *     <AnimatePresence>\r\n *       {items.map(item => (\r\n *         <Frame\r\n *           key={item.id}\r\n *           initial={{ opacity: 0 }}\r\n *           animate={{ opacity: 1 }}\r\n *           exit={{ opacity: 0 }}\r\n *         />\r\n *       ))}\r\n *     </AnimatePresence>\r\n *   )\r\n * }\r\n * ```\r\n *\r\n * You can sequence exit animations throughout a tree using variants.\r\n *\r\n * @motion\r\n *\r\n * Any `motion` components that have an `exit` property defined will animate out when removed from\r\n * the tree.\r\n *\r\n * ```jsx\r\n * import { motion, AnimatePresence } from 'framer-motion'\r\n *\r\n * export const Items = ({ items }) => (\r\n *   <AnimatePresence>\r\n *     {items.map(item => (\r\n *       <motion.div\r\n *         key={item.id}\r\n *         initial={{ opacity: 0 }}\r\n *         animate={{ opacity: 1 }}\r\n *         exit={{ opacity: 0 }}\r\n *       />\r\n *     ))}\r\n *   </AnimatePresence>\r\n * )\r\n * ```\r\n *\r\n * You can sequence exit animations throughout a tree using variants.\r\n *\r\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\r\n * once all `motion` components have finished animating out. Likewise, any components using\r\n * `usePresence` all need to call `safeToRemove`.\r\n *\r\n * @public\r\n */\r\nvar AnimatePresence = function (_a) {\r\n    var children = _a.children, custom = _a.custom, _b = _a.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a.onExitComplete, exitBeforeEnter = _a.exitBeforeEnter;\r\n    // We want to force a re-render once all exiting animations have finished. We\r\n    // either use a local forceRender function, or one from a parent context if it exists.\r\n    var forceRender = useForceUpdate();\r\n    var layoutContext = useContext(SharedLayoutContext);\r\n    if (isSharedLayout(layoutContext)) {\r\n        forceRender = layoutContext.forceUpdate;\r\n    }\r\n    var isInitialRender = useRef(true);\r\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\r\n    var filteredChildren = onlyElements(children);\r\n    // Keep a living record of the children we're actually rendering so we\r\n    // can diff to figure out which are entering and exiting\r\n    var presentChildren = useRef(filteredChildren);\r\n    // A lookup table to quickly reference components by key\r\n    var allChildren = useRef(new Map())\r\n        .current;\r\n    // A living record of all currently exiting components.\r\n    var exiting = useRef(new Set()).current;\r\n    updateChildLookup(filteredChildren, allChildren);\r\n    // If this is the initial component render, just deal with logic surrounding whether\r\n    // we play onMount animations or not.\r\n    if (isInitialRender.current) {\r\n        isInitialRender.current = false;\r\n        return (createElement(Fragment, null, filteredChildren.map(function (child) { return (createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? undefined : false }, child)); })));\r\n    }\r\n    // If this is a subsequent render, deal with entering and exiting children\r\n    var childrenToRender = __spreadArrays(filteredChildren);\r\n    // Diff the keys of the currently-present and target children to update our\r\n    // exiting list.\r\n    var presentKeys = presentChildren.current.map(getChildKey);\r\n    var targetKeys = filteredChildren.map(getChildKey);\r\n    // Diff the present children with our target children and mark those that are exiting\r\n    var numPresent = presentKeys.length;\r\n    for (var i = 0; i < numPresent; i++) {\r\n        var key = presentKeys[i];\r\n        if (targetKeys.indexOf(key) === -1) {\r\n            exiting.add(key);\r\n        }\r\n        else {\r\n            // In case this key has re-entered, remove from the exiting list\r\n            exiting.delete(key);\r\n        }\r\n    }\r\n    // If we currently have exiting children, and we're deferring rendering incoming children\r\n    // until after all current children have exiting, empty the childrenToRender array\r\n    if (exitBeforeEnter && exiting.size) {\r\n        childrenToRender = [];\r\n    }\r\n    // Loop through all currently exiting components and clone them to overwrite `animate`\r\n    // with any `exit` prop they might have defined.\r\n    exiting.forEach(function (key) {\r\n        // If this component is actually entering again, early return\r\n        if (targetKeys.indexOf(key) !== -1)\r\n            return;\r\n        var child = allChildren.get(key);\r\n        if (!child)\r\n            return;\r\n        var insertionIndex = presentKeys.indexOf(key);\r\n        var onExit = function () {\r\n            allChildren.delete(key);\r\n            exiting.delete(key);\r\n            // Remove this child from the present children\r\n            var removeIndex = presentChildren.current.findIndex(function (presentChild) { return presentChild.key === key; });\r\n            presentChildren.current.splice(removeIndex, 1);\r\n            // Defer re-rendering until all exiting children have indeed left\r\n            if (!exiting.size) {\r\n                presentChildren.current = filteredChildren;\r\n                forceRender();\r\n                onExitComplete && onExitComplete();\r\n            }\r\n        };\r\n        childrenToRender.splice(insertionIndex, 0, createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom }, child));\r\n    });\r\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\r\n    // the same tree between renders\r\n    childrenToRender = childrenToRender.map(function (child) {\r\n        var key = child.key;\r\n        return exiting.has(key) ? (child) : (createElement(PresenceChild, { key: getChildKey(child), isPresent: true }, child));\r\n    });\r\n    presentChildren.current = childrenToRender;\r\n    if (process.env.NODE_ENV !== \"production\" &&\r\n        exitBeforeEnter &&\r\n        childrenToRender.length > 1) {\r\n        console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\r\n    }\r\n    return (createElement(Fragment, null, exiting.size\r\n        ? childrenToRender\r\n        : childrenToRender.map(function (child) { return cloneElement(child); })));\r\n};\r\n\r\nfunction createSwitchAnimation(child, stack) {\r\n    if (stack && child !== stack.lead) {\r\n        return { visibilityAction: VisibilityAction.Hide };\r\n    }\r\n    else if (stack &&\r\n        child.presence !== Presence.Entering &&\r\n        child === stack.lead &&\r\n        stack.lead !== stack.prevLead) {\r\n        return { visibilityAction: VisibilityAction.Show };\r\n    }\r\n    var originBox;\r\n    var targetBox;\r\n    if (child.presence === Presence.Entering) {\r\n        originBox = stack === null || stack === void 0 ? void 0 : stack.getFollowOrigin();\r\n    }\r\n    else if (child.presence === Presence.Exiting) {\r\n        targetBox = stack === null || stack === void 0 ? void 0 : stack.getFollowTarget();\r\n    }\r\n    return { originBox: originBox, targetBox: targetBox };\r\n}\r\nfunction createCrossfadeAnimation(child, stack) {\r\n    var _a, _b, _c;\r\n    var config = {};\r\n    var stackLead = stack && stack.lead;\r\n    var stackLeadPresence = stackLead === null || stackLead === void 0 ? void 0 : stackLead.presence;\r\n    if (stack && child === stackLead) {\r\n        if (child.presence === Presence.Entering) {\r\n            config.originBox = stack.getFollowOrigin();\r\n        }\r\n        else if (child.presence === Presence.Exiting) {\r\n            config.targetBox = stack.getFollowTarget();\r\n        }\r\n    }\r\n    else if (stack && child === stack.follow) {\r\n        config.transition = stack.getLeadTransition();\r\n        if (stackLeadPresence === Presence.Entering) {\r\n            config.targetBox = stack.getLeadTarget();\r\n        }\r\n        else if (stackLeadPresence === Presence.Exiting) {\r\n            config.originBox = stack.getLeadOrigin();\r\n        }\r\n    }\r\n    // If neither the lead or follow component is the root child of AnimatePresence,\r\n    // don't handle crossfade animations\r\n    if (!((_a = stack === null || stack === void 0 ? void 0 : stack.follow) === null || _a === void 0 ? void 0 : _a.isPresenceRoot) && !(stackLead === null || stackLead === void 0 ? void 0 : stackLead.isPresenceRoot)) {\r\n        return config;\r\n    }\r\n    if (!stack || child === stackLead) {\r\n        if (child.presence === Presence.Entering) {\r\n            config.crossfadeOpacity = (_b = stack === null || stack === void 0 ? void 0 : stack.follow) === null || _b === void 0 ? void 0 : _b.getValue(\"opacity\", 0);\r\n        }\r\n    }\r\n    else if (stack && child === stack.follow) {\r\n        if (!stackLead || stackLeadPresence === Presence.Entering) ;\r\n        else if (stackLeadPresence === Presence.Exiting) {\r\n            config.crossfadeOpacity = (_c = stack === null || stack === void 0 ? void 0 : stack.lead) === null || _c === void 0 ? void 0 : _c.getValue(\"opacity\", 1);\r\n        }\r\n    }\r\n    else {\r\n        config.visibilityAction = VisibilityAction.Hide;\r\n    }\r\n    return config;\r\n}\r\n\r\n/**\r\n * For each layout animation, we want to identify two components\r\n * within a stack that will serve as the \"lead\" and \"follow\" components.\r\n *\r\n * In the switch animation, the lead component performs the entire animation.\r\n * It uses the follow bounding box to animate out from and back to. The follow\r\n * component is hidden.\r\n *\r\n * In the crossfade animation, both the lead and follow components perform\r\n * the entire animation, animating from the follow origin bounding box to the lead\r\n * target bounding box.\r\n *\r\n * Generalising a stack as First In Last Out, *searching from the end* we can\r\n * generally consider the lead component to be:\r\n *  - If the last child is present, the last child\r\n *  - If the last child is exiting, the last *encountered* exiting component\r\n */\r\nfunction findLeadAndFollow(stack, _a) {\r\n    var prevLead = _a[0], prevFollow = _a[1];\r\n    var lead = undefined;\r\n    var leadIndex = 0;\r\n    var follow = undefined;\r\n    // Find the lead child first\r\n    var numInStack = stack.length;\r\n    var lastIsPresent = false;\r\n    for (var i = numInStack - 1; i >= 0; i--) {\r\n        var child = stack[i];\r\n        var isLastInStack = i === numInStack - 1;\r\n        if (isLastInStack)\r\n            lastIsPresent = child.isPresent;\r\n        if (lastIsPresent) {\r\n            lead = child;\r\n        }\r\n        else {\r\n            // If the child before this will be present, make this the\r\n            // lead.\r\n            var prev = stack[i - 1];\r\n            if (prev && prev.isPresent)\r\n                lead = child;\r\n        }\r\n        if (lead) {\r\n            leadIndex = i;\r\n            break;\r\n        }\r\n    }\r\n    if (!lead)\r\n        lead = stack[0];\r\n    // Find the follow child\r\n    follow = stack[leadIndex - 1];\r\n    // If the lead component is exiting, find the closest follow\r\n    // present component\r\n    if (lead) {\r\n        for (var i = leadIndex - 1; i >= 0; i--) {\r\n            var child = stack[i];\r\n            if (child.isPresent) {\r\n                follow = child;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    // If the lead has changed and the previous lead still exists in the\r\n    // stack, set it to the previous lead. This allows us to differentiate between\r\n    // a, b, c(exit) -> a, b(exit), c(exit)\r\n    // and\r\n    // a, b(exit), c -> a, b(exit), c(exit)\r\n    if (lead !== prevLead &&\r\n        !lastIsPresent &&\r\n        follow === prevFollow &&\r\n        stack.find(function (stackChild) { return stackChild === prevLead; })) {\r\n        lead = prevLead;\r\n    }\r\n    return [lead, follow];\r\n}\r\nvar LayoutStack = /** @class */ (function () {\r\n    function LayoutStack() {\r\n        this.order = [];\r\n        // Track whether we've ever had a child\r\n        this.hasChildren = false;\r\n    }\r\n    LayoutStack.prototype.add = function (child) {\r\n        var _a;\r\n        var layoutOrder = child.config.layoutOrder;\r\n        if (layoutOrder === undefined) {\r\n            this.order.push(child);\r\n        }\r\n        else {\r\n            var index = this.order.findIndex(function (stackChild) {\r\n                return layoutOrder <= (stackChild.config.layoutOrder || 0);\r\n            });\r\n            if (index === -1) {\r\n                child.presence = this.hasChildren\r\n                    ? Presence.Entering\r\n                    : Presence.Present;\r\n                index = this.order.length;\r\n            }\r\n            this.order.splice(index, 0, child);\r\n        }\r\n        /**\r\n         *\r\n         */\r\n        // Load previous values from snapshot into this child\r\n        // TODO Neaten up\r\n        // TODO Double check when reimplementing move\r\n        // TODO Add isDragging status and\r\n        if (this.snapshot) {\r\n            child.prevSnapshot = this.snapshot;\r\n            // TODO Remove in favour of above\r\n            child.prevViewportBox = this.snapshot.boundingBox;\r\n            var latest = this.snapshot.latestMotionValues;\r\n            for (var key in latest) {\r\n                if (!child.hasValue(key)) {\r\n                    child.addValue(key, motionValue(latest[key]));\r\n                }\r\n                else {\r\n                    (_a = child.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(latest[key]);\r\n                }\r\n            }\r\n        }\r\n        this.hasChildren = true;\r\n    };\r\n    LayoutStack.prototype.remove = function (child) {\r\n        var index = this.order.findIndex(function (stackChild) { return child === stackChild; });\r\n        if (index !== -1)\r\n            this.order.splice(index, 1);\r\n    };\r\n    LayoutStack.prototype.updateLeadAndFollow = function () {\r\n        this.prevLead = this.lead;\r\n        this.prevFollow = this.follow;\r\n        var _a = findLeadAndFollow(this.order, [\r\n            this.lead,\r\n            this.follow,\r\n        ]), lead = _a[0], follow = _a[1];\r\n        this.lead = lead;\r\n        this.follow = follow;\r\n    };\r\n    LayoutStack.prototype.updateSnapshot = function () {\r\n        if (!this.lead)\r\n            return;\r\n        var snapshot = {\r\n            boundingBox: this.lead.prevViewportBox,\r\n            latestMotionValues: {},\r\n        };\r\n        this.lead.forEachValue(function (value, key) {\r\n            var latest = value.get();\r\n            if (!isTransformProp(latest)) {\r\n                snapshot.latestMotionValues[key] = latest;\r\n            }\r\n        });\r\n        var dragControls = elementDragControls.get(this.lead);\r\n        if (dragControls && dragControls.isDragging) {\r\n            snapshot.isDragging = true;\r\n            snapshot.cursorProgress = dragControls.cursorProgress;\r\n        }\r\n        this.snapshot = snapshot;\r\n    };\r\n    LayoutStack.prototype.isLeadPresent = function () {\r\n        var _a;\r\n        return this.lead && ((_a = this.lead) === null || _a === void 0 ? void 0 : _a.presence) !== Presence.Exiting;\r\n    };\r\n    LayoutStack.prototype.shouldStackAnimate = function () {\r\n        return true;\r\n        // return this.lead && this.lead?.isPresent\r\n        //     ? this.lead?.props?._shouldAnimate === true\r\n        //     : this.follow && this.follow?.props._shouldAnimate === true\r\n    };\r\n    LayoutStack.prototype.getFollowOrigin = function () {\r\n        var _a;\r\n        // This shouldAnimate check is quite specifically a fix for the optimisation made in Framer\r\n        // where components are kept in the tree ready to be re-used\r\n        return this.follow // && this.follow.shouldAnimate\r\n            ? this.follow.prevViewportBox\r\n            : (_a = this.snapshot) === null || _a === void 0 ? void 0 : _a.boundingBox;\r\n    };\r\n    LayoutStack.prototype.getFollowTarget = function () {\r\n        var _a;\r\n        return (_a = this.follow) === null || _a === void 0 ? void 0 : _a.box;\r\n    };\r\n    LayoutStack.prototype.getLeadOrigin = function () {\r\n        var _a;\r\n        return (_a = this.lead) === null || _a === void 0 ? void 0 : _a.prevViewportBox;\r\n    };\r\n    LayoutStack.prototype.getLeadTarget = function () {\r\n        var _a;\r\n        return (_a = this.lead) === null || _a === void 0 ? void 0 : _a.box;\r\n    };\r\n    LayoutStack.prototype.getLeadTransition = function () {\r\n        var _a;\r\n        return (_a = this.lead) === null || _a === void 0 ? void 0 : _a.config.transition;\r\n    };\r\n    return LayoutStack;\r\n}());\r\n\r\n/**\r\n * @public\r\n */\r\nvar AnimateSharedLayout = /** @class */ (function (_super) {\r\n    __extends(AnimateSharedLayout, _super);\r\n    function AnimateSharedLayout() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        /**\r\n         * A list of all the children in the shared layout\r\n         */\r\n        _this.children = new Set();\r\n        /**\r\n         * As animate components with a defined `layoutId` are added/removed to the tree,\r\n         * we store them in order. When one is added, it will animate out from the\r\n         * previous one, and when it's removed, it'll animate to the previous one.\r\n         */\r\n        _this.stacks = new Map();\r\n        /**\r\n         * Track whether the component has mounted. If it hasn't, the presence of added children\r\n         * are set to Present, whereas if it has they're considered Entering\r\n         */\r\n        _this.hasMounted = false;\r\n        /**\r\n         * Track whether we already have an update scheduled. If we don't, we'll run snapshots\r\n         * and schedule one.\r\n         */\r\n        _this.updateScheduled = false;\r\n        /**\r\n         * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\r\n         */\r\n        _this.renderScheduled = false;\r\n        /**\r\n         * The methods provided to all children in the shared layout tree.\r\n         */\r\n        _this.syncContext = __assign(__assign({}, createBatcher()), { syncUpdate: function (force) { return _this.scheduleUpdate(force); }, forceUpdate: function () {\r\n                // By copying syncContext to itself, when this component re-renders it'll also re-render\r\n                // all children subscribed to the SharedLayout context.\r\n                _this.syncContext = __assign({}, _this.syncContext);\r\n                _this.scheduleUpdate(true);\r\n            }, register: function (child) { return _this.addChild(child); }, remove: function (child) { return _this.removeChild(child); } });\r\n        return _this;\r\n    }\r\n    AnimateSharedLayout.prototype.componentDidMount = function () {\r\n        this.hasMounted = true;\r\n        this.updateStacks();\r\n    };\r\n    AnimateSharedLayout.prototype.componentDidUpdate = function () {\r\n        this.startLayoutAnimation();\r\n    };\r\n    AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\r\n        this.renderScheduled = true;\r\n        return true;\r\n    };\r\n    AnimateSharedLayout.prototype.startLayoutAnimation = function () {\r\n        var _this = this;\r\n        /**\r\n         * Reset update and render scheduled status\r\n         */\r\n        this.renderScheduled = this.updateScheduled = false;\r\n        var type = this.props.type;\r\n        /**\r\n         * Update presence metadata based on the latest AnimatePresence status.\r\n         * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\r\n         */\r\n        this.children.forEach(function (child) {\r\n            if (!child.isPresent) {\r\n                child.presence = Presence.Exiting;\r\n            }\r\n            else if (child.presence !== Presence.Entering) {\r\n                child.presence =\r\n                    child.presence === Presence.Exiting\r\n                        ? Presence.Entering\r\n                        : Presence.Present;\r\n            }\r\n        });\r\n        /**\r\n         * In every layoutId stack, nominate a component to lead the animation and another\r\n         * to follow\r\n         */\r\n        this.updateStacks();\r\n        /**\r\n         * Decide which animation to use between shared layoutId components\r\n         */\r\n        var createAnimation = type === \"crossfade\"\r\n            ? createCrossfadeAnimation\r\n            : createSwitchAnimation;\r\n        /**\r\n         * Create a handler which we can use to flush the children animations\r\n         */\r\n        var handler = {\r\n            measureLayout: function (child) { return child.measureLayout(); },\r\n            layoutReady: function (child) {\r\n                var layoutId = child.layoutId;\r\n                child.layoutReady(createAnimation(child, _this.getStack(layoutId)));\r\n            },\r\n        };\r\n        /**\r\n         * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\r\n         * This requires some co-ordination across components to stop layout thrashing\r\n         * and ensure measurements are taken at the correct time.\r\n         *\r\n         * Here we use that same mechanism of schedule/flush.\r\n         */\r\n        this.children.forEach(function (child) { return _this.syncContext.add(child); });\r\n        this.syncContext.flush(handler);\r\n        /**\r\n         * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\r\n         */\r\n        this.stacks.forEach(function (stack) { return (stack.snapshot = undefined); });\r\n    };\r\n    AnimateSharedLayout.prototype.updateStacks = function () {\r\n        this.stacks.forEach(function (stack) { return stack.updateLeadAndFollow(); });\r\n    };\r\n    AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\r\n        if (force === void 0) { force = false; }\r\n        if (!(force || !this.updateScheduled))\r\n            return;\r\n        /**\r\n         * Flag we've scheduled an update\r\n         */\r\n        this.updateScheduled = true;\r\n        /**\r\n         * Snapshot children\r\n         */\r\n        this.children.forEach(function (child) { return child.snapshotBoundingBox(); });\r\n        /**\r\n         * Every child keeps a local snapshot, but we also want to record\r\n         * snapshots of the visible children as, if they're are being removed\r\n         * in this render, we can still access them.\r\n         */\r\n        this.stacks.forEach(function (stack) { return stack.updateSnapshot(); });\r\n        /**\r\n         * Force a rerender by setting state if we aren't already going to render.\r\n         */\r\n        if (force || !this.renderScheduled) {\r\n            this.renderScheduled = true;\r\n            this.forceUpdate();\r\n        }\r\n    };\r\n    AnimateSharedLayout.prototype.addChild = function (child) {\r\n        this.children.add(child);\r\n        this.addToStack(child);\r\n        child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\r\n    };\r\n    AnimateSharedLayout.prototype.removeChild = function (child) {\r\n        this.scheduleUpdate();\r\n        this.children.delete(child);\r\n        this.removeFromStack(child);\r\n    };\r\n    AnimateSharedLayout.prototype.addToStack = function (child) {\r\n        var stack = this.getStack(child.layoutId);\r\n        stack === null || stack === void 0 ? void 0 : stack.add(child);\r\n    };\r\n    AnimateSharedLayout.prototype.removeFromStack = function (child) {\r\n        var stack = this.getStack(child.layoutId);\r\n        stack === null || stack === void 0 ? void 0 : stack.remove(child);\r\n    };\r\n    /**\r\n     * Return a stack of animate children based on the provided layoutId.\r\n     * Will create a stack if none currently exists with that layoutId.\r\n     */\r\n    AnimateSharedLayout.prototype.getStack = function (id) {\r\n        if (id === undefined)\r\n            return;\r\n        // Create stack if it doesn't already exist\r\n        !this.stacks.has(id) && this.stacks.set(id, new LayoutStack());\r\n        return this.stacks.get(id);\r\n    };\r\n    AnimateSharedLayout.prototype.render = function () {\r\n        return (createElement(SharedLayoutContext.Provider, { value: this.syncContext }, this.props.children));\r\n    };\r\n    return AnimateSharedLayout;\r\n}(Component));\r\n\r\n/**\r\n * Creates a `MotionValue` to track the state and velocity of a value.\r\n *\r\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * export function MyComponent() {\r\n *   const scale = useMotionValue(1)\r\n *\r\n *   return <Frame scale={scale} />\r\n * }\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * export const MyComponent = () => {\r\n *   const scale = useMotionValue(1)\r\n *\r\n *   return <motion.div style={{ scale }} />\r\n * }\r\n * ```\r\n *\r\n * @param initial - The initial state.\r\n *\r\n * @public\r\n */\r\nfunction useMotionValue(initial) {\r\n    return useConstant(function () { return motionValue(initial); });\r\n}\r\n\r\n/**\r\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\r\n *\r\n * TODO: Remove and move to library\r\n *\r\n * @internal\r\n */\r\nfunction resolveMotionValue(value) {\r\n    var unwrappedValue = value instanceof MotionValue ? value.get() : value;\r\n    return isCustomValue(unwrappedValue)\r\n        ? unwrappedValue.toValue()\r\n        : unwrappedValue;\r\n}\r\n\r\nvar isCustomValueType = function (v) {\r\n    return typeof v === \"object\" && v.mix;\r\n};\r\nvar getMixer = function (v) { return (isCustomValueType(v) ? v.mix : undefined); };\r\nfunction transform() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    var useImmediate = !Array.isArray(args[0]);\r\n    var argOffset = useImmediate ? 0 : -1;\r\n    var inputValue = args[0 + argOffset];\r\n    var inputRange = args[1 + argOffset];\r\n    var outputRange = args[2 + argOffset];\r\n    var options = args[3 + argOffset];\r\n    var interpolator = interpolate(inputRange, outputRange, __assign({ mixer: getMixer(outputRange[0]) }, options));\r\n    return useImmediate ? interpolator(inputValue) : interpolator;\r\n}\r\n\r\nvar isTransformer = function (v) {\r\n    return typeof v === \"function\";\r\n};\r\nfunction useTransform(parent, customTransform, to, options) {\r\n    var comparitor = isTransformer(customTransform)\r\n        ? [parent]\r\n        : [parent, customTransform.join(\",\"), to === null || to === void 0 ? void 0 : to.join(\",\")];\r\n    var transformer = useMemo(function () {\r\n        return isTransformer(customTransform)\r\n            ? customTransform\r\n            : transform(customTransform, to, options);\r\n    }, comparitor);\r\n    var initialValue = transformer(parent.get());\r\n    var value = useMotionValue(initialValue);\r\n    // Handle subscription to parent\r\n    var unsubscribe = useRef();\r\n    useMemo(function () {\r\n        unsubscribe.current && unsubscribe.current();\r\n        unsubscribe.current = parent.onChange(function (v) { return value.set(transformer(v)); });\r\n        // Manually set with the latest parent value in case we've re-parented\r\n        value.set(initialValue);\r\n    }, [parent, value, transformer]);\r\n    useUnmountEffect(function () { return unsubscribe.current && unsubscribe.current(); });\r\n    return value;\r\n}\r\n\r\n// Keep things reasonable and avoid scale: Infinity. In practise we might need\r\n// to add another value, opacity, that could interpolate scaleX/Y [0,0.01] => [0,1]\r\n// to simply hide content at unreasonable scales.\r\nvar maxScale = 100000;\r\nvar invertScale = function (scale) {\r\n    return scale > 0.001 ? 1 / scale : maxScale;\r\n};\r\n/**\r\n * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse\r\n * of their respective parent scales.\r\n *\r\n * This is useful for undoing the distortion of content when scaling a parent component.\r\n *\r\n * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.\r\n * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output\r\n * of those instead.\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * const MyComponent = () => {\r\n *   const { scaleX, scaleY } = useInvertedScale()\r\n *   return <motion.div style={{ scaleX, scaleY }} />\r\n * }\r\n * ```\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * function MyComponent() {\r\n *   const { scaleX, scaleY } = useInvertedScale()\r\n *   return <Frame scaleX={scaleX} scaleY={scaleY} />\r\n * }\r\n * ```\r\n *\r\n * @public\r\n */\r\nfunction useInvertedScale(scale) {\r\n    var parentScaleX = useMotionValue(1);\r\n    var parentScaleY = useMotionValue(1);\r\n    var visualElement = useContext(MotionContext).visualElement;\r\n    invariant(!!(scale || visualElement), \"If no scale values are provided, useInvertedScale must be used within a child of another motion component.\");\r\n    if (scale) {\r\n        parentScaleX = scale.scaleX || parentScaleX;\r\n        parentScaleY = scale.scaleY || parentScaleY;\r\n    }\r\n    else if (visualElement) {\r\n        parentScaleX = visualElement.getValue(\"scaleX\", 1);\r\n        parentScaleY = visualElement.getValue(\"scaleY\", 1);\r\n    }\r\n    var scaleX = useTransform(parentScaleX, invertScale);\r\n    var scaleY = useTransform(parentScaleY, invertScale);\r\n    return { scaleX: scaleX, scaleY: scaleY };\r\n}\r\n\r\nfunction useOnChange(value, callback) {\r\n    useEffect(function () { return (isMotionValue(value) ? value.onChange(callback) : undefined); }, [value]);\r\n}\r\n\r\n/**\r\n * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.\r\n *\r\n * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber\r\n * to another `MotionValue`.\r\n *\r\n * @remarks\r\n *\r\n * ```jsx\r\n * const x = useSpring(0, { stiffness: 300 })\r\n * const y = useSpring(x, { damping: 10 })\r\n * ```\r\n *\r\n * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.\r\n * @param springConfig - Configuration options for the spring.\r\n * @returns `MotionValue`\r\n *\r\n * @public\r\n */\r\nfunction useSpring(source, config) {\r\n    if (config === void 0) { config = {}; }\r\n    var activeSpringAnimation = useRef(null);\r\n    var value = useMotionValue(isMotionValue(source) ? source.get() : source);\r\n    useMemo(function () {\r\n        return value.attach(function (v, set) {\r\n            if (activeSpringAnimation.current) {\r\n                activeSpringAnimation.current.stop();\r\n            }\r\n            activeSpringAnimation.current = spring(__assign({ from: value.get(), to: v, velocity: value.getVelocity() }, config)).start(set);\r\n            return value.get();\r\n        });\r\n    }, Object.values(config));\r\n    useOnChange(source, function (v) { return value.set(parseFloat(v)); });\r\n    return value;\r\n}\r\n\r\nfunction createScrollMotionValues() {\r\n    return {\r\n        scrollX: motionValue(0),\r\n        scrollY: motionValue(0),\r\n        scrollXProgress: motionValue(0),\r\n        scrollYProgress: motionValue(0),\r\n    };\r\n}\r\nfunction setProgress(offset, maxOffset, value) {\r\n    value.set(!offset || !maxOffset ? 0 : offset / maxOffset);\r\n}\r\nfunction createScrollUpdater(values, getOffsets) {\r\n    var update = function () {\r\n        var _a = getOffsets(), xOffset = _a.xOffset, yOffset = _a.yOffset, xMaxOffset = _a.xMaxOffset, yMaxOffset = _a.yMaxOffset;\r\n        // Set absolute positions\r\n        values.scrollX.set(xOffset);\r\n        values.scrollY.set(yOffset);\r\n        // Set 0-1 progress\r\n        setProgress(xOffset, xMaxOffset, values.scrollXProgress);\r\n        setProgress(yOffset, yMaxOffset, values.scrollYProgress);\r\n    };\r\n    update();\r\n    return update;\r\n}\r\n\r\nvar isBrowser$2 = typeof window !== \"undefined\";\r\nvar useIsomorphicLayoutEffect = isBrowser$2 ? useLayoutEffect : useEffect;\r\n\r\nvar getElementScrollOffsets = function (element) { return function () {\r\n    return {\r\n        xOffset: element.scrollLeft,\r\n        yOffset: element.scrollTop,\r\n        xMaxOffset: element.scrollWidth - element.offsetWidth,\r\n        yMaxOffset: element.scrollHeight - element.offsetHeight,\r\n    };\r\n}; };\r\n/**\r\n * Returns MotionValues that update when the provided element scrolls:\r\n *\r\n * - `scrollX` — Horizontal scroll distance in pixels.\r\n * - `scrollY` — Vertical scroll distance in pixels.\r\n * - `scrollXProgress` — Horizontal scroll progress between `0` and `1`.\r\n * - `scrollYProgress` — Vertical scroll progress between `0` and `1`.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * import * as React from \"react\"\r\n * import {\r\n *   Frame,\r\n *   useElementScroll,\r\n *   useTransform\r\n * } from \"framer\"\r\n *\r\n * export function MyComponent() {\r\n *   const ref = React.useRef()\r\n *   const { scrollYProgress } = useElementScroll(ref)\r\n *\r\n *   return (\r\n *     <Frame ref={ref}>\r\n *       <Frame scaleX={scrollYProgress} />\r\n *     </Frame>\r\n *   )\r\n * }\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * export const MyComponent = () => {\r\n *   const ref = useRef()\r\n *   const { scrollYProgress } = useElementScroll(ref)\r\n *\r\n *   return (\r\n *     <div ref={ref}>\r\n *       <motion.div style={{ scaleX: scrollYProgress }} />\r\n *     </div>\r\n *   )\r\n * }\r\n * ```\r\n *\r\n * @public\r\n */\r\nfunction useElementScroll(ref) {\r\n    var values = useConstant(createScrollMotionValues);\r\n    useIsomorphicLayoutEffect(function () {\r\n        var element = ref.current;\r\n        invariant(!!element, \"ref provided to useScroll must be passed into a HTML element.\");\r\n        if (!element)\r\n            return;\r\n        var updateScrollValues = createScrollUpdater(values, getElementScrollOffsets(element));\r\n        var scrollListener = addDomEvent(element, \"scroll\", updateScrollValues, { passive: true });\r\n        var resizeListener = addDomEvent(element, \"resize\", updateScrollValues);\r\n        return function () {\r\n            scrollListener && scrollListener();\r\n            resizeListener && resizeListener();\r\n        };\r\n    }, []);\r\n    return values;\r\n}\r\n\r\nvar viewportScrollValues = createScrollMotionValues();\r\nfunction getViewportScrollOffsets() {\r\n    return {\r\n        xOffset: window.pageXOffset,\r\n        yOffset: window.pageYOffset,\r\n        xMaxOffset: document.body.clientWidth - window.innerWidth,\r\n        yMaxOffset: document.body.clientHeight - window.innerHeight,\r\n    };\r\n}\r\nvar hasListeners = false;\r\nfunction addEventListeners() {\r\n    hasListeners = true;\r\n    if (typeof window === \"undefined\")\r\n        return;\r\n    var updateScrollValues = createScrollUpdater(viewportScrollValues, getViewportScrollOffsets);\r\n    addDomEvent(window, \"scroll\", updateScrollValues, { passive: true });\r\n    addDomEvent(window, \"resize\", updateScrollValues);\r\n}\r\n/**\r\n * Returns MotionValues that update when the viewport scrolls:\r\n *\r\n * - `scrollX` — Horizontal scroll distance in pixels.\r\n * - `scrollY` — Vertical scroll distance in pixels.\r\n * - `scrollXProgress` — Horizontal scroll progress between `0` and `1`.\r\n * - `scrollYProgress` — Vertical scroll progress between `0` and `1`.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * import * as React from \"react\"\r\n * import {\r\n *   Frame,\r\n *   useViewportScroll,\r\n *   useTransform\r\n * } from \"framer\"\r\n *\r\n * export function MyComponent() {\r\n *   const { scrollYProgress } = useViewportScroll()\r\n *   return <Frame scaleX={scrollYProgress} />\r\n * }\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * export const MyComponent = () => {\r\n *   const { scrollYProgress } = useViewportScroll()\r\n *   return <motion.div style={{ scaleX: scrollYProgress }} />\r\n * }\r\n * ```\r\n *\r\n * @public\r\n */\r\nfunction useViewportScroll() {\r\n    useIsomorphicLayoutEffect(function () {\r\n        !hasListeners && addEventListeners();\r\n    }, []);\r\n    return viewportScrollValues;\r\n}\r\n\r\n/**\r\n * Creates `AnimationControls`, which can be used to manually start, stop\r\n * and sequence animations on one or more components.\r\n *\r\n * The returned `AnimationControls` should be passed to the `animate` property\r\n * of the components you want to animate.\r\n *\r\n * These components can then be animated with the `start` method.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * import * as React from 'react'\r\n * import { Frame, useAnimation } from 'framer'\r\n *\r\n * export function MyComponent(props) {\r\n *    const controls = useAnimation()\r\n *\r\n *    controls.start({\r\n *        x: 100,\r\n *        transition: { duration: 0.5 },\r\n *    })\r\n *\r\n *    return <Frame animate={controls} />\r\n * }\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * import * as React from 'react'\r\n * import { motion, useAnimation } from 'framer-motion'\r\n *\r\n * export function MyComponent(props) {\r\n *    const controls = useAnimation()\r\n *\r\n *    controls.start({\r\n *        x: 100,\r\n *        transition: { duration: 0.5 },\r\n *    })\r\n *\r\n *    return <motion.div animate={controls} />\r\n * }\r\n * ```\r\n *\r\n * @returns Animation controller with `start` and `stop` methods\r\n *\r\n * @public\r\n */\r\nfunction useAnimation() {\r\n    var animationControls = useConstant(function () { return new AnimationControls(); });\r\n    useEffect(function () {\r\n        animationControls.mount();\r\n        return function () { return animationControls.unmount(); };\r\n    }, []);\r\n    return animationControls;\r\n}\r\n\r\n/**\r\n * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * import * as React from \"react\"\r\n * import { Frame, useCycle } from \"framer\"\r\n *\r\n * export function MyComponent() {\r\n *   const [x, cycleX] = useCycle(0, 50, 100)\r\n *\r\n *   return (\r\n *     <Frame\r\n *       animate={{ x: x }}\r\n *       onTap={() => cycleX()}\r\n *      />\r\n *    )\r\n * }\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * An index value can be passed to the returned `cycle` function to cycle to a specific index.\r\n *\r\n * ```jsx\r\n * import * as React from \"react\"\r\n * import { motion, useCycle } from \"framer-motion\"\r\n *\r\n * export const MyComponent = () => {\r\n *   const [x, cycleX] = useCycle(0, 50, 100)\r\n *\r\n *   return (\r\n *     <motion.div\r\n *       animate={{ x: x }}\r\n *       onTap={() => cycleX()}\r\n *      />\r\n *    )\r\n * }\r\n * ```\r\n *\r\n * @param items - items to cycle through\r\n * @returns [currentState, cycleState]\r\n *\r\n * @public\r\n */\r\nfunction useCycle() {\r\n    var items = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        items[_i] = arguments[_i];\r\n    }\r\n    // TODO: After Framer X beta, remove this warning\r\n    warning(items.length > 1, \"useCycle syntax has changed. `useCycle([0, 1, 2])` becomes `useCycle(0, 1, 2)`\");\r\n    var index = useRef(0);\r\n    var _a = useState(items[index.current]), item = _a[0], setItem = _a[1];\r\n    return [\r\n        item,\r\n        function (next) {\r\n            index.current =\r\n                typeof next !== \"number\"\r\n                    ? wrap(0, items.length, index.current + 1)\r\n                    : next;\r\n            setItem(items[index.current]);\r\n        },\r\n    ];\r\n}\r\n\r\n// Does this device prefer reduced motion? Returns `null` server-side.\r\nvar prefersReducedMotion = motionValue(null);\r\nif (typeof window !== \"undefined\") {\r\n    if (window.matchMedia) {\r\n        var motionMediaQuery_1 = window.matchMedia(\"(prefers-reduced-motion)\");\r\n        var setReducedMotionPreferences = function () {\r\n            return prefersReducedMotion.set(motionMediaQuery_1.matches);\r\n        };\r\n        motionMediaQuery_1.addListener(setReducedMotionPreferences);\r\n        setReducedMotionPreferences();\r\n    }\r\n    else {\r\n        prefersReducedMotion.set(false);\r\n    }\r\n}\r\nfunction determineShouldReduceMotion(prefersReduced, isReducedMotion) {\r\n    return typeof isReducedMotion === \"boolean\"\r\n        ? isReducedMotion\r\n        : Boolean(prefersReduced);\r\n}\r\n/**\r\n * A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.\r\n *\r\n * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing\r\n * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.\r\n *\r\n * It will actively respond to changes and re-render your components with the latest setting.\r\n *\r\n * ```jsx\r\n * export function Sidebar({ isOpen }) {\r\n *   const shouldReduceMotion = useReducedMotion()\r\n *   const closedX = shouldReduceMotion ? 0 : \"-100%\"\r\n *\r\n *   return (\r\n *     <motion.div animate={{\r\n *       opacity: isOpen ? 1 : 0,\r\n *       x: isOpen ? 0 : closedX\r\n *     }} />\r\n *   )\r\n * }\r\n * ```\r\n *\r\n * @return boolean\r\n *\r\n * @public\r\n */\r\nfunction useReducedMotion() {\r\n    var isReducedMotion = useContext(MotionContext).isReducedMotion;\r\n    var _a = useState(determineShouldReduceMotion(prefersReducedMotion.get(), isReducedMotion)), shouldReduceMotion = _a[0], setShouldReduceMotion = _a[1];\r\n    useEffect(function () {\r\n        return prefersReducedMotion.onChange(function (v) {\r\n            setShouldReduceMotion(determineShouldReduceMotion(v, isReducedMotion));\r\n        });\r\n    }, [setShouldReduceMotion, isReducedMotion]);\r\n    return shouldReduceMotion;\r\n}\r\n\r\n/**\r\n * Define accessibility options for a tree. Can be used to force the tree into Reduced Motion mode,\r\n * or disable device detection.\r\n *\r\n * @internal\r\n */\r\nfunction ReducedMotion(_a) {\r\n    var children = _a.children, enabled = _a.enabled;\r\n    var context = useContext(MotionContext);\r\n    context = useMemo(function () { return (__assign(__assign({}, context), { isReducedMotion: enabled })); }, [enabled]);\r\n    return (createElement(MotionContext.Provider, { value: context }, children));\r\n}\r\n\r\n/**\r\n * Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * const dragControls = useDragControls()\r\n *\r\n * function startDrag(event) {\r\n *   dragControls.start(event, { snapToCursor: true })\r\n * }\r\n *\r\n * return (\r\n *   <>\r\n *     <Frame onTapStart={startDrag} />\r\n *     <Frame drag=\"x\" dragControls={dragControls} />\r\n *   </>\r\n * )\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * const dragControls = useDragControls()\r\n *\r\n * function startDrag(event) {\r\n *   dragControls.start(event, { snapToCursor: true })\r\n * }\r\n *\r\n * return (\r\n *   <>\r\n *     <div onMouseDown={startDrag} />\r\n *     <motion.div drag=\"x\" dragControls={dragControls} />\r\n *   </>\r\n * )\r\n * ```\r\n *\r\n * @public\r\n */\r\nvar DragControls = /** @class */ (function () {\r\n    function DragControls() {\r\n        this.componentControls = new Set();\r\n    }\r\n    /**\r\n     * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.\r\n     *\r\n     * @internal\r\n     */\r\n    DragControls.prototype.subscribe = function (controls) {\r\n        var _this = this;\r\n        this.componentControls.add(controls);\r\n        return function () { return _this.componentControls.delete(controls); };\r\n    };\r\n    /**\r\n     * Start a drag gesture on every `motion` component that has this set of drag controls\r\n     * passed into it via the `dragControls` prop.\r\n     *\r\n     * ```jsx\r\n     * dragControls.start(e, {\r\n     *   snapToCursor: true\r\n     * })\r\n     * ```\r\n     *\r\n     * @param event - A mouse/touch/pointer event.\r\n     * @param options - Options\r\n     *\r\n     * @public\r\n     */\r\n    DragControls.prototype.start = function (event, options) {\r\n        this.componentControls.forEach(function (controls) {\r\n            controls.start(event.nativeEvent || event, options);\r\n        });\r\n    };\r\n    return DragControls;\r\n}());\r\nvar createDragControls = function () { return new DragControls(); };\r\n/**\r\n * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop\r\n * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we\r\n * might want to initiate that dragging from a different component than the draggable one.\r\n *\r\n * By creating a `dragControls` using the `useDragControls` hook, we can pass this into\r\n * the draggable component's `dragControls` prop. It exposes a `start` method\r\n * that can start dragging from pointer events on other components.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * const dragControls = useDragControls()\r\n *\r\n * function startDrag(event) {\r\n *   dragControls.start(event, { snapToCursor: true })\r\n * }\r\n *\r\n * return (\r\n *   <>\r\n *     <Frame onTapStart={startDrag} />\r\n *     <Frame drag=\"x\" dragControls={dragControls} />\r\n *   </>\r\n * )\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * const dragControls = useDragControls()\r\n *\r\n * function startDrag(event) {\r\n *   dragControls.start(event, { snapToCursor: true })\r\n * }\r\n *\r\n * return (\r\n *   <>\r\n *     <div onMouseDown={startDrag} />\r\n *     <motion.div drag=\"x\" dragControls={dragControls} />\r\n *   </>\r\n * )\r\n * ```\r\n *\r\n * @public\r\n */\r\nfunction useDragControls() {\r\n    return useConstant(createDragControls);\r\n}\r\n\r\n/**\r\n * Uses the ref that is passed in, or creates a new one\r\n * @param external - External ref\r\n * @internal\r\n */\r\nfunction useExternalRef(externalRef) {\r\n    // We're conditionally calling `useRef` here which is sort of naughty as hooks\r\n    // shouldn't be called conditionally. However, Framer Motion will break if this\r\n    // condition changes anyway. It might be possible to use an invariant here to\r\n    // make it explicit, but I expect changing `ref` is not normal behaviour.\r\n    var ref = !externalRef || typeof externalRef === \"function\"\r\n        ? useRef(null)\r\n        : externalRef;\r\n    // Handle `ref` functions. Again, calling the hook conditionally is kind of naughty\r\n    // but `ref` types changing between renders would break Motion anyway. If we receive\r\n    // bug reports about this, we should track the provided ref and throw an invariant\r\n    // rather than move the conditional to inside the useEffect as this will be fired\r\n    // for every Frame component within Framer.\r\n    if (externalRef && typeof externalRef === \"function\") {\r\n        useEffect(function () {\r\n            externalRef(ref.current);\r\n            return function () { return externalRef(null); };\r\n        }, []);\r\n    }\r\n    return ref;\r\n}\r\n\r\n/**\r\n * This is just a very basic VisualElement, more of a hack to keep supporting useAnimatedState with\r\n * the latest APIs.\r\n */\r\nvar StateVisualElement = /** @class */ (function (_super) {\r\n    __extends(StateVisualElement, _super);\r\n    function StateVisualElement() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.initialState = {};\r\n        return _this;\r\n    }\r\n    StateVisualElement.prototype.build = function () { };\r\n    StateVisualElement.prototype.clean = function () { };\r\n    StateVisualElement.prototype.getBoundingBox = function () {\r\n        return { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } };\r\n    };\r\n    StateVisualElement.prototype.readNativeValue = function (key) {\r\n        return this.initialState[key] || 0;\r\n    };\r\n    StateVisualElement.prototype.render = function () {\r\n        this.build();\r\n    };\r\n    return StateVisualElement;\r\n}(VisualElement));\r\n/**\r\n * This is not an officially supported API and may be removed\r\n * on any version.\r\n * @internal\r\n */\r\nfunction useAnimatedState(initialState) {\r\n    var _a = useState(initialState), animationState = _a[0], setAnimationState = _a[1];\r\n    var visualElement = useConstant(function () { return new StateVisualElement(); });\r\n    visualElement.updateConfig({\r\n        onUpdate: function (v) { return setAnimationState(__assign({}, v)); },\r\n    });\r\n    visualElement.initialState = initialState;\r\n    var controls = useVisualElementAnimation(visualElement, {}, {});\r\n    useEffect(function () {\r\n        visualElement.mount({});\r\n        return function () { return visualElement.unmount(); };\r\n    }, []);\r\n    var startAnimation = useConstant(function () { return function (animationDefinition) {\r\n        return controls.start(animationDefinition);\r\n    }; });\r\n    return [animationState, startAnimation];\r\n}\r\n\r\nexport { AnimatePresence, AnimateSharedLayout, AnimationControls, DragControls, MotionContext, MotionPluginContext, MotionPlugins, MotionValue, PresenceContext, ReducedMotion, VisualElementAnimationControls, addScaleCorrection, animationControls, createMotionComponent, isValidMotionProp, motion, motionValue, resolveMotionValue, transform, useAnimatedState, useAnimation, useCycle, useDomEvent, useDragControls, useElementScroll, useExternalRef, useGestures, useInvertedScale, useIsPresent, useMotionValue, usePanGesture, usePresence, useReducedMotion, useSpring, useTapGesture, useTransform, useViewportScroll };\r\n"]},"metadata":{},"sourceType":"module"}